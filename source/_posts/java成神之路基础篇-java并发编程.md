---
title: java成神之路基础篇-java并发编程
date: 2019-03-28 12:28:38
tags: [java]
categories: [java整理总结]
---
`前言`
> java成神之路基础篇之并发编程。
不积跬步无以至千里，不积小流无以成江海。
<!--more-->
**************

## Java 并发编程
### 并发与并行
- 什么是并发、什么是并行
> 并行：是两个任务同时运行，就是甲任务进行的同时，乙任务也在进行。(需要多核CPU)
并发：指两个任务都请求运行，而处理器只能按受一个任务，就把这两个任务安排轮流进行，由于时间间隔较短，使人感觉两个任务都在运行。（表面看是CPU在同时执行多个任务，其实实际上是因为CPU瞬间切换到其他任务的速度特别快，在不同的任务之间一直在不停的切换，给不同的任务分配了不同的时间。）

- 并发与并行的不同解释
  - 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生。
  - 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件。
  - 并发在一台处理器上“同时”处理多个任务，并行在多台处理器上同时处理多个任务

### 什么是线程，与进程的区别
#### 线程与进程的区别
- 定义

<table><td bgcolor=palegreen>
进程:具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位.
</table>
<table><td bgcolor=pink>
线程:进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源.
</table>


2.关系

一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行.

相对进程而言，线程是一个更加接近于执行体的概念，它可以与同进程中的其他线程共享数据，但拥有自己的栈空间，拥有独立的执行序列。



3.区别

　　进程和线程的主要差别在于它们是不同的操作系统资源管理方式。进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。

1) 简而言之,一个程序至少有一个进程,一个进程至少有一个线程.

2) 线程的划分尺度小于进程，使得多线程程序的并发性高。

3) 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。

4) 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。

5) 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。



4.优缺点

线程和进程在使用上各有优缺点：

线程执行开销小，但不利于资源的管理和保护；

而进程正相反。

同时，线程适合于在SMP机器上运行，而进程则可以跨机器迁移。
- 线程的实现
- 线程的状态、优先级
- 线程调度
- 创建线程的多种方式
- 守护线程

### 线程池
- 自己设计线程池
- submit() 和 execute()
- 线程池原理
- 为什么不允许使用 Executors 创建线程池

### 线程安全
- 死锁
- 死锁如何排查
- 线程安全和内存模型的关系

### 锁
- CAS
- 乐观锁与悲观锁
- 数据库相关锁机制
- 分布式锁
- 偏向锁
- 轻量级锁
- 重量级锁
- monitor
- 锁优化
- 锁消除
- 锁粗化
- 自旋锁
- 可重入锁
- 阻塞锁
- 死锁

### 死锁
- 什么是死锁
- 死锁如何解决

### synchronized
- synchronized 是如何实现的？
- synchronized 和 lock 之间关系
- 不使用 synchronized 如何实现一个线程安全的单例
- synchronized 和原子性、可见性和有序性之间的关系

### volatile
- happens-before
- 内存屏障
- 编译器指令重排和 CPU 指令重
- volatile 的实现原理
- volatile 和原子性
- 可见性和有序性之间的关系
- 有了 symchronized 为什么还需要 volatile

### sleep 和 wait
### wait 和 notify
### notify 和 notifyAll
### ThreadLocal
### 写一个死锁的程序
### 写代码来解决生产者消费者问题
### 并方包
- Thread
- Runnable
- Callable
- ReentrantLock
- ReentrantReadWriteLock
- Atomic*
- Semaphore
- CountDownLatch
- ConcurrentHashMap
- Executors
