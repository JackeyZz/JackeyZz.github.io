---
title: java成神之路基础篇-面向对象
date: 2019-03-01 16:02:01
tags: [java]
categories: [java整理总结]
---
`前言`
> java成神之路基础篇之面向对象，包括面向对象、平台无关性、值传递、封装、继承、多态
不积跬步无以至千里，不积小流无以成江海。
<!--more-->
**************

## 什么是面向对象
### 面向对象
Object Oriented简称OO ：像C++，JAVA等语言。  
面向对象是一种思想，是基于面向过程而言的。面向对象是将功能等封装至对象中，由对象实现解决问题的具体细节。因此不同于过程为主体的面向过程的思想，面向对象以对象，也就是数据为第一位，而方法或者是算法过程作为其次，这是对数据的一种优化，操作更加方便，简化了过程。  
通俗实例：A、B、C一起打牌。  
面向对象：`A.play_with(B, C)`或者`B.play_with(A, C)`或者`C.play_with(A, B)`  
解决问题：抽象出对象，由对象执行动作。  
### 面向过程
Procedure Oriented 简称PO ：像C语言。  
面向过程在解决问题时，会将解决问题的过程拆分成一个个子过程，即为一个个方法函数。然后按照一定的顺序执行完这些方法，问题也就解决了。
通俗实例：A、B、C一起打牌。
面向过程：`play_with(A, B, C)`
解决问题：拆分成动作，并将数据丢进去执行该动作。
### 面向对象的三大基本特征和五大基本原则
三大基本特征：
- 封装：由面向对象思想将事物的属性以及解决问题的动作封装为对象，即抽象为类。封装性为一种基本特征，区别为对象的创建(可见[博客入口](http://jackeyzzhold.xyz/2018/11/02/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%AF%B9%E8%B1%A1/#more))，是具体如何进行将事物抽象封装为对象的。
- 继承：
- 多态

五大基本原则：
- 单一职责原则(SRP)
- 开放封闭原则(OCP)
- 里氏替换原则(LSP)
- 依赖倒置原则(DIP)
- 接口分离原则(ISP)

#### 封装
封装，就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。
#### 继承
继承，指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过 “继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用 基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。
#### 多态
多态，是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。
#### 单一职责原则SRP(Single Responsibility Principle)
是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。

#### 开放封闭原则OCP(Open－Close Principle)
一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。

#### 里式替换原则LSP(the Liskov Substitution Principle LSP)
子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。

#### 依赖倒置原则DIP(the Dependency Inversion Principle DIP)
具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能 造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。

#### 接口分离原则ISP(the Interface Segregation Principle ISP)
模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来

#### 耦合
简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。

有软硬件之间的耦合，还有软件各模块之间的耦合。
耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。

耦合可以分为以下几种，它们之间的耦合度由高到低排列如下：
- 内容耦合。
当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。
- 公共耦合。
两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。
- 外部耦合。
一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。
- 控制耦合。
一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。
- 标记耦合。
若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。
数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。
- 非直接耦合。
两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。

`总结`:  
耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。

#### 内聚与耦合
内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。  
耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。  
内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。

## 平台无关性
java的虚拟机机制：
- 先编写`.java`后缀的源程序文件
- 然后编译成`.class`结尾的字节码文件
- 然后不同的平台有对应的java虚拟机(比如windows有windows的java虚拟机,linux有linux的java虚拟机),不同的虚拟机都可以将`.class`文件解释成对应机器的机器码,这样就实现了一份源码,可以在不同的平台运行的目的,这就是java的平台无关性。此处平台就是指不同的操作系统

### Java如何实现的平台无关性
java是一门高级语言，它通过其他的低级语言来实现一个虚拟机，虽然平台不同，但是也可以使用不同的技术来实现一个功能相近的虚拟机，然后java程序在虚拟机上运行，就“与平台无关”了。 而c和c++也可以跨平台，但是需要在不同平台下编译。  
java所宣扬的跨平台性实际上是所谓的“一次编译，到处执行”，即只需在一个地方编译，在其他各个平台下都可以执行。之所以会这样，是因为他们编译出来的东西是不同的，而且编译出来的东西运行在的地方也不同。
java编译出来的是一种“java字节码”，由虚拟机去解释执行。而c和c++则编译成了二进制，直接交由操作系统执行。
正是因为有了虚拟机，java才有了这样的一个特性。
#### Java从四个方面支持平台无关
- 最主要的是Java平台本身。Java平台扮演Java程序和所在的硬件与操作系统之间的缓冲角色。这样Java程序只需要与Java平台打交道，而不用管具体的操作系统。
- Java语言保证了基本数据类型的值域和行为都是由语言自己定义的。而C/C++中，基本数据类是由它的占位宽度决定的，占位宽度由所在平台决定的。不同平台编译同一个C++程序会出现不同的行为。通过保证基本数据类型在所有平台的一致性，Java语言为平台无关性提供强有力的支持。
- Java class文件。Java程序最终会被编译成二进制class文件。class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载运行。它的格式有着严格的定义，是平台无关的。
- 可伸缩性。Sun通过改变API的方式得到三个基础API集合，表现为Java平台不同的伸缩性：J2EE,J2SE,J2ME

#### 实现平台无关的7大步骤
- 选择程序运行的主机和设备集合（目标宿主机）
- 在目标宿主机中选择Java平台版本。
- 对于每个目标宿主机，选择程序将要运行的Java平台实现（目标运行时环境） 。
- 编写程序，调用Java API标准运行库（不调用本地方法，或者专门开发商专门调用本地方法的库）
- 编写程序，不依赖于垃圾收集器收集垃圾时间，不依赖线程的优先级
- 努力设计用户界面，在所有的目标宿主机都能正常工作
- 在所有目标运行时环境和所有目标宿主机进行测试

### JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）
## 值传递
> 形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了

> 实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。

### 值传递
在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。
`实例如下：`  
```java
public static void valueCrossTest(int age,float weight){
    System.out.println("传入的age："+age);
    System.out.println("传入的weight："+weight);
    age=33;
    weight=89.5f;
    System.out.println("方法内重新赋值后的age："+age);
    System.out.println("方法内重新赋值后的weight："+weight);
    }
//测试
public static void main(String[] args) {
        int a=25;
        float w=77.5f;
        valueCrossTest(a,w);
        System.out.println("方法执行后的age："+a);
        System.out.println("方法执行后的weight："+w);
      }
/*
传入的age：25
传入的weight：77.5

方法内重新赋值后的age：33
方法内重新赋值后的weight：89.5

方法执行后的age：25
方法执行后的weight：77.5
*/
```
`具体过程如下：`    
首先程序运行时，调用main()方法，此时JVM为main()方法往虚拟机栈中压入一个栈帧，即为当前栈帧，用来存放main()中的局部变量表(包括参数)、操作栈、方法出口等信息，如a和w都是main()方法中的局部变量，因此可以断定，a和w是躺着main方法所在的栈帧中。
![](java成神之路基础篇-面向对象/pic1.png)
而当执行到valueCrossTest()方法时，JVM也为其往虚拟机栈中压入一个栈，即为当前栈帧，用来存放valueCrossTest()中的局部变量等信息，因此age和weight是躺着valueCrossTest方法所在的栈帧中，而他们的值是从a和w的值copy了一份副本而得。
![](java成神之路基础篇-面向对象/pic2.png)
因而可以a和age、w和weight对应的内容是不一致的，所以当在方法内重新赋值时，实际流程如图：
![](java成神之路基础篇-面向对象/pic3.png)
也就是说，`age和weight的改动，只是改变了当前栈帧（valueCrossTest方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，main方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。`
`因此：`
> 值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。

### 引用传递
> ”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。

`实例1如下：`
```java
public class Person {
        private String name;
        private int age;
        public String getName() {
            return name;
        }
        public void setName(String name) {
            this.name = name;
        }
        public int getAge() {
            return age;
        }
        public void setAge(int age) {
            this.age = age;
        }
}
public static void PersonCrossTest(Person person){
         System.out.println("传入的person的name："+person.getName());
         person.setName("我是张小龙");
         System.out.println("方法内重新赋值后的name："+person.getName());
     }
//测试
public static void main(String[] args) {
        Person p=new Person();
        p.setName("我是马化腾");
        p.setAge(45);
        PersonCrossTest(p);
        System.out.println("方法执行后的name："+p.getName());
}
/*
传入的person的name：我是马化腾
方法内重新赋值后的name：我是张小龙
方法执行后的name：我是张小龙
*/
```
可以看出，person经过personCrossTest()方法的执行之后，内容发生了改变，这印证了上面所说的“引用传递”，对形参的操作，`改变了实际对象的内容`。
`实例2如下：增加一行代码`
```java
public static void PersonCrossTest(Person person){
        System.out.println("传入的person的name："+person.getName());
        person=new Person();//加多此行代码
        person.setName("我是张小龙");
        System.out.println("方法内重新赋值后的name："+person.getName());
    }
/*
传入的person的name：我是马化腾
方法内重新赋值后的name：我是张小龙
方法执行后的name：我是马化腾
*/
```
按照JVM内存模型可以知道，(`具体可见:`[博客入口](http://jackeyzzhold.xyz/2018/03/11/java-JVM/))，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到main（）方法中的下列代码时
```java
Person p=new Person();
p.setName("我是马化腾");
p.setAge(45);
PersonCrossTest(p);
```
JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：
![](java成神之路基础篇-面向对象/pic4.png)
当执行到PersonCrossTest()方法时，因为方法内有这么一行代码：`person = New Person()`
JVM需要在堆内另外开辟一块内存来存储new Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变。

可以推出：实参也应该指向了新创建的person对象的地址，所以在执行PersonCrossTest()结束之后，最终输出的应该是后面创建的对象内容。

然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。

`由此可见：引用传递，在Java中并不存在。`

但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？

这是因为：`无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。`
![](java成神之路基础篇-面向对象/pic5.png)
有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：

p和person都是指向同一个对象。

因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。而在第二个例子中，当执行到new Person()之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：

p依旧是指向旧的对象，person指向新对象的地址。

所以此时对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系。

`总结：`
> 因此可见：在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。只是在传递过程中：如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。

## 封装、继承、多态
### 什么是多态、方法重写与重载
### Java的继承与实现
### 构造函数与默认构造函数
### 类变量、成员变量与局部变量
### 成员变量与方法作用域
