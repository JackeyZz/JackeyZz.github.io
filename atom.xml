<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JackeyZz的博客主页</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-19T08:57:22.569Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JackeyZz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java编程思想-初始化与清理and访问权限控制</title>
    <link href="http://yoursite.com/2018/12/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86and%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2018/12/17/java编程思想-初始化与清理and访问权限控制/</id>
    <published>2018-12-17T08:26:52.000Z</published>
    <updated>2018-12-19T08:57:22.569Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/12/17/java编程思想-初始化与清理and访问权限控制/pic1.png" alt="">   </p><h2 id="基本类型的方法重载"><a href="#基本类型的方法重载" class="headerlink" title="基本类型的方法重载"></a>基本类型的方法重载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123; System.out.print(<span class="string">"f1(char)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">byte</span> x)</span></span>&#123; System.out.print(<span class="string">"f1(byte)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">short</span> x)</span></span>&#123; System.out.print(<span class="string">"f1(short)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; System.out.print(<span class="string">"f1(int)"</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">byte</span> x)</span></span>&#123; System.out.print(<span class="string">"f2(byte)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">short</span> x)</span></span>&#123; System.out.print(<span class="string">"f2(short)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; System.out.print(<span class="string">"f2(int)"</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">short</span> x)</span></span>&#123; System.out.print(<span class="string">"f3(short)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; System.out.print(<span class="string">"f3(int)"</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; System.out.print(<span class="string">"f4(int)"</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 小类型传入大类型的参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testChar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x = <span class="string">'x'</span>;</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);  <span class="comment">// output: f1(char);f2(int);f3(int);f4(int)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testByte</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> x = <span class="number">0</span>;</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);  <span class="comment">// output: f1(byte);f2(byte);f3(short);f(int)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testShort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> x = <span class="number">0</span>;</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);  <span class="comment">// output: f1(short);f2(short);f3(short);f4(int)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);  <span class="comment">// output: f1(int);f2(int);f3(int);f4(int)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 大类型传入小类型的参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    f4((<span class="keyword">int</span>)x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及基本类型的重载有两种情况<code>byte &gt; short &gt; int &gt; long &gt; float &gt; double</code>：</p><ul><li>实际值的数据类型比方法形参的数据类型要小时，实际数据类型会被提升。<code>char</code>若没有对应类型的形参，直接提升至<code>int</code></li><li>实际值的数据类型比方法形参的数据类型要大时，需要通过类型转换来执行窄化转换，否则编译器会报错</li></ul><h2 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h2><h3 id="在方法内部获得对当前对象的引用"><a href="#在方法内部获得对当前对象的引用" class="headerlink" title="在方法内部获得对当前对象的引用"></a>在方法内部获得对当前对象的引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function">Leaf <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Leaf x = <span class="keyword">new</span> Leaf();</span><br><span class="line">    x.increment().increment().increment().ptint();  <span class="comment">// output: i = 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>increment()</code>方法内部通过<code>this</code>关键字返回对当前对象的引用。</p><h3 id="将当前对象传递给其他方法"><a href="#将当前对象传递给其他方法" class="headerlink" title="将当前对象传递给其他方法"></a>将当前对象传递给其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">    Apple peeled = apple.getPeeled();</span><br><span class="line">    System.out.println(<span class="string">"JackeyZz"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Peeler</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Apple <span class="title">peel</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">  <span class="function">Apple <span class="title">getPeeled</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Peeler.peel(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassingThis</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Person.eat(<span class="keyword">new</span> Apple());         <span class="comment">// output: JackeyZz</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Apple</code>类需要调用<code>Peeler.peel()</code>方法，它是一个外部工具方法，将执行由于某种原因而必须放在<code>Apple</code>外部的操作(也许是因为该外部方法要应用到其他不同的类，避免重复代码),为了将其自身传递给外部方法，使用<code>this</code>关键字。</p><h3 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> petalCount = <span class="number">0</span>;</span><br><span class="line">  String s = <span class="string">"JackeyZz"</span>;</span><br><span class="line">  Flower(<span class="keyword">int</span> petals)&#123;</span><br><span class="line">    <span class="keyword">this</span>.petalCount = petals;</span><br><span class="line">  &#125;</span><br><span class="line">  Flower(String s)&#123;</span><br><span class="line">    <span class="keyword">this</span>.s = s;</span><br><span class="line">  &#125;</span><br><span class="line">  Flower(String s, <span class="keyword">int</span> petals)&#123;</span><br><span class="line">    <span class="keyword">this</span>(petals);</span><br><span class="line">    <span class="keyword">this</span>.s = s;</span><br><span class="line">  &#125;</span><br><span class="line">  Flower()&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"JackeyZz"</span>, <span class="number">47</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造器的几个特点：</p><ul><li>可用<code>this</code>调用一个构造器，但是不能同时调用两个构造器</li><li>必须将构造器调用置于最起始处，否则编译报错</li><li>除构造器外，编译器禁止在其他任何方法中调用构造器<h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3>在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布在方法定义之间，它们仍旧会在任何方法(包括构造器)被调用之前得到初始化。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span></span>&#123;</span><br><span class="line">  Window(<span class="keyword">int</span> marker)&#123;</span><br><span class="line">    System.out.print(<span class="string">"window("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span></span>&#123;</span><br><span class="line">  Window w1 =<span class="keyword">new</span> Window(<span class="number">1</span>);</span><br><span class="line">  House()&#123;</span><br><span class="line">    System.out.print(<span class="string">"house"</span>);</span><br><span class="line">    w3 = <span class="keyword">new</span> Window(<span class="number">33</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"f()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">House h = <span class="keyword">new</span> House();</span><br><span class="line">h.f();</span><br><span class="line"><span class="comment">// output: window(1) window(2) window(3) house window(33) f()</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3><p>无论创建多少个对象，静态数据都只占用一份存储区域。<code>static</code>关键字不能应用于局部变量，只能作用于域。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bowl</span></span>&#123;</span><br><span class="line">  Bowl(<span class="keyword">int</span> marker)&#123;</span><br><span class="line">    print(<span class="string">"Bowl("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</span><br><span class="line">    print(<span class="string">"f1("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Bowl b1 = <span class="keyword">new</span> Bowl(<span class="number">1</span>);</span><br><span class="line">  Table()&#123;</span><br><span class="line">    print(<span class="string">"table()"</span>);</span><br><span class="line">    b2.f1(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</span><br><span class="line">    print(<span class="string">"f2("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl b2 = <span class="keyword">new</span> Bowl(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cupboard</span></span>&#123;</span><br><span class="line">  Bowl b3 = <span class="keyword">new</span> Bowl(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">static</span> Bowl b4 = <span class="keyword">new</span> Bowl(<span class="number">4</span>);</span><br><span class="line">  Cupboard()&#123;</span><br><span class="line">    print(<span class="string">"cupboard()"</span>);</span><br><span class="line">    b4.f1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</span><br><span class="line">    print(<span class="string">"f3("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl b5 = <span class="keyword">new</span> Bowl(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    print(<span class="string">"test.."</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    print(<span class="string">"test.."</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    table.f2(<span class="number">1</span>);</span><br><span class="line">    cupboard.f3(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Table table = <span class="keyword">new</span> Table();</span><br><span class="line">  <span class="keyword">static</span> Cupboard cupboard = <span class="keyword">new</span> Cupboard();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* output:</span></span><br><span class="line"><span class="comment">* Bowl(1) Bowl(2) table() f1(1) Bowl(4) Bowl(5) Bowl(3) cupboard() f1(2)</span></span><br><span class="line"><span class="comment">* test.. Bowl(3) cupboard() f1(2) test.. Bowl(3) cupboard() f1(2) f2(1) f(2)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>静态数据初始化的几个特点：</p><ul><li>静态数据只有在第一次被访问时才会初始化，此后不会再次被初始化</li><li>初始化的顺序是先静态对象(倘若尚未由于对象创建而被初始化)，而后是“非静态”对象</li></ul><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><h2 id="java清理"><a href="#java清理" class="headerlink" title="java清理"></a>java清理</h2><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>GC垃圾收集机制具体可见：<a href="http://jackeyzzhold.xyz/2018/03/20/java-GC/" target="_blank" rel="noopener">博客入口</a></p><h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><code>finalize()</code>是<code>Object</code>的<code>protected</code>方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</li><li><code>finalize()</code>与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的<code>finalize</code>的调用具有不确定性</li><li>不建议用<code>finalize</code>方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在<code>finalize</code>方法中显式调用其他资源释放方法。</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如<code>System.runFinalizersOnExit()</code>方法、<code>Runtime.runFinalizersOnExit()</code>方法</li><li><code>System.gc()</code>与<code>System.runFinalization()</code>方法增加了<code>finalize</code>方法执行的机会，但不可盲目依赖它们</li><li>Java语言规范并不保证<code>finalize</code>方法会被及时地执行、而且根本不会保证它们会被执行</li><li><code>finalize</code>方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成<code>finalize</code>的执行</li><li>对象再生问题：<code>finalize</code>方法中，可将待回收对象赋值给<code>GC Roots</code>可达的对象引用，从而达到对象再生的目的</li><li><code>finalize</code>方法至多由GC执行一次(用户当然可以手动调用对象的<code>finalize</code>方法，但并不影响GC对<code>finalize</code>的行为)</li></ul><h4 id="执行过程-生命周期"><a href="#执行过程-生命周期" class="headerlink" title="执行过程(生命周期)"></a>执行过程(生命周期)</h4><ol><li>首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</li><li>具体的finalize流程：<br>对象可由两种状态，涉及到两类状态空间，一是终结状态空间 <code>F = {unfinalized, finalizable, finalized}</code>；二是可达状态空间 <code>R = {reachable, finalizer-reachable, unreachable}</code>。各状态含义如下：<ul><li>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</li><li>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</li><li>finalized: 表示GC已经对该对象执行过finalize方法</li><li>reachable: 表示GC Roots引用可达</li><li>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</li><li>unreachable：对象不可通过上面两种途径可达</li></ul></li></ol><p>状态变迁图：<br><img src="/2018/12/17/java编程思想-初始化与清理and访问权限控制/pic2.png" alt=""><br>变迁说明：</p><ol><li>新建对象首先处于<code>[reachable, unfinalized]</code>状态(A)</li><li>随着程序的运行，一些引用关系会消失，导致状态变迁，从<code>reachable</code>状态变迁到<code>f-reachable(B, C, D)</code>或<code>unreachable(E, F)</code>状态</li><li>若JVM检测到处于<code>unfinalized</code>状态的对象变成<code>f-reachable</code>或<code>unreachable</code>，JVM会将其标记为<code>finalizable</code>状态(G,H)。若对象原处于<code>[unreachable, unfinalized]</code>状态，则同时将其标记为<code>f-reachable(H)</code>。</li><li>在某个时刻，JVM取出某个<code>finalizable</code>对象，将其标记为<code>finalized</code>并在某个线程中执行其<code>finalize</code>方法。由于是在活动线程中引用了该对象，该对象将变迁到<code>(reachable, finalized)</code>状态(K或J)。该动作将影响某些其他对象从<code>f-reachable</code>状态重新回到<code>reachable</code>状态<code>(L, M, N)</code></li><li>处于<code>finalizable</code>状态的对象不能同时是<code>unreahable</code>的，由第4点可知，将对象<code>finalizable</code>对象标记为<code>finalized</code>时会由某个线程执行该对象的<code>finalize</code>方法，致使其变成<code>reachable</code>。这也是图中只有八个状态点的原因</li><li>程序员手动调用<code>finalize</code>方法并不会影响到上述内部标记的变化，因此JVM只会至多调用<code>finalize</code>一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为</li><li>若JVM检测到<code>finalized</code>状态的对象变成<code>unreachable</code>，回收其内存(I)</li><li>若对象并未覆盖<code>finalize</code>方法，JVM会进行优化，直接回收对象（O）</li><li>注：<code>System.runFinalizersOnExit()</code>等方法可以使对象即使处于<code>reachable</code>状态，JVM仍对其执行<code>finalize</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   对象复活</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 新建对象，因为SAVE_HOOK指向这个对象，对象此时的状态是(reachable,unfinalized)</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> GC();</span><br><span class="line">        <span class="comment">//将SAVE_HOOK设置成null，此时刚才创建的对象就不可达了，因为没有句柄再指向它了，对象此时状态是(unreachable，unfinalized)</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//强制系统执行垃圾回收，系统发现刚才创建的对象处于unreachable状态，并检测到这个对象的类覆盖了finalize方法，因此把这个对象放入F-Queue队列，由低优先级线程执行它的finalize方法，此时对象的状态变成(unreachable, finalizable)或者是(finalizer-reachable,finalizable)</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// sleep，目的是给低优先级线程从F-Queue队列取出对象并执行其finalize方法提供机会。在执行完对象的finalize方法中的super.finalize()时，对象的状态变成(unreachable,finalized)状态，但接下来在finalize方法中又执行了SAVE_HOOK = this;这句话，又有句柄指向这个对象了，对象又可达了。因此对象的状态又变成了(reachable, finalized)状态。</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 这里楼主说对象处于(reachable,finalized)状态应该是合理的。对象的finalized方法被执行了，因此是finalized状态。又因为在finalize方法是执行了SAVE_HOOK=this这句话，本来是unreachable的对象，又变成reachable了。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123; <span class="comment">//此时对象应该处于(reachable, finalized)状态</span></span><br><span class="line">            <span class="comment">// 这句话会输出，注意对象由unreachable，经过finalize复活了。</span></span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再一次将SAVE_HOOK放空，此时刚才复活的对象，状态变成(unreachable,finalized)</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 再一次强制系统回收垃圾，此时系统发现对象不可达，虽然覆盖了finalize方法，但已经执行过了，因此直接回收。</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 为系统回收垃圾提供机会</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123;</span><br><span class="line">            <span class="comment">// 这句话不会输出，因为对象已经彻底消失了。</span></span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"execute method finalize()"</span>);</span><br><span class="line">       <span class="comment">// 这句话让对象的状态由unreachable变成reachable，就是对象复活</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java访问权限"><a href="#java访问权限" class="headerlink" title="java访问权限"></a>java访问权限</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/12/17/java编程思想-初始化与清理and访问权限控制/pic1.png&quot; alt=&quot;&quot;&gt;   &lt;/p&gt;
&lt;h2 id=&quot;基本类型的方法重载&quot;&gt;&lt;a href=&quot;#基本类型的方法重载&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想-操作符and控制流程</title>
    <link href="http://yoursite.com/2018/12/14/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E6%93%8D%E4%BD%9C%E7%AC%A6and%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/14/java编程思想-操作符and控制流程/</id>
    <published>2018-12-14T05:51:34.000Z</published>
    <updated>2018-12-14T11:54:41.187Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/12/14/java编程思想-操作符and控制流程/pic1.png" alt="">                                                                    </p><h2 id="java操作符"><a href="#java操作符" class="headerlink" title="java操作符"></a>java操作符</h2><h3 id="对象赋值"><a href="#对象赋值" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>对对象赋值实际是对对象引用进行操作，是将引用从一个地方复制到另一个地方，即假设<code>c=d</code>，那么c和d都指向原本只有d指向的那个对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line">Tank t1 = <span class="keyword">new</span> Tank();</span><br><span class="line">Tank t2 = <span class="keyword">new</span> Tank();</span><br><span class="line">t1.level = <span class="number">9</span>;</span><br><span class="line">t2.level = <span class="number">47</span>;</span><br><span class="line">t1 = t2;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* output:</span></span><br><span class="line"><span class="comment">* t1.level = 47</span></span><br><span class="line"><span class="comment">* t2.level = 47</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">t1.level = <span class="number">27</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* output:</span></span><br><span class="line"><span class="comment">* t1.level = 27</span></span><br><span class="line"><span class="comment">* t2.level = 27</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>这是由于<code>t1 = t2</code>导致两个引用都指向了同一个对象，而原本<code>t1</code>指向的值为9的对象丢失最终被垃圾回收器自动清理。这个现象通常称作“别名现象”，为避免这种现象，可以<code>t1.level = t2.level</code></p><h3 id="对象的比较"><a href="#对象的比较" class="headerlink" title="对象的比较"></a>对象的比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer n1 = <span class="keyword">new</span> Integer(<span class="number">47</span>);</span><br><span class="line">Integer n2 = <span class="keyword">new</span> Integer(<span class="number">47</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* n1 == n2   output : false;</span></span><br><span class="line"><span class="comment">* n1 != n2   output : true;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>虽然两个对象的值一样，但是==与!=比较的是对象的引用，因此得到的结果如上。若要比较对象的实际内容，可用<code>n1.equals(n2)</code>。但是在自己实现的类中使用<code>.equals()</code>还是无法比较对象的实际内容，这是由于<code>.equals()</code>默认行为是比较引用的，除非在自己类中覆盖<code>.equals()</code>方法，而在大多数的Java类库中都实现了<code>.equals()</code>。</p><h3 id="对char、byte、short类型进行移位处理"><a href="#对char、byte、short类型进行移位处理" class="headerlink" title="对char、byte、short类型进行移位处理"></a>对char、byte、short类型进行移位处理</h3><p>对char、byte、short类型进行移位处理之前，需要转成int型，并且得到的结果也是int类型的值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/12/14/java编程思想-操作符and控制流程/pic1.png&quot; alt=&quot;&quot;&gt;                                                                    &lt;/p&gt;
&lt;h2 i
      
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想-对象</title>
    <link href="http://yoursite.com/2018/11/02/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/02/java编程思想-对象/</id>
    <published>2018-11-02T05:47:35.000Z</published>
    <updated>2018-12-13T15:49:56.969Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2018/11/02/java编程思想-对象/Java-对象.png" alt=""></p><h2 id="对象、对象引用、句柄"><a href="#对象、对象引用、句柄" class="headerlink" title="对象、对象引用、句柄"></a>对象、对象引用、句柄</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Light it = <span class="keyword">new</span> Light();</span><br><span class="line">it.on();</span><br></pre></td></tr></table></figure><p>上述例子中，类的名称为<code>Light</code>，调用<code>new</code>方法创建类<code>Light</code>的新对象，然后用对象引用<code>it</code>关联创建的新对象。<code>.on()</code>作为类对象的接口，向对象发出请求执行任务。<br>通常对象需要关联引用才能够传递消息，执行任务；引用可以单独存在。</p><h3 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h3><p>在Java里面，对象有五大基本特性</p><ul><li>万物皆为对象：不仅仅是基本数据变量，可以是任何概念化构件</li><li>程序是对象的集合，通过发送消息来告知彼此所要做的                             </li><li>每个对象都有自己的由其他对象所构成的存储</li><li>每个对象都是某个类的一个实例</li><li>某一特定类型的所有对象都可以接受同样的消息</li></ul><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)<br><img src="/2018/11/02/java编程思想-对象/pic1.png" alt=""><br>从上面的这张图里面可以看出，对象在内存中的结构主要包含以下几个部分：</p><ul><li>Mark Word(标记字段)：对象的Mark Word部分占4个字节，其内容是一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。</li><li>class Pointer（Class对象指针）：Class对象指针的大小也是4个字节，其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址</li><li>对象实际数据：这里面包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节</li><li>对齐：最后一部分是对齐填充的字节，按8个字节填充。</li></ul><p>对象存储布局具体可见：<a href="https://www.cnblogs.com/duanxz/p/4967042.html" target="_blank" rel="noopener">博客入口</a></p><h3 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h3><p>java中的引用类型可分为：</p><ul><li>强引用：默认的引用类型，例如<code>StringBuffer buffer = new StringBuffer()</code>，就是<code>buffer</code>变量持有的为<code>StringBuilder</code>的强引用类型。</li><li>软引用：即<code>SoftReference</code>，其指向的对象只有在内存不足的时候进行回收。</li><li>弱引用：即<code>WeakReference</code>,其指向的对象在GC执行时会被回收。</li><li>虚引用：即<code>PhantomReference</code>,与<code>ReferenceQueue</code>结合，用作记录该引用指向的对象已被销毁。</li></ul><p>java虚拟机(JVM)是通过某些数据类型来执行计算的，其数据类型可分为：基本类型、引用类型和null类型。其中引用类型可分为：</p><ul><li>类类型：对类实例的引用</li><li>接口类型：对实现了该接口的某个类实例的引用</li><li>数组类型：对数组对象的引用，在JVM中，数组是个真正的对象</li></ul><p>JVM数据访问方式：</p><ul><li>句柄形式：引用指向句柄，句柄包含对象地址和对象类型</li><li>指针：直接存储对象地址<br>指针比句柄少一步，访问更快；但是值发生改变时，前者引用不用变，后者要改变指针。</li></ul><p>对象的访问定位：<br>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面只规定了是一个指向对象的引用，并没有定义这个引用应该通过什么种方式去定位、访问到堆中的对象的具体位置，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用句柄和直接指针两种。<br>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。<br><img src="/2018/11/02/java编程思想-对象/pic2.png" alt=""><br>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址<br><img src="/2018/11/02/java编程思想-对象/pic3.png" alt=""><br>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。<br>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。从上一部分讲解的对象内存布局可以看出，就虚拟机HotSpot而言，它是使用第二种方式进行对象访问，但在整个软件开发的范围来看，各种语言、框架中使用句柄来访问的情况也十分常见。</p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><p>通常用<code>new</code>操作符来创建一个新的对象。</p><p>Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常(例外：克隆、反序列化)仅仅是一个<code>new</code>关键字而已，而在虚拟机中，对象(本文中讨论的对象限于普通Java对象，不包括数组和Class对象等)的创建又是怎样一个过程呢？<br>虚拟机遇到一条<code>new</code>指令时，</p><ul><li>首先jvm要检查类A是否已经被加载到了内存，即类的符号引用是否已经在常量池中，并且检查这个符号引用代表的类是否已被加载、解析和初始化过的。如果还没有，需要先触发类的加载、解析、初始化。然后在堆上创建对象。</li><li><p>为新生对象分配内存。<br>对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务具体便等同于一块确定大小 的内存从Java堆中划分出来，怎么划呢？</p><ul><li>假设Java堆中内存是绝对规整的，所有用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作 为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。</li><li>如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。</li></ul><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此</p><ul><li>在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，</li><li>而使用CMS这种基于Mark-Sweep算法的收集器时（说明一下，CMS收集器可以通过UseCMSCompactAtFullCollection或CMSFullGCsBeforeCompaction来整理内存），就通常采用空闲列表。</li></ul><p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。解决这个问题有两个方案，</p><ul><li>一种是对分配内存空间的动作进行同步——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；</li><li>另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</li></ul></li><li>完成实例数据部分的初始化工作（初始化为0值）<br>内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB的话，这一个工作也可以提前至TLAB分配时进行。这 步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li>完成对象头的填充：如对象自身的运行时数据、类型指针等。</li></ul><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。<br>在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，初始化才正式开始，开始调用<init>方法完成初始复制和构造函数，所有的字段都为零值。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执 行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。<br>下面代码是HotSpot虚拟机bytecodeInterpreter.cpp中的代码片段（这个解释器实现很少机会实际使用，大部分平台上都使用模板 解释器；当代码通过JIT编译器执行时差异就更大了。不过这段代码用于了解HotSpot的运作过程是没有什么问题的）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保常量池中存放的是已解释的类</span></span><br><span class="line">    <span class="keyword">if</span> (!constants-&gt;tag_at(index).is_unresolved_klass()) &#123;</span><br><span class="line">      <span class="comment">// 断言确保是klassOop和instanceKlassOop（这部分下一节介绍）</span></span><br><span class="line">      oop entry = (klassOop) *constants-&gt;obj_at_addr(index);</span><br><span class="line">      assert(entry-&gt;is_klass(), <span class="string">"Should be resolved klass"</span>);</span><br><span class="line">      klassOop k_entry = (klassOop) entry;</span><br><span class="line">      assert(k_entry-&gt;klass_part()-&gt;oop_is_instance(), <span class="string">"Should be instanceKlass"</span>);</span><br><span class="line">      instanceKlass* ik = (instanceKlass*) k_entry-&gt;klass_part();</span><br><span class="line">      <span class="comment">// 确保对象所属类型已经经过初始化阶段</span></span><br><span class="line">      <span class="keyword">if</span> ( ik-&gt;is_initialized() &amp;&amp; ik-&gt;can_be_fastpath_allocated() ) &#123;</span><br><span class="line">        <span class="comment">// 取对象长度</span></span><br><span class="line">        <span class="keyword">size_t</span> obj_size = ik-&gt;size_helper();</span><br><span class="line">        oop result = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 记录是否需要将对象所有字段置零值</span></span><br><span class="line">        <span class="keyword">bool</span> need_zero = !ZeroTLAB;</span><br><span class="line">        <span class="comment">// 是否在TLAB中分配对象</span></span><br><span class="line">        <span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">          result = (oop) THREAD-&gt;tlab().allocate(obj_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          need_zero = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 直接在eden中分配对象</span></span><br><span class="line">    retry:</span><br><span class="line">          HeapWord* compare_to = *Universe::heap()-&gt;top_addr();</span><br><span class="line">          HeapWord* new_top = compare_to + obj_size;</span><br><span class="line">          <span class="comment">// cmpxchg是x86中的CAS指令，这里是一个C++方法，通过CAS方式分配空间，并发失败的话，转到retry中重试直至成功分配为止</span></span><br><span class="line">          <span class="keyword">if</span> (new_top &lt;= *Universe::heap()-&gt;end_addr()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Atomic::cmpxchg_ptr(new_top, Universe::heap()-&gt;top_addr(), compare_to) != compare_to) &#123;</span><br><span class="line">              <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            result = (oop) compare_to;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果需要，为对象初始化零值</span></span><br><span class="line">          <span class="keyword">if</span> (need_zero ) &#123;</span><br><span class="line">            HeapWord* to_zero = (HeapWord*) result + <span class="keyword">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">            obj_size -= <span class="keyword">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">            <span class="keyword">if</span> (obj_size &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">              <span class="built_in">memset</span>(to_zero, <span class="number">0</span>, obj_size * HeapWordSize);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 根据是否启用偏向锁，设置对象头信息</span></span><br><span class="line">          <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">            result-&gt;set_mark(ik-&gt;prototype_header());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;set_mark(markOopDesc::prototype());</span><br><span class="line">          &#125;</span><br><span class="line">          result-&gt;set_klass_gap(<span class="number">0</span>);</span><br><span class="line">          result-&gt;set_klass(k_entry);</span><br><span class="line">          <span class="comment">// 将对象引用入栈，继续执行下一条指令</span></span><br><span class="line">          SET_STACK_OBJECT(result, <span class="number">0</span>);</span><br><span class="line">          UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></init></init></p><h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p>Java数据存储位置：</p><ul><li>寄存器：位于处理器内部，速度最快，数量有限，按需求分配，无法在程序中直接控制</li><li>堆栈：位于通用RAM(随机访问存储器)中，由堆栈指针控制分配，往上释放往下分配，故需要了解堆栈中数据的生命周期。存储数据有对象引用等</li><li>堆：通用的内存池(位于RAM区)，用于存放所有的Java对象，不需要了解生命周期，执行<code>new</code>时自动在堆中分配存储</li><li>常量存储：存放在代码内部</li><li>非RAM存储：把对象转化成可以存放在其他媒介上的事物，如流对象(对象转换成字节流发送至其他机器)和持久化对象(存放至磁盘)</li></ul><h3 id="特例：基本类型"><a href="#特例：基本类型" class="headerlink" title="特例：基本类型"></a>特例：基本类型</h3><p>当<code>new</code>创建一个特别小且简单的变量对象(如基本数据类型int、char、long等等)时存储至堆中，往往不是很有效，因此不用<code>new</code>来创建变量，而是创建一个并非是引用的“自动”变量，这个变量直接存储“值”，并置于堆栈中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'x'</span>;</span><br><span class="line">Character ch = <span class="keyword">new</span> Character(c);</span><br></pre></td></tr></table></figure></p><p>其中变量<code>c</code>为基本数据类型，存储在堆栈中，而通过<code>Character(c)</code>的自动装箱功能自动地将基本类型转换成包装器类型，存储在堆中。<br>高精度数字：<code>BigInteger</code>和<code>BigDecimal</code></p><h3 id="特例：数组"><a href="#特例：数组" class="headerlink" title="特例：数组"></a>特例：数组</h3><ul><li>数组的安全性：Java确保数组会被初始化，而且不能在它的范围之外被访问。这种范围检查，是以每个数组上少量的内存开销及运行时的下标检查为代价的</li><li>创建一个数组对象时，实际上就是创建一个引用数组，并且每个引用都会自动被初始化为一个特定值，该值拥有自己的关键字null。在使用任何引用前，必须为其指定一个对象。</li></ul><h2 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域由花括号的位置决定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">  <span class="comment">// only x is available</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// both x and q are available</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// q is out of scope</span></span><br><span class="line">  <span class="comment">// only x is available</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而作用域里定义的变量只可用于作用域结束之前</p><h3 id="对象的作用域"><a href="#对象的作用域" class="headerlink" title="对象的作用域"></a>对象的作用域</h3><p>Java对象与基本类型的生命周期不一样，当<code>new</code>创建一个Java对象时，它可以存活于作用域之外。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  String s = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>引用<code>s</code>在作用域终点就消失了，但是<code>s</code>指向的<code>String</code>对象仍继续占据内存空间。这就涉及到如何在作用域外传递和复制对象引用。</p><h3 id="对象的销毁-1"><a href="#对象的销毁-1" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><p>Java存在一个垃圾回收器，用以监视用<code>new</code>创建的所有对象，并辨别那些不会再被引用的对象，随后释放这些对象的内存空间，以便供其他新的对象使用，消除了内存泄漏问题。<br>GC垃圾收集机制具体可见：<a href="http://jackeyzzhold.xyz/2018/03/20/java-GC/" target="_blank" rel="noopener">博客入口</a></p><h2 id="数据类型：类"><a href="#数据类型：类" class="headerlink" title="数据类型：类"></a>数据类型：类</h2><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>字段有时被称为数据成员</p><ul><li>任何类型的对象，通过引用与其进行通信，必须初始化该引用，以便关联实际对象</li><li>基本类型的一种</li></ul><p>每个对象都有用来存储其字段的空间，普通字段不能在对象间共享。可以通过“引用名称.变量名称”进行字段赋值。<br>若类的某个成员是基本数据类型，则其存在一个默认值，但这并不适用于局部变量(及并非是某个类的字段),如某个方法中定义了<code>int x;</code>，那么<code>x</code>的值可能为任意值。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>java的方法决定了一个对象能够接受什么样的消息，其基本组成部分为：名称、参数、返回值和方法体</p><h3 id="名字可见性"><a href="#名字可见性" class="headerlink" title="名字可见性"></a>名字可见性</h3><p>反转域名确定唯一性</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>通过static关键字满足以下两种需求：</p><ul><li>为某特定域分配单一存储空间，不考虑对象</li><li>希望某个方法不于包含它的类的任何对象关联在一起，即没有创建对象也可以调用这个方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class StaticTest&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line">StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">StaticTest st2 = <span class="keyword">new</span> StaticTest();</span><br></pre></td></tr></table></figure><p>此时<code>st1.i</code>与<code>st2.i</code>指向同一存储空间。<br>引用static变量既可以使用对象引用去定位，也可以使用类名去定位，如<code>StaticTest.i</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/2018/11/02/java编程思想-对象/Java-对象.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;对象、对象引用、句柄&quot;&gt;&lt;a href=&quot;#对象、对象引用、句柄&quot; class=&quot;headerlink&quot; title=&quot;对象、对象引用、句柄
      
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>deeplearning_word2vec</title>
    <link href="http://yoursite.com/2018/06/26/deeplearning-word2vec/"/>
    <id>http://yoursite.com/2018/06/26/deeplearning-word2vec/</id>
    <published>2018-06-26T09:42:03.000Z</published>
    <updated>2018-09-22T07:36:52.958Z</updated>
    
    <content type="html"><![CDATA[<p><strong>word2vec</strong> 是google在2013年推出的一个NLP工具，它的特点是将所有的词向量化，这样词与词之间就可以定量的去度量他们之间的关系，挖掘词之间的联系。虽然源码是开源的，但是谷歌的代码库国内无法访问，因此本文的讲解word2vec原理以Github上的<a href="https://github.com/tmikolov/word2vec" target="_blank" rel="noopener">word2vec</a>代码为准。</p><h2 id="词向量基础"><a href="#词向量基础" class="headerlink" title="词向量基础"></a>词向量基础</h2><h3 id="one-hot-representation"><a href="#one-hot-representation" class="headerlink" title="one hot representation"></a>one hot representation</h3><p>用词向量来表示词并不是word2vec的首创，在很久之前就出现了。最早的词向量是很冗长的，它使用是词向量维度大小为整个词汇表的大小，对于每个具体的词汇表中的词，将对应的位置置为1。比如我们有下面的5个词组成的词汇表，词”Queen”的序号为2， 那么它的词向量就是(0,1,0,0,0)。同样的道理，词”Woman”的词向量就是(0,0,0,1,0)。这种词向量的编码方式我们一般叫做1-of-N representation或者one hot representation.<br><img src="/2018/06/26/deeplearning-word2vec/pic1.png" alt=""><br>One hot representation用来表示词向量非常简单，但是却有很多问题。最大的问题是我们的词汇表一般都非常大，比如达到百万级别，这样每个词都用百万维的向量来表示简直是内存的灾难。这样的向量其实除了一个位置是1，其余的位置全部都是0，表达的效率不高，能不能把词向量的维度变小呢？</p><h3 id="Distributed-representation"><a href="#Distributed-representation" class="headerlink" title="Distributed representation"></a>Distributed representation</h3><p>Distributed representation可以解决One hot representation的问题，它的思路是通过训练，将每个词都映射到一个较短的词向量上来。所有的这些词向量就构成了向量空间，进而可以用普通的统计学的方法来研究词与词之间的关系。这个较短的词向量维度是多大呢？这个一般需要我们在训练时自己来指定。</p><p>比如下图我们将词汇表里的词用”Royalty”,”Masculinity”, “Femininity”和”Age”4个维度来表示，King这个词对应的词向量可能是(0.99,0.99,0.05,0.7)。当然在实际情况中，我们并不能对词向量的每个维度做一个很好的解释。<br><img src="/2018/06/26/deeplearning-word2vec/pic2.png" alt=""><br>有了用Distributed representation表示的较短的词向量，我们就可以较容易的分析词之间的关系了，比如我们将词的维度降维到2维，有一个有趣的研究表明，用下图的词向量表示我们的词时，我们可以发现：<br>$$\vec {King} - \vec {Man} + \vec {Woman} = \vec {Queen}$$<br><img src="/2018/06/26/deeplearning-word2vec/pic3.png" alt=""><br>可见我们只要得到了词汇表里所有词对应的词向量，那么我们就可以做很多有趣的事情了。不过，怎么训练得到合适的词向量呢？一个很常见的方法是使用神经网络语言模型。</p><p><strong>word2vec</strong> 做的事情很简单，大致来说，就是构建了一个多层神经网络，然后在给定文本中获取对应的输入和输出，在训练过程中不断修正神经网络中的参数，最后得到词向量。</p><h2 id="神经网络语言模型：CBOW、Skip-Gram"><a href="#神经网络语言模型：CBOW、Skip-Gram" class="headerlink" title="神经网络语言模型：CBOW、Skip-Gram"></a>神经网络语言模型：CBOW、Skip-Gram</h2><p>word2vec采用的是 <strong>n元语法模型(n-gram model)</strong>，即假设一个词只与周围n个词有关，而与文本中的其他词无关。</p><p>CBOW模型能够根据输入周围n-1个词来预测出这个词本身，而skip-gram模型能够根据词本身来预测周围有哪些词。也就是说，CBOW模型的输入是某个词A周围的n个单词的词向量之和，输出是词A本身的词向量；而skip-gram模型的输入是词A本身，输出是词A周围的n个单词的词向量(对的，要循环n遍)</p><h3 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h3><p>CBOW模型的训练输入是某一个特征词的上下文相关的词对应的词向量，而输出就是这特定的一个词的词向量。比如下面这段话，我们的上下文大小取值为4，特定的这个词是”Learning”，也就是我们需要的输出词向量,上下文对应的词有8个，前后各4个，这8个词是我们模型的输入。由于CBOW使用的是词袋模型，因此这8个词都是平等的，也就是不考虑他们和我们关注的词之间的距离大小，只要在我们上下文之内即可<br><img src="/2018/06/26/deeplearning-word2vec/pic4.png" alt=""><br>　这样我们这个CBOW的例子里，我们的输入是8个词向量，输出是所有词的softmax概率（训练的目标是期望训练样本特定词对应的softmax概率最大），对应的CBOW神经网络模型输入层有8个神经元，输出层有词汇表大小个神经元。隐藏层的神经元个数我们可以自己指定。通过DNN的反向传播算法，我们可以求出DNN模型的参数，同时得到所有的词对应的词向量。这样当我们有新的需求，要求出某8个词对应的最可能的输出中心词时，我们可以通过一次DNN前向传播算法并通过softmax激活函数找到概率最大的词对应的神经元即可。</p><h3 id="Skip-gram"><a href="#Skip-gram" class="headerlink" title="Skip-gram"></a>Skip-gram</h3><p>Skip-Gram模型和CBOW的思路是反着来的，即输入是特定的一个词的词向量，而输出是特定词对应的上下文词向量。还是上面的例子，我们的上下文大小取值为4， 特定的这个词”Learning”是我们的输入，而这8个上下文词是我们的输出。</p><p>这样我们这个Skip-Gram的例子里，我们的输入是特定词， 输出是softmax概率排前8的8个词，对应的Skip-Gram神经网络模型输入层有1个神经元，输出层有词汇表大小个神经元。隐藏层的神经元个数我们可以自己指定。通过DNN的反向传播算法，我们可以求出DNN模型的参数，同时得到所有的词对应的词向量。这样当我们有新的需求，要求出某1个词对应的最可能的8个上下文词时，我们可以通过一次DNN前向传播算法得到概率大小排前8的softmax概率对应的神经元所对应的词即可。</p><h2 id="word2vec的使用"><a href="#word2vec的使用" class="headerlink" title="word2vec的使用"></a>word2vec的使用</h2><p>word2vec也使用了CBOW与Skip-Gram来训练模型与得到词向量，但是并没有使用传统的DNN模型。最先优化使用的数据结构是用霍夫曼树来代替隐藏层和输出层的神经元，霍夫曼树的叶子节点起到输出层神经元的作用，叶子节点的个数即为词汇表的小大。 而内部节点则起到隐藏层神经元的作用。</p><p>word2vec有两种改进方法，一种是基于Hierarchical Softmax的，另一种是基于Negative Sampling的。</p><h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><p>霍夫曼树的建立过程如下：<br>输入：权值为(w1,w2,…wn)的n个节点<br>输出：对应的霍夫曼树<br>1）将(w1,w2,…wn)看做是有n棵树的森林，每个树仅有一个节点。<br>2）在森林中选择根节点权值最小的两棵树进行合并，得到一个新的树，这两颗树分布作为新树的左右子树。新树的根节点权重为左右子树的根节点权重之和。<br>3） 将之前的根节点权值最小的两棵树从森林删除，并把新树加入森林。<br>4）重复步骤2）和3）直到森林里只有一棵树为止。<br>下面我们用一个具体的例子来说明霍夫曼树建立的过程，我们有(a,b,c,d,e,f)共6个节点，节点的权值分布是(16,4,8,6,20,3)。<br>首先是最小的b和f合并，得到的新树根节点权重是7.此时森林里5棵树，根节点权重分别是16,8,6,20,7。此时根节点权重最小的6,7合并，得到新子树，依次类推，最终得到下面的霍夫曼树。<br><img src="/2018/06/26/deeplearning-word2vec/pic6.png" alt=""><br>那么霍夫曼树有什么好处呢？一般得到霍夫曼树后我们会对叶子节点进行霍夫曼编码，由于权重高的叶子节点越靠近根节点，而权重低的叶子节点会远离根节点，这样我们的高权重节点编码值较短，而低权重值编码值较长。这保证的树的带权路径最短，也符合我们的信息论，即我们希望越常用的词拥有更短的编码。如何编码呢？一般对于一个霍夫曼树的节点（根节点除外），可以约定左子树编码为0，右子树编码为1.如上图，则可以得到c的编码是00。</p><p>在word2vec中，约定编码方式和上面的例子相反，即约定左子树编码为1，右子树编码为0，同时约定左子树的权重不小于右子树的权重。</p><h3 id="基于Hierarchical-Softmax的word2vec模型"><a href="#基于Hierarchical-Softmax的word2vec模型" class="headerlink" title="基于Hierarchical Softmax的word2vec模型"></a>基于Hierarchical Softmax的word2vec模型</h3><h4 id="传统神经网络的局限性"><a href="#传统神经网络的局限性" class="headerlink" title="传统神经网络的局限性"></a>传统神经网络的局限性</h4><p>理论上说，无论是CBOW模型还是skip-gram模型，其具体的实现都可以用神经网络来完成。问题在于，这样做的计算量太大了。我们可以简略估计一下。首先定义一些变量的含义:</p><ul><li>n:一个词的上下文包含的词数，与n-gram中n的含义相同</li><li>m:词向量的长度，通常在10~100</li><li>h:隐藏层的规模，一般在100量级</li><li>N:词典的规模，通常在1W~10W</li><li>T:训练文本中单词个数</li></ul><p>以CBOW为例，输入层为n-1个单词的词向量，长度为m(n-1)，隐藏层的规模为h,输出层的规模为N。那么前向的时间复杂度就是o(m(n-1)h+hN) = o(hN) 这还是处理一个词所需要的复杂度。如果要处理所有文本，则需要o(hNT)的时间复杂度。这个是不可接受的。同时我们也注意到，o(hNT)之中，h和T的值相对固定，想要对其进行优化，主要还是应该从N入手。而输出层的规模之所以为N，是因为这个神经网络要完成的是N选1的任务。<br><img src="/2018/06/26/deeplearning-word2vec/pic7.png" alt=""><br>如上图所示，传统的神经网络词向量语言模型，里面一般有三层，输入层（词向量），隐藏层和输出层（softmax层）。里面最大的问题在于从隐藏层到输出的softmax层的计算量很大，因为要计算所有词的softmax概率，再去找概率最大的值。这个模型如下图所示。其中V是词汇表的大小，</p><p>那么可不可以减小N的值呢？答案是可以的。<strong>解决的思路就是将一次分类分解为多次分类，这也是Hierarchical Softmax的核心思想。</strong> 举个栗子，有[1,2,3,4,5,6,7,8]这8个分类，想要判断词A属于哪个分类，我们可以一步步来，首先判断A是属于[1,2,3,4]还是属于[5,6,7,8]。如果判断出属于[1,2,3,4]，那么就进一步分析是属于[1,2]还是[3,4]，以此类推，如图中所示的那样。这样一来，就把单个词的时间复杂度从o(h<em>N)降为o(h</em>logN)，更重要的减少了内存的开销。<br><img src="/2018/06/26/deeplearning-word2vec/pic5.png" alt=""><br>从上面可以看到从输入到输出，中间是一个树形结构，其中的每一个节点都完成一个二分类(logistic分类)问题。那么就存在一个如何构建树的问题。这里采用huffman树，因为这样构建的话，出现频率越高的词所经过的路径越短，从而使得所有单词的平均路径长度达到最短。</p><h4 id="模型概述"><a href="#模型概述" class="headerlink" title="模型概述"></a>模型概述</h4><p>word2vec对传统模型做了改进。</p><ul><li>首先，对于从输入层到隐藏层的映射，没有采取神经网络的线性变换加激活函数的方法，而是采用简单的对所有输入词向量求和并取平均的方法。比如输入的是三个4维词向量：(1,2,3,4),(9,6,11,8),(5,10,7,12),那么我们word2vec映射后的词向量就是(5,6,7,8)。由于这里是从多个词向量变成了一个词向量。</li><li>第二个改进就是从隐藏层到输出的softmax层这里的计算量改进。为了避免要计算所有词的softmax概率，word2vec采样了霍夫曼树来代替从隐藏层到输出softmax层的映射。我们在上一节已经介绍了霍夫曼树的原理。如何映射呢？这里就是理解word2vec的关键所在了。</li></ul><p>由于我们把之前所有都要计算的从输出softmax层的概率计算变成了一颗二叉霍夫曼树，那么我们的softmax概率计算只需要沿着树形结构进行就可以了。如下图所示，我们可以沿着霍夫曼树从根节点一直走到我们的叶子节点的词w2。<br><img src="/2018/06/26/deeplearning-word2vec/pic8.png" alt=""></p><p>和之前的神经网络语言模型相比，我们的霍夫曼树的所有内部节点就类似之前神经网络隐藏层的神经元,其中，根节点的词向量对应我们的投影后的词向量，而所有叶子节点就类似于之前神经网络softmax输出层的神经元，叶子节点的个数就是词汇表的大小。在霍夫曼树中，隐藏层到输出层的softmax映射不是一下子完成的，而是沿着霍夫曼树一步步完成的，因此这种softmax取名为”Hierarchical Softmax”。</p><p>如何“沿着霍夫曼树一步步完成”呢？在word2vec中，我们采用了二元逻辑回归的方法，即规定沿着左子树走，那么就是负类(霍夫曼树编码1)，沿着右子树走，那么就是正类(霍夫曼树编码0)。判别正类和负类的方法是使用sigmoid函数，即：<br>$$P(+) = \sigma(x_w^T\theta) = \frac{1}{1+e^{-x_w^T\theta}}$$<br>其中$x_w$是当前内部节点的词向量，而θ则是我们需要从训练样本求出的逻辑回归的模型参数。</p><p>使用霍夫曼树有什么好处呢？首先，由于是二叉树，之前计算量为V,现在变成了$log_2V$。第二，由于使用霍夫曼树是高频的词靠近树根，这样高频词需要更少的时间会被找到，这符合我们的贪心优化思想。</p><p>容易理解，被划分为左子树而成为负类的概率为P(−)=1−P(+)。在某一个内部节点，要判断是沿左子树还是右子树走的标准就是看P(−),P(+)谁的概率值大。而控制P(−),P(+)谁的概率值大的因素一个是当前节点的词向量，另一个是当前节点的模型参数θ。</p><p>对于上图中的$w_2$，如果它是一个训练样本的输出，那么我们期望对于里面的隐藏节点$n(w_2,1)$的P(−)概率大，$n(w_2,2)$的P(−)概率大，$n(w_2,3)$的P(+)概率大。</p><p>　　　　回到基于Hierarchical Softmax的word2vec本身，我们的目标就是找到合适的所有节点的词向量和所有内部节点θ, 使训练样本达到最大似然。那么如何达到最大似然呢？</p><h4 id="模型梯度计算"><a href="#模型梯度计算" class="headerlink" title="模型梯度计算"></a>模型梯度计算</h4><p>我们使用最大似然法来寻找所有节点的词向量和所有内部节点θ。先拿上面的$w_2$例子来看，我们期望最大化下面的似然函数：<br>$$\prod_{i=1}^3P(n(w_i),i) = (1- \frac{1}{1+e^{-x_w^T\theta_1}})(1- \frac{1}{1+e^{-x_w^T\theta_2}})\frac{1}{1+e^{-x_w^T\theta_3}}$$<br>对于所有的训练样本，我们期望最大化所有样本的似然函数乘积。</p><p>为了便于我们后面一般化的描述，我们定义输入的词为w,其从输入层词向量求和平均后的霍夫曼树根节点词向量为$x_w$, 从根节点到w所在的叶子节点，包含的节点总数为$l_w$, w在霍夫曼树中从根节点开始，经过的第i个节点表示为$p^w_i$,对应的霍夫曼编码为$d^w_i∈{0,1}$,其中$i=2,3,…l_w$。而该节点对应的模型参数表示为$θ^w_i$, 其中$i=1,2,…l_{w-1}$，没有$i=l_w$是因为模型参数仅仅针对于霍夫曼树的内部节点。</p><p>定义w经过的霍夫曼树某一个节点j的逻辑回归概率为$P(d^w_j|x_w,θ^w_{j-1})$，其表达式为：<br>$$P(d_j^w|x_w, \theta_{j-1}^w)= \begin{cases}  \sigma(x_w^T\theta_{j-1}^w)&amp; {d_j^w=0}\ 1-  \sigma(x_w^T\theta_{j-1}^w) &amp; {d_j^w = 1} \end{cases}$$</p><p>那么对于某一个目标输出词w,其最大似然为：<br>$$\prod_{j=2}^{l_w}P(d_j^w|x_w, \theta_{j-1}^w) = \prod_{j=2}^{l_w} [\sigma(x_w^T\theta_{j-1}^w)] ^{1-d_j^w}[1-\sigma(x_w^T\theta_{j-1}^w)]^{d_j^w}$$</p><p>在word2vec中，由于使用的是随机梯度上升法，所以并没有把所有样本的似然乘起来得到真正的训练集最大似然，仅仅每次只用一个样本更新梯度，这样做的目的是减少梯度计算量。这样我们可以得到w的对数似然函数L如下：<br>$$L= log \prod_{j=2}^{l_w}P(d_j^w|x_w, \theta_{j-1}^w) = \sum\limits_{j=2}^{l_w} ((1-d_j^w) log [\sigma(x_w^T\theta_{j-1}^w)]  + d_j^w log[1-\sigma(x_w^T\theta_{j-1}^w)])$$</p><p>要得到模型中w词向量和内部节点的模型参数θ, 我们使用梯度上升法即可。首先我们求模型参数$θ^w_{j-1}$的梯度：<br>$$\frac{\partial L}{\partial \theta_{j-1}^w}=(1-d_j^w)\frac{(\sigma(x_w^T\theta_{j-1}^w)(1-\sigma(x_w^T\theta_{j-1}^w)}{\sigma(x_w^T\theta_{j-1}^w)}x_w - d_j^w \frac{(\sigma(x_w^T\theta_{j-1}^w)(1-\sigma(x_w^T\theta_{j-1}^w)}{1- \sigma(x_w^T\theta_{j-1}^w)}x_w=(1-d_j^w)(1-\sigma(x_w^T\theta_{j-1}^w))x_w -  d_j^w\sigma(x_w^T\theta_{j-1}^w)x_w=(1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))x_w$$</p><p>如果大家看过之前写的逻辑回归原理小结，会发现这里的梯度推导过程基本类似。<br>同样的方法，可以求出xw的梯度表达式如下：<br>$$\frac{\partial L}{\partial x_w} = (1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))\theta_{j-1}^w$$</p><p>有了梯度表达式，我们就可以用梯度上升法进行迭代来一步步的求解我们需要的所有的$θ^w_{j-1}$和$x_w$。</p><h4 id="基于Hierarchical-Softmax的CBOW模型"><a href="#基于Hierarchical-Softmax的CBOW模型" class="headerlink" title="基于Hierarchical Softmax的CBOW模型"></a>基于Hierarchical Softmax的CBOW模型</h4><p>由于word2vec有两种模型：CBOW和Skip-Gram,我们先看看基于CBOW模型时， Hierarchical Softmax如何使用。</p><p>首先我们要定义词向量的维度大小M，以及CBOW的上下文大小2c,这样我们对于训练样本中的每一个词，其前面的c个词和后面的c个词作为了CBOW模型的输入,该词本身作为样本的输出，期望softmax概率最大。</p><p>在做CBOW模型前，我们需要先将词汇表建立成一颗霍夫曼树。</p><p>对于从输入层到隐藏层（投影层），这一步比较简单，就是对w周围的2c个词向量求和取平均即可，即：<br>$$x_w = \frac{1}{2c}\sum\limits_{i=1}^{2c}x_i$$<br>第二步，通过梯度上升法来更新我们的$θ^w_{j-1}$和$x_w$，注意这里的$x_w$是由2c个词向量相加而成，我们做梯度更新完毕后会用梯度项直接更新原始的各个$x_i(i=1,2,,,,2c)$，即：<br>$$\theta_{j-1}^w = \theta_{j-1}^w + \eta  (1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))x_w$$<br>$$x_w= x_w +\eta  (1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))\theta_{j-1}^w \;(i =1,2..,2c)$$<br>其中η为梯度上升法的步长。</p><p>这里总结下基于Hierarchical Softmax的CBOW模型算法流程，梯度迭代使用了随机梯度上升法：</p><p>输入：基于CBOW的语料训练样本，词向量的维度大小M，CBOW的上下文大小2c,步长η<br>输出：霍夫曼树的内部节点模型参数θ，所有的词向量w</p><ul><li>基于语料训练样本建立霍夫曼树。</li><li>随机初始化所有的模型参数θ，所有的词向量w</li><li>进行梯度上升迭代过程，对于训练集中的每一个样本(context(w),w)做如下处理：<ul><li>e=0， 计算$x_w= \frac{1}{2c}\sum\limits_{i=1}^{2c}x_i$</li><li>for j = 2 to $l_w$, 计算：<br>$f = \sigma(x_w^T\theta_{j-1}^w)$<br>$g = (1-d_j^w-f)\eta$<br>$e = e + g\theta_{j-1}^w$<br>$\theta_{j-1}^w= \theta_{j-1}^w + gx_w$</li><li>对于$context(w)$中的每一个词向量$x_i$(共2c个)进行更新：<br>$x_i = x_i + e$</li><li>如果梯度收敛，则结束梯度迭代，否则回到步骤3继续迭代。</li></ul></li></ul><h4 id="基于Hierarchical-Softmax的Skip-Gram模型"><a href="#基于Hierarchical-Softmax的Skip-Gram模型" class="headerlink" title="基于Hierarchical Softmax的Skip-Gram模型"></a>基于Hierarchical Softmax的Skip-Gram模型</h4><p>现在我们先看看基于Skip-Gram模型时， Hierarchical Softmax如何使用。此时输入的只有一个词w,输出的为2c个词向量context(w)。</p><p>我们对于训练样本中的每一个词，该词本身作为样本的输入， 其前面的c个词和后面的c个词作为了Skip-Gram模型的输出,，期望这些词的softmax概率比其他的词大。</p><p>Skip-Gram模型和CBOW模型其实是反过来的，在上一篇已经讲过。</p><p>在做CBOW模型前，我们需要先将词汇表建立成一颗霍夫曼树。</p><p>对于从输入层到隐藏层（投影层），这一步比CBOW简单，由于只有一个词，所以，即xw就是词w对应的词向量。</p><p>第二步，通过梯度上升法来更新我们的$θ^w_{j-1}$和$x_w$，注意这里的$x_w$周围有2c个词向量，此时如果我们期望$P(x_i|x_w),i=1,2…2c$最大。此时我们注意到由于上下文是相互的，在期望$P(x_i|x_w),i=1,2…2c$最大化的同时，反过来我们也期望$P(x_w|x_i),i=1,2…2c$最大。那么是使用$P(x_i|x_w)$好还是$P(x_w|x_i)$好呢，word2vec使用了后者，这样做的好处就是在一次迭代时，我们不是更新$x_w$一个词，而是$x_i,i=1,2…2c$共2c个词。这样整体的迭代会更加的均衡。因为这个原因，Skip-Gram模型并没有和CBOW模型一样对输入进行迭代更新，而是对2c个输出进行迭代更新。</p><p>这里总结下基于Hierarchical Softmax的Skip-Gram模型算法流程，梯度迭代使用了随机梯度上升法：</p><p>输入：基于Skip-Gram的语料训练样本，词向量的维度大小M，Skip-Gram的上下文大小2c,步长η<br>输出：霍夫曼树的内部节点模型参数θ，所有的词向量w</p><ul><li>基于语料训练样本建立霍夫曼树。</li><li>随机初始化所有的模型参数θ，所有的词向量w,</li><li>进行梯度上升迭代过程，对于训练集中的每一个样本(w,context(w))做如下处理：<ul><li>for i =1 to 2c:<ul><li>e=0</li><li>for j = 2 to $l_w$, 计算：<br>$f = \sigma(x_i^T\theta_{j-1}^w)$<br>$g = (1-d_j^w-f)\eta$<br>$e = e + g\theta_{j-1}^w$<br>$\theta_{j-1}^w= \theta_{j-1}^w+ gx_i$</li><li>$x_i = x_i + e$</li></ul></li><li>如果梯度收敛，则结束梯度迭代，算法结束，否则回到步骤a继续迭代。</li></ul></li></ul><h3 id="word2vec大致流程"><a href="#word2vec大致流程" class="headerlink" title="word2vec大致流程"></a>word2vec大致流程</h3><ul><li><strong>分词/词干提取和词形还原。</strong> 中文和英文的nlp各有各的难点，中文的难点在于需要进行分词，将一个个句子分解成一个单词数组。而英文虽然不需要分词，但是要处理各种各样的时态，所以要进行词干提取和词形还原。</li><li><strong>构造词典，统计词频。</strong> 这一步需要遍历一遍所有文本，找出所有出现过的词，并统计各词的出现频率。</li><li><strong>构造树形结构。</strong> 依照出现概率构造Huffman树。如果是完全二叉树，则简单很多，后面会仔细解释。需要注意的是，所有分类都应该处于叶节点。<br><img src="/2018/06/26/deeplearning-word2vec/pic9.png" alt=""></li><li><strong>生成节点所在的二进制码。</strong> 拿上图举例，22对应的二进制码为00,而17对应的是100。也就是说，这个二进制码反映了节点在树中的位置，就像门牌号一样，能按照编码从根节点一步步找到对应的叶节点。</li><li><strong>初始化各非叶节点的中间向量和叶节点中的词向量。</strong> 树中的各个节点，都存储着一个长为m的向量，但叶节点和非叶结点中的向量的含义不同。叶节点中存储的是各词的词向量，是作为神经网络的输入的。而非叶结点中存储的是中间向量，对应于神经网络中隐含层的参数，与输入一起决定分类结果。</li><li><strong>训练中间向量和词向量。</strong> 对于CBOW模型，首先将词A附近的n-1个词的词向量相加作为系统的输入，并且按照词A在步骤4中生成的二进制码，一步步的进行分类并按照分类结果训练中间向量和词向量。举个栗子，对于绿17节点，我们已经知道其二进制码是100。那么在第一个中间节点应该将对应的输入分类到右边。如果分类到左边，则表明分类错误，需要对向量进行修正。第二个，第三个节点也是这样，以此类推，直到达到叶节点。因此对于单个单词来说，最多只会改动其路径上的节点的中间向量，而不会改动其他节点。<br><img src="/2018/06/26/deeplearning-word2vec/pic10.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;word2vec&lt;/strong&gt; 是google在2013年推出的一个NLP工具，它的特点是将所有的词向量化，这样词与词之间就可以定量的去度量他们之间的关系，挖掘词之间的联系。虽然源码是开源的，但是谷歌的代码库国内无法访问，因此本文的讲解word2vec原
      
    
    </summary>
    
      <category term="深度学习整理总结" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>收集整理</title>
    <link href="http://yoursite.com/2018/06/12/%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/06/12/收集整理/</id>
    <published>2018-06-12T06:03:29.000Z</published>
    <updated>2018-09-22T07:36:53.417Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一步：给TF新手的教程指南"><a href="#第一步：给TF新手的教程指南" class="headerlink" title="第一步：给TF新手的教程指南"></a>第一步：给TF新手的教程指南</h2><h3 id="1：tf初学者需要明白的入门准备"><a href="#1：tf初学者需要明白的入门准备" class="headerlink" title="1：tf初学者需要明白的入门准备"></a>1：tf初学者需要明白的入门准备</h3><p>机器学习入门笔记：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/ml_introduction.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/ml_introduction.ipynb</a></p></blockquote><p>MNIST 数据集入门笔记</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/mnist_dataset_intro.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/mnist_dataset_intro.ipynb</a></p></blockquote><h3 id="2：tf初学者需要了解的入门基础"><a href="#2：tf初学者需要了解的入门基础" class="headerlink" title="2：tf初学者需要了解的入门基础"></a>2：tf初学者需要了解的入门基础</h3><p>Hello World</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/1_Introduction/helloworld.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/1_Introduction/helloworld.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/1_Introduction/helloworld.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/1_Introduction/helloworld.py</a></p></blockquote><p>基本操作</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/1_Introduction/basic_operations.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/1_Introduction/basic_operations.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/1_Introduction/basic_operations.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/1_Introduction/basic_operations.py</a></p></blockquote><h3 id="3：tf初学者需要掌握的基本模型"><a href="#3：tf初学者需要掌握的基本模型" class="headerlink" title="3：tf初学者需要掌握的基本模型"></a>3：tf初学者需要掌握的基本模型</h3><p>最近邻：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/nearest_neighbor.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/nearest_neighbor.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/nearest_neighbor.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/nearest_neighbor.py</a></p></blockquote><p>线性回归：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/linear_regression.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/linear_regression.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/linear_regression.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/linear_regression.py</a></p></blockquote><p>Logistic 回归：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/logistic_regression.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/logistic_regression.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/logistic_regression.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/logistic_regression.py</a></p></blockquote><h3 id="4：tf初学者需要尝试的神经网络"><a href="#4：tf初学者需要尝试的神经网络" class="headerlink" title="4：tf初学者需要尝试的神经网络"></a>4：tf初学者需要尝试的神经网络</h3><p>多层感知器：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/multilayer_perceptron.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/multilayer_perceptron.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/multilayer_perceptron.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/multilayer_perceptron.py</a></p></blockquote><p>卷积神经网络：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/convolutional_network.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/convolutional_network.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/convolutional_network.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/convolutional_network.py</a></p></blockquote><p>循环神经网络（LSTM）：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/recurrent_network.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/recurrent_network.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/recurrent_network.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/recurrent_network.py</a></p></blockquote><p>双向循环神经网络（LSTM）：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/bidirectional_rnn.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/bidirectional_rnn.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/bidirectional_rnn.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/bidirectional_rnn.py</a></p></blockquote><p>动态循环神经网络（LSTM）</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/dynamic_rnn.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/dynamic_rnn.py</a></p></blockquote><p>自编码器</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/autoencoder.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/autoencoder.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/autoencoder.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/autoencoder.py</a></p></blockquote><h3 id="5：tf初学者需要精通的实用技术"><a href="#5：tf初学者需要精通的实用技术" class="headerlink" title="5：tf初学者需要精通的实用技术"></a>5：tf初学者需要精通的实用技术</h3><p>保存和恢复模型</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/4_Utils/save_restore_model.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/4_Utils/save_restore_model.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/save_restore_model.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/save_restore_model.py</a></p></blockquote><p>图和损失可视化</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/4_Utils/tensorboard_basic.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/4_Utils/tensorboard_basic.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/tensorboard_basic.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/tensorboard_basic.py</a></p></blockquote><p>Tensorboard——高级可视化</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/tensorboard_advanced.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/tensorboard_advanced.py</a></p></blockquote><h3 id="5：tf初学者需要的懂得的多GPU基本操作"><a href="#5：tf初学者需要的懂得的多GPU基本操作" class="headerlink" title="5：tf初学者需要的懂得的多GPU基本操作"></a>5：tf初学者需要的懂得的多GPU基本操作</h3><p>多 GPU 上的基本操作</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/5_MultiGPU/multigpu_basics.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/5_MultiGPU/multigpu_basics.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/5_MultiGPU/multigpu_basics.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/5_MultiGPU/multigpu_basics.py</a></p></blockquote><h3 id="6：案例需要的数据集"><a href="#6：案例需要的数据集" class="headerlink" title="6：案例需要的数据集"></a>6：案例需要的数据集</h3><p>有一些案例需要 MNIST 数据集进行训练和测试。运行这些案例时，该数据集会被自动下载下来（使用 input_data.py）。<br>MNIST数据集笔记：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/mnist_dataset_intro.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/mnist_dataset_intro.ipynb</a></p></blockquote><p>官方网站：<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a></p><h2 id="第二步：为TF新手准备的各个类型的案例、模型和数据集"><a href="#第二步：为TF新手准备的各个类型的案例、模型和数据集" class="headerlink" title="第二步：为TF新手准备的各个类型的案例、模型和数据集"></a>第二步：为TF新手准备的各个类型的案例、模型和数据集</h2><p>初步了解：TFLearnTensorFlow<br>接下来的示例来自TFLearn，这是一个为 TensorFlow 提供了简化的接口的库。里面有很多示例和预构建的运算和层。<br>使用教程：TFLearn 快速入门。通过一个具体的机器学习任务学习 TFLearn 基础。开发和训练一个深度神经网络分类器。<br>TFLearn地址：<a href="https://github.com/tflearn/tflearn" target="_blank" rel="noopener">https://github.com/tflearn/tflearn</a><br>示例：<a href="https://github.com/tflearn/tflearn/tree/master/examples" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/tree/master/examples</a><br>预构建的运算和层：<a href="http://tflearn.org/doc_index/#api" target="_blank" rel="noopener">http://tflearn.org/doc_index/#api</a><br>笔记：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/tutorials/intro/quickstart.md" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/tutorials/intro/quickstart.md</a></p></blockquote><p>基础模型以及数据集<br>线性回归，使用 TFLearn 实现线性回归</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/linear_regression.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/linear_regression.py</a></p></blockquote><p>逻辑运算符。使用 TFLearn 实现逻辑运算符</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/logical.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/logical.py</a></p></blockquote><p>权重保持。保存和还原一个模型</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/weights_persistence.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/weights_persistence.py</a></p></blockquote><p>微调。在一个新任务上微调一个预训练的模型</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/finetuning.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/finetuning.py</a></p></blockquote><p>使用 HDF5。使用 HDF5 处理大型数据集</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/use_hdf5.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/use_hdf5.py</a></p></blockquote><p>使用 DASK。使用 DASK 处理大型数据集</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/use_dask.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/use_dask.py</a></p></blockquote><p>计算机视觉模型及数据集<br>多层感知器。一种用于 MNIST 分类任务的多层感知实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/dnn.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/dnn.py</a></p></blockquote><p>卷积网络（MNIST）。用于分类 MNIST 数据集的一种卷积神经网络实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_mnist.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_mnist.py</a></p></blockquote><p>卷积网络（CIFAR-10）。用于分类 CIFAR-10 数据集的一种卷积神经网络实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_cifar10.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_cifar10.py</a></p></blockquote><p>网络中的网络。用于分类 CIFAR-10 数据集的 Network in Network 实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/network_in_network.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/network_in_network.py</a></p></blockquote><p>Alexnet。将 Alexnet 应用于 Oxford Flowers 17 分类任务</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/alexnet.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/alexnet.py</a></p></blockquote><p>VGGNet。将 VGGNet 应用于 Oxford Flowers 17 分类任务</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/vgg_network.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/vgg_network.py</a></p></blockquote><p>VGGNet Finetuning (Fast Training)。使用一个预训练的 VGG 网络并将其约束到你自己的数据上，以便实现快速训练</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/vgg_network_finetuning.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/vgg_network_finetuning.py</a></p></blockquote><p>RNN Pixels。使用 RNN（在像素的序列上）分类图像</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/rnn_pixels.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/rnn_pixels.py</a></p></blockquote><p>Highway Network。用于分类 MNIST 数据集的 Highway Network 实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/highway_dnn.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/highway_dnn.py</a></p></blockquote><p>Highway Convolutional Network。用于分类 MNIST 数据集的 Highway Convolutional Network 实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_highway_mnist.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_highway_mnist.py</a></p></blockquote><p>Residual Network (MNIST) 。应用于 MNIST 分类任务的一种瓶颈残差网络（bottleneck residual network）</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/residual_network_mnist.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/residual_network_mnist.py</a></p></blockquote><p>Residual Network (CIFAR-10)。应用于 CIFAR-10 分类任务的一种残差网络</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/residual_network_cifar10.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/residual_network_cifar10.py</a></p></blockquote><p>Google Inception（v3）。应用于 Oxford Flowers 17 分类任务的谷歌 Inception v3 网络</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/googlenet.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/googlenet.py</a></p></blockquote><p>自编码器。用于 MNIST 手写数字的自编码器</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/autoencoder.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/autoencoder.py</a></p></blockquote><p>自然语言处理模型及数据集<br>循环神经网络（LSTM），应用 LSTM 到 IMDB 情感数据集分类任</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm.py</a></p></blockquote><p>双向 RNN（LSTM），将一个双向 LSTM 应用到 IMDB 情感数据集分类任务：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/bidirectional_lstm.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/bidirectional_lstm.py</a></p></blockquote><p>动态 RNN（LSTM），利用动态 LSTM 从 IMDB 数据集分类可变长度文本：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/dynamic_lstm.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/dynamic_lstm.py</a></p></blockquote><p>城市名称生成，使用 LSTM 网络生成新的美国城市名：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm_generator_cityname.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm_generator_cityname.py</a></p></blockquote><p>莎士比亚手稿生成，使用 LSTM 网络生成新的莎士比亚手稿：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm_generator_shakespeare.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm_generator_shakespeare.py</a></p></blockquote><p>Seq2seq，seq2seq 循环网络的教学示例：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/seq2seq_example.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/seq2seq_example.py</a></p></blockquote><p>CNN Seq，应用一个 1-D 卷积网络从 IMDB 情感数据集中分类词序列</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/cnn_sentence_classification.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/cnn_sentence_classification.py</a></p></blockquote><p>强化学习案例<br>Atari Pacman 1-step Q-Learning，使用 1-step Q-learning 教一台机器玩 Atari 游戏：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/reinforcement_learning/atari_1step_qlearning.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/reinforcement_learning/atari_1step_qlearning.py</a></p></blockquote><h2 id="第三步：为TF新手准备的其他方面内容"><a href="#第三步：为TF新手准备的其他方面内容" class="headerlink" title="第三步：为TF新手准备的其他方面内容"></a>第三步：为TF新手准备的其他方面内容</h2><p>Recommender-Wide&amp;Deep Network，推荐系统中 wide &amp; deep 网络的教学示例：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/others/recommender_wide_and_deep.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/others/recommender_wide_and_deep.py</a></p></blockquote><p>Spiral Classification Problem，对斯坦福 CS231n spiral 分类难题的 TFLearn 实现：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/notebooks/spiral.ipynb" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/notebooks/spiral.ipynb</a></p></blockquote><p>层，与 TensorFlow 一起使用 TFLearn 层：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/layers.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/layers.py</a></p></blockquote><p>训练器，使用 TFLearn 训练器类训练任何 TensorFlow 图：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/layers.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/layers.py</a></p></blockquote><p>Bulit-in Ops，连同 TensorFlow 使用 TFLearn built-in 操作：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/builtin_ops.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/builtin_ops.py</a></p></blockquote><p>Summaries，连同 TensorFlow 使用 TFLearn summarizers：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/summaries.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/summaries.py</a></p></blockquote><p>Variables，连同 TensorFlow 使用 TFLearn Variables：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/variables.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/variables.py</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;第一步：给TF新手的教程指南&quot;&gt;&lt;a href=&quot;#第一步：给TF新手的教程指南&quot; class=&quot;headerlink&quot; title=&quot;第一步：给TF新手的教程指南&quot;&gt;&lt;/a&gt;第一步：给TF新手的教程指南&lt;/h2&gt;&lt;h3 id=&quot;1：tf初学者需要明白的入门准备&quot;
      
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="tf" scheme="http://yoursite.com/tags/tf/"/>
    
  </entry>
  
  <entry>
    <title>个性化推荐系统笔记</title>
    <link href="http://yoursite.com/2018/06/04/%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/04/个性化推荐系统笔记/</id>
    <published>2018-06-04T10:49:57.000Z</published>
    <updated>2018-09-22T07:36:53.176Z</updated>
    
    <content type="html"><![CDATA[<h2 id="推荐系统原理"><a href="#推荐系统原理" class="headerlink" title="推荐系统原理"></a>推荐系统原理</h2><hr><h2 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h2><h3 id="数据处理部分"><a href="#数据处理部分" class="headerlink" title="数据处理部分"></a>数据处理部分</h3><h4 id="导入的包"><a href="#导入的包" class="headerlink" title="导入的包"></a>导入的包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.ops <span class="keyword">import</span> math_ops</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> isfile, isdir</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br></pre></td></tr></table></figure><h4 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h4><p>1) <code>os.path.join(,)</code>将路径拼接起来；<br>2) <code>os.path.exists()</code>判断路径是否存在；<br>3) <code>print(&#39;Found {} Data&#39;.format(database_name))</code>字符串占位符写法<br>4) <code>os.makedirs()</code>创建目录；<code>shutil.rmtree</code>删除目录<br>5) <code>with...as...</code>处理上下文环境产生的异常。<strong>工作过程：</strong> 紧跟<code>with</code>后面的语句被求值后，返回对象的<code>__enter__()</code>方法被调用，这个方法的返回值将被赋值给<code>as</code>后面的变量。当<code>with</code>后面的代码块全部被执行完之后，将调用前面返回对象的<code>__exit__()</code>方法。<br>6) <code>DLProgress(tqdm)</code> 显示下载进度条的格式<br>7) <code>urlretrieve(url, filename=None, reporthook=None, data=None)</code></p><pre><code>- 参数`finename`指定了保存本地路径(如果参数未指定，`urllib`会生成一个临时文件保存数据)- 参数`reporthook`是一个回调函数，当连接上服务器、以及相应的数据块传输完毕时会触发该回调，我们可以利用这个回调函数来显示当前的下载进度。- 参数`data`指post到服务器的数据，该方法返回一个包含两个元素的(filename, headers)元组，filename表示保存到本地的路径，header表示服务器的响应头。</code></pre><p>8) <code>assert</code> 没完善一个程序之前，我们不知道程序在哪里会出错，与其让它在运行最崩溃，不如在出现错误条件时就崩溃，这时候就需要<code>assert</code>断言。其是声明其布尔值必须为真的判定，如果发生异常就说明表达示为假。可以理解<code>assert</code>断言语句为<code>raise-if-not</code>，用来测试表示式，其返回值为假，就会触发异常。<strong>assert的异常参数</strong>，其实就是在 <strong>断言表达式后添加字符串信息</strong>，用来解释断言并更好的知道是哪里出了问题。<br>9) <code>hashlib.md5(open(save_path, &#39;rb&#39;).read()).hexdigest()</code>打开文件并读取文件内容，通过<code>hashlib.md5</code>进行加密，<code>hexdigest()</code>获取加密字符串。<br>10) <code>zipfile.ZipFile(filename,&#39;r&#39;)</code>读取zip文件；<code>zipfile.ZipFile.extractall</code>解压zip文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_unzip</span><span class="params">(save_path, _, database_name, data_path)</span>:</span></span><br><span class="line">print(<span class="string">'Extracting &#123;&#125;...'</span>.format(database_name))</span><br><span class="line"><span class="keyword">with</span> zipfile.ZipFile(save_path) <span class="keyword">as</span> zf:</span><br><span class="line">zf.extractall(data_path)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_extract</span><span class="params">(database_name, data_path)</span>:</span></span><br><span class="line">DATASET_ML1M=<span class="string">'ml-1m'</span></span><br><span class="line"><span class="keyword">if</span> database_name==DATASET_ML1M:</span><br><span class="line">url=<span class="string">'http://files.grouplens.org/datasets/movielens/ml-1m.zip'</span></span><br><span class="line">hashcode=<span class="string">'c4d9eecfca2ab87c1945afe126590906'</span></span><br><span class="line">extract_path=os.path.join(data_path,<span class="string">'ml-1m'</span>)</span><br><span class="line">save_path=os.path.join(data_path,<span class="string">'ml-1m.zip'</span>)</span><br><span class="line">extract_fn=_unzip</span><br><span class="line"><span class="keyword">if</span> os.path.exists(extract_path):</span><br><span class="line">print(<span class="string">'Found &#123;&#125; Data'</span>.format(database_name))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(data_path):</span><br><span class="line">os.makedirs(data_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(save_path):</span><br><span class="line"><span class="keyword">with</span> DLProgress(unit=<span class="string">'B'</span>,unit_scale=<span class="keyword">True</span>,miniters=<span class="number">1</span>,desc=<span class="string">'Downloading &#123;&#125;'</span>.format(database_name)) <span class="keyword">as</span> pbar:</span><br><span class="line">urlretrieve(</span><br><span class="line">url,</span><br><span class="line">save_path,</span><br><span class="line">pbar.hook)</span><br><span class="line"><span class="keyword">assert</span> hashlib.md5(open(save_path,<span class="string">'rb'</span>).read()).hexdigest()==hashcode,\</span><br><span class="line"><span class="string">'&#123;&#125; file is corrupted. Remove the file and try again.'</span>.format(save_path)</span><br><span class="line">os.makedirs(extract_path)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">extract_fn(save_path,extract_path,database_name,data_path)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">shutil.rmtree(extract_path)</span><br><span class="line"><span class="keyword">raise</span> err</span><br><span class="line">print(<span class="string">'Done.'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLProgress</span><span class="params">(tqdm)</span>:</span></span><br><span class="line">last_block=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook</span><span class="params">(self,block_num=<span class="number">1</span>,block_size=<span class="number">1</span>,total_size=None)</span>:</span></span><br><span class="line">self.total=total_size</span><br><span class="line">self.update((block_num-self.last_block)*block_size)</span><br><span class="line">self.last_block=block_num</span><br></pre></td></tr></table></figure><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><ol><li><code>pd.read_table(&#39;./ml-1m/users.dat&#39;, sep=&#39;::&#39;, header=None, names=users_title, engine = &#39;python&#39;)</code> sep:分隔符；header：列名；names：结合header=None用于结果的列名列表。</li><li><code>users.filter(regex=&#39;UserID|Gender|Age|JobID&#39;)</code>过滤掉不符合条件，返回符合条件的数据。</li><li><code>users.values</code>原始数据；<code>users[&#39;Gender&#39;].map(gender_map)</code>映射</li><li><code>enumerate</code>对于一个可迭代的(iterable)/可遍历的对象(如列表、字符串)，<code>enumerate</code>将其组成一个索引序列，利用它可以同时获得索引和值</li><li><code>pattern = re.compile(r&#39;^(.*)\((\d+)\)$&#39;)</code>、<code>pattern.match(val).group(1)</code>返回匹配后的第一组数据。<br>6.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取User数据</span></span><br><span class="line">users_title = [<span class="string">'UserID'</span>, <span class="string">'Gender'</span>, <span class="string">'Age'</span>, <span class="string">'JobID'</span>, <span class="string">'Zip-code'</span>]</span><br><span class="line">users = pd.read_table(<span class="string">'./ml-1m/users.dat'</span>, sep=<span class="string">'::'</span>, header=<span class="keyword">None</span>, names=users_title, engine = <span class="string">'python'</span>)</span><br><span class="line">users = users.filter(regex=<span class="string">'UserID|Gender|Age|JobID'</span>)</span><br><span class="line">users_orig = users.values</span><br><span class="line"><span class="comment">#改变User数据中性别和年龄</span></span><br><span class="line">gender_map = &#123;<span class="string">'F'</span>:<span class="number">0</span>, <span class="string">'M'</span>:<span class="number">1</span>&#125;</span><br><span class="line">users[<span class="string">'Gender'</span>] = users[<span class="string">'Gender'</span>].map(gender_map)</span><br><span class="line"></span><br><span class="line">age_map = &#123;val:ii <span class="keyword">for</span> ii,val <span class="keyword">in</span> enumerate(set(users[<span class="string">'Age'</span>]))&#125;</span><br><span class="line">users[<span class="string">'Age'</span>] = users[<span class="string">'Age'</span>].map(age_map)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取Movie数据集</span></span><br><span class="line">movies_title = [<span class="string">'MovieID'</span>, <span class="string">'Title'</span>, <span class="string">'Genres'</span>]</span><br><span class="line">movies = pd.read_table(<span class="string">'./ml-1m/movies.dat'</span>, sep=<span class="string">'::'</span>, header=<span class="keyword">None</span>, names=movies_title, engine = <span class="string">'python'</span>)</span><br><span class="line">movies_orig = movies.values</span><br><span class="line"><span class="comment">#将Title中的年份去掉</span></span><br><span class="line">pattern = re.compile(<span class="string">r'^(.*)\((\d+)\)$'</span>)</span><br><span class="line"></span><br><span class="line">title_map = &#123;val:pattern.match(val).group(<span class="number">1</span>) <span class="keyword">for</span> ii,val <span class="keyword">in</span> enumerate(set(movies[<span class="string">'Title'</span>]))&#125;</span><br><span class="line">movies[<span class="string">'Title'</span>] = movies[<span class="string">'Title'</span>].map(title_map)</span><br><span class="line"></span><br><span class="line"><span class="comment">#电影类型转数字字典</span></span><br><span class="line">genres_set = set()</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> movies[<span class="string">'Genres'</span>].str.split(<span class="string">'|'</span>):</span><br><span class="line">genres_set.update(val)</span><br><span class="line"></span><br><span class="line">genres_set.add(<span class="string">'&lt;PAD&gt;'</span>)</span><br><span class="line">genres2int = &#123;val:ii <span class="keyword">for</span> ii, val <span class="keyword">in</span> enumerate(genres_set)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#将电影类型转成等长数字列表，长度是18</span></span><br><span class="line">genres_map = &#123;val:[genres2int[row] <span class="keyword">for</span> row <span class="keyword">in</span> val.split(<span class="string">'|'</span>)] <span class="keyword">for</span> ii,val <span class="keyword">in</span> enumerate(set(movies[<span class="string">'Genres'</span>]))&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> genres_map:</span><br><span class="line"><span class="keyword">for</span> cnt <span class="keyword">in</span> range(max(genres2int.values()) - len(genres_map[key])):</span><br><span class="line">genres_map[key].insert(len(genres_map[key]) + cnt,genres2int[<span class="string">'&lt;PAD&gt;'</span>])</span><br><span class="line"></span><br><span class="line">movies[<span class="string">'Genres'</span>] = movies[<span class="string">'Genres'</span>].map(genres_map)</span><br><span class="line"></span><br><span class="line"><span class="comment">#电影Title转数字字典</span></span><br><span class="line">title_set = set()</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> movies[<span class="string">'Title'</span>].str.split():</span><br><span class="line">title_set.update(val)</span><br><span class="line"></span><br><span class="line">title_set.add(<span class="string">'&lt;PAD&gt;'</span>)</span><br><span class="line">title2int = &#123;val:ii <span class="keyword">for</span> ii, val <span class="keyword">in</span> enumerate(title_set)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#将电影Title转成等长数字列表，长度是15</span></span><br><span class="line">title_count = <span class="number">15</span></span><br><span class="line">title_map = &#123;val:[title2int[row] <span class="keyword">for</span> row <span class="keyword">in</span> val.split()] <span class="keyword">for</span> ii,val <span class="keyword">in</span> enumerate(set(movies[<span class="string">'Title'</span>]))&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> title_map:</span><br><span class="line"><span class="keyword">for</span> cnt <span class="keyword">in</span> range(title_count - len(title_map[key])):</span><br><span class="line">title_map[key].insert(len(title_map[key]) + cnt,title2int[<span class="string">'&lt;PAD&gt;'</span>])</span><br><span class="line"></span><br><span class="line">movies[<span class="string">'Title'</span>] = movies[<span class="string">'Title'</span>].map(title_map)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取评分数据集</span></span><br><span class="line">ratings_title = [<span class="string">'UserID'</span>,<span class="string">'MovieID'</span>, <span class="string">'ratings'</span>, <span class="string">'timestamps'</span>]</span><br><span class="line">ratings = pd.read_table(<span class="string">'./ml-1m/ratings.dat'</span>, sep=<span class="string">'::'</span>, header=<span class="keyword">None</span>, names=ratings_title, engine = <span class="string">'python'</span>)</span><br><span class="line">ratings = ratings.filter(regex=<span class="string">'UserID|MovieID|ratings'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并三个表</span></span><br><span class="line">data = pd.merge(pd.merge(ratings, users), movies)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将数据分成X和y两张表</span></span><br><span class="line">target_fields = [<span class="string">'ratings'</span>]</span><br><span class="line">features_pd, targets_pd = data.drop(target_fields, axis=<span class="number">1</span>), data[target_fields]</span><br><span class="line"></span><br><span class="line">features = features_pd.values</span><br><span class="line">targets_values = targets_pd.values</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> title_count, title_set, genres2int, features, targets_values, ratings, users, movies, data, movies_orig, users_orig</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment">#title_count, title_set, genres2int, features, targets_values, ratings, users, movies, data, movies_orig, users_orig = load_data()</span></span><br><span class="line"><span class="comment">#pickle.dump((title_count, title_set, genres2int, features, targets_values, ratings, users, movies, data, movies_orig, users_orig), open('preprocess.p', 'wb'))</span></span><br><span class="line">title_count, title_set, genres2int, features, targets_values, ratings, users, movies, data, movies_orig, users_orig = pickle.load(open(<span class="string">'preprocess.p'</span>, mode=<span class="string">'rb'</span>))</span><br><span class="line">print(users.head())</span><br><span class="line">print(movies.head())</span><br><span class="line">print(movies.values[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>###</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;推荐系统原理&quot;&gt;&lt;a href=&quot;#推荐系统原理&quot; class=&quot;headerlink&quot; title=&quot;推荐系统原理&quot;&gt;&lt;/a&gt;推荐系统原理&lt;/h2&gt;&lt;hr&gt;
&lt;h2 id=&quot;程序解析&quot;&gt;&lt;a href=&quot;#程序解析&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
      <category term="深度学习整理总结" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="推荐" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>模式识别总结7_pca</title>
    <link href="http://yoursite.com/2018/05/22/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%80%BB%E7%BB%937-pca/"/>
    <id>http://yoursite.com/2018/05/22/模式识别总结7-pca/</id>
    <published>2018-05-22T05:52:28.000Z</published>
    <updated>2018-09-22T07:36:53.602Z</updated>
    
    <content type="html"><![CDATA[<h2 id="pca的用途"><a href="#pca的用途" class="headerlink" title="pca的用途"></a>pca的用途</h2><p>一个模式识别系统设计的好坏，首要取决于所选用的特征是否较好的反映了正在研究的问题。模式识别问题的第一步是获取特征，获取来的特征被称作原始特征，其中可能有很多特征与我们研究的问题没多大关系，它们在后续的分类中甚至还有可能影响分类性能；另外，就算这些特征都是与研究问题有联系的，但是太多的特征会导致计算量大、推广能力差，所以原始特征必须要进一步清洗得到二次特征，即在保证分类器效果的前提下应该使特征数尽可能的少，主要有两种办法：</p><ul><li>一种是特征选择，从D个特征中选出d(d小于D)个特征</li><li>另一种是特征提取或特征变换，通过把特征空间降维变换得到d个特征。</li></ul><p>关于特征选择，需要回答两方面的问题：</p><ul><li>特征的评价准则：如何衡量一组特征对分类的有效性</li><li>特征的寻优算法：怎样更快地找到性能最优或较好的特征组合。</li></ul><p>关于特征提取，通常采用线性变换:$y=W^Tx$；一般情况下的特征变换就是降维变换，即高维空间到低维空间的映射。<br><strong>主成分分析(Principle Component Analysis)</strong> 最早被提出是用于数据分析上的一种方法，其主要思想就是从一组特征中计算出一组按贡献程度从大到小排列的新特征，这组新特征是原始特征的线性组合，且相互之间不相关。</p><p>是通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫主成分。通俗的讲就是将分布在多个维度的高维数据投射到几个轴上。</p><h2 id="pca算法"><a href="#pca算法" class="headerlink" title="pca算法"></a>pca算法</h2><p>1、假设由数据的特征和记录构成二维矩阵$X$，即$X$的一列表示一个特征，一行表示一条记录(一个示例)，$X$是一个$m$行$n$列的矩阵(需要进行减去平均值处理)。</p><p>2、计算$X$的转置$X^T$。$X^T$为$n$行$m$列的矩阵。</p><p>3、计算$X^T$任意两行之间的协方差，得到一个$n$行$n$列的协方差矩阵$CovX$。</p><p>4、求$CovX$的特征值和特征向量，得到$n$个特征值和一个$n$行$n$列的特征向量矩阵$V_0$。</p><p>5、根据$n$个特征值的大小，降序排序，取最大的$k$个特征值，并取这$k$个特征值对应的特征向量，得到一个$k$行$n$列的特征向量矩阵$V$。</p><p>6、将$k$行$n$列的特征向量$V$与$n$行$m$列的矩阵$X^T$相乘，得到$k$行$m$列的矩阵$Y_0$。</p><p>7、将$Y_0$进行转置就得到$m$行$k$列的矩阵$Y$，这个矩阵$Y$就是包含$k$个主要成分的数据。<br>算法代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pca</span><span class="params">(dataMat,topNfeat=<span class="number">9999999</span>)</span>:</span></span><br><span class="line">meanVals=mean(dataMat,axis=<span class="number">0</span>)  <span class="comment">##axis的值表示哪一维度压缩为1.=0时表示输出一行，每一列的平均值</span></span><br><span class="line">meanRemoved=dataMat-meanVals   <span class="comment">##减去平均值</span></span><br><span class="line">covMat=cov(meanRemoved,rowvar=<span class="number">0</span>)  <span class="comment">##协方差</span></span><br><span class="line">eigVals,eigVects=linalg.eig(mat(covMat))  <span class="comment">##特征值和特征向量</span></span><br><span class="line">eigValInd=argsort(eigVals)    <span class="comment">##特征值排序从小到大</span></span><br><span class="line">eigValInd=eigValInd[:-(topNfeat+<span class="number">1</span>):<span class="number">-1</span>]   </span><br><span class="line">redEigVects=eigVects[:,eigValInd]   <span class="comment">##前topNfeat个特征及特征向量</span></span><br><span class="line">lowDDataMat=meanRemoved*redEigVects  </span><br><span class="line">reconMat=(lowDDataMat*redEigVects.T)+meanVals</span><br><span class="line"><span class="keyword">return</span> lowDDataMat,reconMat</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;pca的用途&quot;&gt;&lt;a href=&quot;#pca的用途&quot; class=&quot;headerlink&quot; title=&quot;pca的用途&quot;&gt;&lt;/a&gt;pca的用途&lt;/h2&gt;&lt;p&gt;一个模式识别系统设计的好坏，首要取决于所选用的特征是否较好的反映了正在研究的问题。模式识别问题的第一步是获取
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="模式识别" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>模式识别总结6_cluster、ensemble</title>
    <link href="http://yoursite.com/2018/05/22/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%80%BB%E7%BB%936-cluster%E3%80%81ensemble/"/>
    <id>http://yoursite.com/2018/05/22/模式识别总结6-cluster、ensemble/</id>
    <published>2018-05-22T05:52:03.000Z</published>
    <updated>2018-09-22T07:36:53.587Z</updated>
    
    <content type="html"><![CDATA[<h2 id="聚类clustering"><a href="#聚类clustering" class="headerlink" title="聚类clustering"></a>聚类clustering</h2><h3 id="监督学习vs非监督学习"><a href="#监督学习vs非监督学习" class="headerlink" title="监督学习vs非监督学习"></a>监督学习vs非监督学习</h3><ul><li>监督学习：在那些数据属性特征与目标类别属性相联系的数据集中发现其中的模式关系，这种模式关系被用来预测测试集数据的目标属性值</li><li>非监督学习：没有目标属性</li></ul><h3 id="聚类基础概念"><a href="#聚类基础概念" class="headerlink" title="聚类基础概念"></a>聚类基础概念</h3><p><strong>聚类</strong> 是数据挖掘中的基本任务，聚类是将大量数据集中具有“相似”特征的数据点划分为统一类别，并最终生成多个类的方法。</p><p>聚类分析的基本思想是 <strong>“物以类聚、人以群分”</strong>，因此大量的数据集中必然存在相似的数据点，基于这个假设就可以将数据区分出来，并发现每个数据集(分类)的特征。</p><p>与聚类的概念类似的另外一个概念是“分类”，实际上二者经常被混用。但二者根本上是不同的：</p><ul><li>学习方式不同。聚类是一种非监督式学习算法，而分类是监督式学习算法。</li><li>对源数据集要求不同。聚类不要求源数据集有标签，但分类需要标签用来做学习。</li><li>应用场景不同。聚类一般应用于做数据探索性分析，而分类更多的用于预测性分析。</li><li>解读结果不同。聚类算法的结果是将不同的数据集按照各自的典型特征分成不同类别，不同人对聚类的结果解读可能不同；而分类的结果却是一个固定值，不存在不同解读的情况。</li></ul><p>聚类是一类成熟且经典的数据挖掘和机器学习算法，按照不同的维度划分有很多经典的算法，如 <strong>K均值(K-Means)</strong>、两步聚类、Kohonen等，甚至Python提供了9种聚类算法。</p><h3 id="分区聚类-Partitional-Clustering"><a href="#分区聚类-Partitional-Clustering" class="headerlink" title="分区聚类(Partitional Clustering)"></a>分区聚类(Partitional Clustering)</h3><p>点到聚类$i$中心的距离：<br>$$se_{k_i}=\sum_{x_j\in Cluster\quad i}||x_j-C_i||^2$$<br>目标函数：<br>$$se_k=\sum_{i=1}^kse_{k_i}$$</p><h4 id="K均值-K-Means"><a href="#K均值-K-Means" class="headerlink" title="K均值(K-Means)"></a>K均值(K-Means)</h4><p>聚类首先面临的一个问题是，如何衡量不同数据之间的“相似度”。大多数“相似度”都是基于距离计算的，距离计算可以分为两类：</p><ul><li>基于几何距离的“相似度”<br>为了方便计算，假设平面上两点a(x1,y1)与b(x2,y2)）<ul><li>欧式距离 : a和b平方和的开方(结果越大，相似度越高)<br>$$d_{12}=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$$</li><li>曼哈顿距离 : 每个维度的距离之和(结果越大，相似度越高)<br>$$d_{12}=|x_1-x_2|+|y_1-y_2|$$</li><li>切比雪夫距离: 每个维度上距离的最大值(结果越大，相似度越高)<br>$$d_{12}=max(|x_1-x_2|,|y_1-y_2|)$$</li></ul></li><li>基于非几何距离的“相似度”<ul><li>余弦距离：两个向量的夹角<br>$$cos\theta=\dfrac{x_1x_2+y_1y_2}{\sqrt{x_1^2+y_1^2}\sqrt{x_2^2+y_2^2}}$$<br>夹角余弦取值范围为[-1,1]。夹角余弦越大表示两个向量的夹角越小，夹角余弦越小表示两向量的夹角越大。当两个向量的方向重合时夹角余弦取最大值1，当两个向量的方向完全相反夹角余弦取最小值-1。</li><li>汉明距离<br>两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。例如字符串“1111”与“1001”之间的汉明距离为2。</li><li>杰卡德相似系数(Jaccard similarity coefficient)<br>$$J(A,B)=\dfrac{|A\bigcap B|}{|A\bigcup B|}$$</li><li>相关系数(Correlation coefficient)<br>$$\rho_{XY}=\dfrac{Cov(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}=\dfrac{E((X-EX)(Y-EY))}{\sqrt{D(X)}\sqrt{D(Y)}}$$<br>相关系数是衡量随机变量X与Y相关程度的一种方法，相关系数的取值范围是[-1,1]。相关系数的绝对值越大，则表明X与Y相关度越高。当X与Y线性相关时，相关系数取值为1(正线性相关)或-1(负线性相关)。</li></ul></li></ul><p>除了上述常用相似度计算方法外，还可能包括马氏距离、闵可夫斯基距离、标准欧氏距离等。</p><p>回到本文的主题 <strong>K-Means算法</strong> 来，通过上述算法来计算数据相似度(大多数选择欧氏距离)，但我们会发现不同维度间由于度量单位的差异，计算的结果值会产生很大差异。例如假设A和B两个点分别具有两个维度：订单金额和转化率，那么订单金额的取值范围可能是0到无穷大，而转化率的取值为0到1，因此计算结果会由于订单金额的取值范围而“片面”夸大了这一维度的计算比重。所以大多数情况下，如果存在这种度量量级的差异会选择数据标准化，使不同维度落到相同的数据区间内然后进行计算。</p><blockquote><p>上面说到大多数情况下需要标准化，就意味着不是所有的场景下都需要标准化，一种是原有的数据维度之间的量级差异不大，因此没有必要标准化；二是标准化后的结果在解读时会出现难以还原的问题，例如原本均值为180在标准化后可能就是0.31，而这个数据很难还原，只能进行相对其他维度的解读。</p></blockquote><p><strong>K-Means的计算步骤如下：</strong></p><ul><li>为每个聚类确定一个初始聚类中心，这样就有K个初始聚类中心。</li><li>将样本集中的样本按照最小距离原则分配到最邻近聚类。</li><li>使用每个聚类中的样本均值作为新的聚类中心。</li><li>重复步骤2.3直到聚类中心不再变化。</li><li>结束，得到K个聚类</li></ul><p>K-Means的计算既然作为一种经典算法，一定有很多 <strong>优势</strong>：</p><ul><li>它是解决聚类问题的一种经典算法，简单、快速而且可以用于多种数据类型。</li><li>对处理大数据集，该算法是相对可伸缩和高效率的。</li><li>因为它的复杂度是O(n k t ) , 其中, n 是所有对象的数目，k 是簇的数目，t 是迭代的次数。通常k &lt; &lt;n 且t &lt; &lt;n 。</li><li>算法尝试找出使平方误差函数值最小的k个划分。当结果簇是密集的，而簇与簇之间区别明显时, 它的效果较好。</li></ul><p>但是，传统K-Means也有很多 <strong>不足</strong>：</p><ul><li>既然基于均值计算，那么要求簇的平均值可以被定义和使用，此时字符串等非数值型数据则不适用。</li><li>K-Means的第一步是确定k（要生成的簇的数目），对于不同的初始值K，可能会导致不同结果。</li><li>应用数据集存在局限性，适用于球状或集中分布数据，不适用于特殊情况数据。如下面这种非球状的数据分布就无法正确分类。<br><img src="/2018/05/22/模式识别总结6-cluster、ensemble/pic1.png" alt=""></li><li>它对于“躁声”和孤立点数据是敏感的，少量的该类数据能够对平均值产生极大的影响。</li></ul><h4 id="模糊C均值聚类FCM"><a href="#模糊C均值聚类FCM" class="headerlink" title="模糊C均值聚类FCM"></a>模糊C均值聚类FCM</h4><p>FCM算法是基于对目标函数的优化基础上的一种数据聚类方法。聚类结果是每一个数据点对聚类中心的隶属程度，该隶属程度用一个数值来表示。FCM算法是一种无监督的模糊聚类方法，在算法实现过程中不需要人为的干预。这种算法的不足之处:首先，算法中需要设定一些参数，若参数的初始化选取的不合适，可能影响聚类结果的正确性;其次，当数据样本集合较大并且特征数目较多时，算法的实时性不太好。<br><strong>目标函数：</strong><br>$$J=\sum_{i=1}^C\sum_{k=1}^N(u_{i,k})^md_{i,k}^2\quad s.t.\sum_{i=1}^Cu_{i,k}=1$$<br><strong>聚类中心迭代公式：</strong><br>$$V_i=\frac{\sum_{k=1}^N(u_{i,k})^mx_k}{\sum_{k=1}^N(u_{i,k})^m}$$<br><strong>每个样本$k$属于类$i$的隶属度：</strong><br>$$u_{i,k}=\dfrac{1}{\sum_{j=1}^C(\dfrac{d_{k,i}}{d_{k,j}})^{\frac{2}{m-1}}}$$<br><strong>距离公式：</strong><br>$$d_{i,k}^2=||x_k-V_i||^2$$<br><strong>算法步骤：</strong></p><ul><li>初始化数据集</li><li>初始化隶属度数组</li><li>根据隶属度数组更新聚类中心</li><li>根据聚类中心更新隶属度数组</li><li>是否达到结束条件，没有达到则重复2-4步骤。</li></ul><h3 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h3><h4 id="Agglomerative-clustering"><a href="#Agglomerative-clustering" class="headerlink" title="Agglomerative clustering"></a>Agglomerative clustering</h4><p>是一种自底而上的层次聚类方法，它能够根据指定的相似度或距离定义计算出类之间的距离.<br><strong>Dendrogram：</strong> 依次将符合条件的类相连，最后得到使算法与数据均形象化的树状结构图。专门用来描述经层次聚类算法得到的结果。<br><img src="/2018/05/22/模式识别总结6-cluster、ensemble/pic2.png" alt=""><br><strong>Agglomerative Clustering Algorithm</strong></p><ul><li>1.将每一个元素单独定为一类</li><li>2.重复：每一轮都合并指定距离(对指定距离的理解很重要)最小的类</li><li>3.直到所有的元素都归为同一类</li></ul><p><strong>算法步骤：</strong></p><ul><li>将每个对象归为一类, 共得到N类, 每类仅包含一个对象. 类与类之间的距离就是它们所包含的对象之间的距离.</li><li>找到最接近的两个类并合并成一类, 于是总的类数少了一个.</li><li>重新计算新的类与所有旧类之间的距离.</li><li>重复第2步和第3步, 直到最后合并成一个类为止(此类包含了N个对象).</li></ul><p><strong>根据步骤三的不同，Agglomerative Clustering的三种不同方法</strong><br>依据对相似度(距离)的不同定义，将Agglomerative Clustering的聚类方法分为三种：</p><ul><li>Single-linkage:要比较的距离为元素对之间的最小距离(两个聚类的相似度取决于两个不同簇中最近的两个点)</li><li>Complete-linkage:要比较的距离为元素对之间的最大距离(组间距离等于两组对象之间的最大距离。)</li><li>Group average：要比较的距离为类之间的平均距离(平均距离的定义与计算：假设有A，B两个类，A中有n个元素，B中有m个元素。在A与B中各取一个元素，可得到他们之间的距离。将nm个这样的距离相加，得到距离和。最后距离和除以nm得到A，B两个类的平均距离。)</li></ul><h4 id="divisive"><a href="#divisive" class="headerlink" title="divisive"></a>divisive</h4><p>是一种自顶而下的层次聚类方法</p><h2 id="集成ensemble"><a href="#集成ensemble" class="headerlink" title="集成ensemble"></a>集成ensemble</h2><p>对于训练集数据，我们通过训练若干个个体学习器，通过一定的结合策略，就可以最终形成一个强学习器，以达到博采众长的目的。<br><img src="/2018/05/22/模式识别总结6-cluster、ensemble/pic3.png" alt=""><br>目前来说，<strong>同质个体学习器</strong> (个体学习器都是一个种类的，例如都是决策树的，或者都是神经网络的)的应用是最广泛的，一般我们常说的集成学习的方法都是指的同质个体学习器。而同质个体学习器使用最多的模型是CART决策树和神经网络。同质个体学习器按照个体学习器之间是否存在依赖关系可以分为两类，第一个是个体学习器之间存在 <strong>强依赖关系</strong>，一系列个体学习器基本都需要 <strong>串行生成</strong>，代表算法是 <strong>boosting系列算法</strong>，第二个是个体学习器之间不存在强依赖关系，一系列个体学习器可以 <strong>并行生成</strong>，代表算法是 <strong>bagging</strong> 和 <strong>随机森林(Random Forest)系列算法</strong>。</p><h3 id="boosting"><a href="#boosting" class="headerlink" title="boosting"></a>boosting</h3><p><img src="/2018/05/22/模式识别总结6-cluster、ensemble/pic4.png" alt=""><br>从图中可以看出，Boosting算法的工作机制是首先从训练集用初始权重训练出一个弱学习器1，根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器1学习误差率高的训练样本点的权重变高，使得这些误差率高的点在后面的弱学习器2中得到更多的重视。然后基于调整权重后的训练集来训练弱学习器2.，如此重复进行，直到弱学习器数达到事先指定的数目T，最终将这T个弱学习器通过集合策略进行整合，得到最终的强学习器。　　</p><p>不过有几个具体的问题Boosting算法没有详细说明。<br>1) 如何计算学习误差率e?<br>2) 如何得到弱学习器权重系数α?<br>3) 如何更新样本权重D?<br>4) 使用何种结合策略？</p><h4 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h4><h5 id="分类问题算法"><a href="#分类问题算法" class="headerlink" title="分类问题算法"></a>分类问题算法</h5><p>输入为样本集$T={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}$，输出为{-1, +1}，弱分类器算法, 弱分类器迭代次数$K$。输出为最终的强分类器$f(x)$</p><p>初始化样本集权重为<br>$$D(1)=(w_{11},w_{12},…w_{1m});w_{1i}=\frac{1}{m};i=1,2…m$$<br>对于$k=1,2,…K$:</p><ul><li>使用具有权重$D_k$的样本集来训练数据，得到弱分类器$G_k(x)$</li><li>计算Gk(x)的分类误差率<br>$$e_k=P(G_k(x_i)≠y_i)=\sum_{i=1}^mw_{ki}I(G_k(x_i)≠y_i)$$</li><li>计算弱分类器的系数<br>$$α_k=\frac{1}{2}log\frac{1-e_k}{e_k}$$</li><li>更新样本集的权重分布<br>$$w_{k+1,i}=\frac{w_{ki}}{Z_K}exp(-α_ky_iG_k(x_i))\quad i=1,2,…m$$<br>这里$Z_k$是规范化因子<br>$$Z_k=\sum_{i=1}^mw_{ki}exp(-α_ky_iG_k(x_i))$$</li></ul><p>构建最终分类器为：<br>$$f(x)=sign(\sum_{k=1}^Kα_kG_k(x))$$<br>　　　　<br>对于Adaboost多元分类算法，其实原理和二元分类类似，最主要区别在弱分类器的系数上。比如Adaboost SAMME算法，它的弱分类器的系数<br>$$α_k=\frac{1}{2}log\frac{1-e_k}{e_k}+log(R-1)$$<br>其中R为类别数。从上式可以看出，如果是二元分类，R=2，则上式和我们的二元分类算法中的弱分类器的系数一致。</p><h5 id="回归问题算法"><a href="#回归问题算法" class="headerlink" title="回归问题算法"></a>回归问题算法</h5><p>输入为样本集$T={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}$，弱学习器算法, 弱学习器迭代次数$K$。输出为最终的强学习器$f(x)$<br>初始化样本集权重为<br>$$D(1)=(w_{11},w_{12},…w_{1m});w_{1i}=\frac{1}{m};i=1,2…m$$<br>对于$k=1,2,…K$:</p><ul><li>使用具有权重$D_k$的样本集来训练数据，得到弱学习器$G_k(x)$</li><li>计算训练集上的最大误差<br>$$E_k=max|y_i-G_k(x_i)|i=1,2…m$$</li><li>计算每个样本的相对误差:<ul><li>如果是线性误差，则$e_{ki}=\frac{|y_i-G_k(x_i)|}{E_k}$；</li><li>如果是平方误差，则$e_{ki}=\frac{(y_i-G_k(x_i))^2}{E^2_k}$</li><li>如果是指数误差，则$e_{ki}=1-exp(\frac{-y_i+G_k(x_i))}{E_k})$　　　　　　　　</li></ul></li><li>计算回归误差率<br>$$e_k=\sum_{i=1}^mw_{ki}e_{ki}$$</li><li>计算弱学习器的系数<br>$$α_k=\frac{e_k}{1-e_k}$$</li><li>更新样本集的权重分布为<br>$$w_{k+1,i}=\frac{w_{ki}}{Z_k}α<em>k^{1-e</em>{ki}}$$</li></ul><p>这里$Z_k$是规范化因子<br>$$Z_k=\sum_{i=1}^mw_{ki}α<em>k^{1-e</em>{ki}}$$</p><p>构建最终强学习器为：<br>$$f(x)=\sum_{k=1}^K(ln\frac{1}{αk})g(x)$$<br>其中，$g(x)$是所有$α_kG_k(x),k=1,2,….K$的中位数。　　　　</p><h5 id="Adaboost算法的正则化"><a href="#Adaboost算法的正则化" class="headerlink" title="Adaboost算法的正则化"></a>Adaboost算法的正则化</h5><p>为了防止Adaboost过拟合，我们通常也会加入正则化项，这个正则化项我们通常称为 <strong>步长(learning rate)</strong>。定义为$ν$,对于前面的弱学习器的迭代<br>$$f_k(x)=f_{k-1}(x)+α_kG_k(x)$$<br>如果我们加上了正则化项，则有<br>$$f_k(x)=f_{k-1}(x)+να_kG_k(x)$$<br>$ν$的取值范围为$0&lt;ν≤1$。对于同样的训练集学习效果，较小的$ν$意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。</p><h4 id="梯度提升树GBDT"><a href="#梯度提升树GBDT" class="headerlink" title="梯度提升树GBDT"></a>梯度提升树GBDT</h4><p>在GBDT的迭代中，假设我们前一轮迭代得到的强学习器是$f_{t-1}(x)$, 损失函数是$L(y,f_{t-1}(x))$, 我们本轮迭代的目标是找到一个CART回归树模型的弱学习器$h_t(x)$，让本轮的损失损失$L(y,f_t(x)=L(y,f_{t-1}(x)+h_t(x))$最小。也就是说，本轮迭代找到决策树，要让样本的损失尽量变得更小。</p><p>GBDT的思想可以用一个通俗的例子解释，假如有个人30岁，我们首先用20岁去拟合，发现损失有10岁，这时我们用6岁去拟合剩下的损失，发现差距还有4岁，第三轮我们用3岁拟合剩下的差距，差距就只有一岁了。如果我们的迭代轮数还没有完，可以继续迭代下面，每一轮迭代，拟合的岁数误差都会减小。</p><p>从上面的例子看这个思想还是蛮简单的，但是有个问题是这个损失的拟合不好度量，损失函数各种各样，怎么找到一种通用的拟合方法呢？</p><h5 id="GBDT的负梯度拟合"><a href="#GBDT的负梯度拟合" class="headerlink" title="GBDT的负梯度拟合"></a>GBDT的负梯度拟合</h5><p>在上一节中，我们介绍了GBDT的基本思路，但是没有解决损失函数拟合方法的问题。针对这个问题，大牛Freidman提出了用损失函数的负梯度来拟合本轮损失的近似值，进而拟合一个CART回归树。第$t$轮的第$i$个样本的损失函数的负梯度表示为<br>$$r_{ti}=-[\frac{∂L(y_i,f(x_i))}{∂f(x_i)}\rbrack_{f(x)}=f_{t-1}(x)$$</p><p>利用$(x_i,r_{ti})(i=1,2,..m)$,我们可以拟合一颗CART回归树，得到了第$t$颗回归树，其对应的叶节点区域$R_{tj},j=1,2,…,J$。其中$J$为叶子节点的个数。</p><p>针对每一个叶子节点里的样本，我们求出使损失函数最小，也就是拟合叶子节点最好的的输出值$c_{tj}$如下：</p><p>$$c_{tj}=\underbrace{arg\;min}<em>{c}\sum</em>{x_i\in R_{tj}}L(y_i,f_{t-1}(x_i)+c)$$</p><p>这样我们就得到了本轮的决策树拟合函数如下：<br>$$h_t(x) = \sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})$$</p><p>从而本轮最终得到的强学习器的表达式如下：<br>$$f_{t}(x) = f_{t-1}(x) + \sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})$$</p><p>通过损失函数的负梯度来拟合，我们找到了一种通用的拟合损失误差的办法，这样无轮是分类问题还是回归问题，我们通过其损失函数的负梯度的拟合，就可以用GBDT来解决我们的分类回归问题。区别仅仅在于损失函数不同导致的负梯度不同而已。</p><h5 id="GBDT回归算法"><a href="#GBDT回归算法" class="headerlink" title="GBDT回归算法"></a>GBDT回归算法</h5><p>好了，有了上面的思路，下面我们总结下GBDT的回归算法。为什么没有加上分类算法一起？那是因为分类算法的输出是不连续的类别值，需要一些处理才能使用负梯度。</p><p>输入是训练集样本$T={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}$，最大迭代次数$T$, 损失函数$L$。输出是强学习器$f(x)$<br>初始化弱学习器<br>$$f_0(x) = \underbrace{arg\; min}<em>{c}\sum\limits</em>{i=1}^{m}L(y_i, c)$$</p><p>对迭代轮数$t=1,2,…T$有：</p><ul><li><p>对样本$i=1,2,…m$，计算负梯度<br>$$r_{ti} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg\rbrack_{f(x) = f_{t-1}\;\; (x)}$$</p></li><li><p>利用$(x_i,r_{ti})(i=1,2,..m)$, 拟合一颗CART回归树,得到第t颗回归树，其对应的叶子节点区域为$R_{tj},j=1,2,…,J$。其中J为回归树t的叶子节点的个数。</p></li><li><p>对叶子区域$j=1,2,..J$,计算最佳拟合值<br>$$c_{tj} = \underbrace{arg\; min}<em>{c}\sum\limits</em>{x_i \in R_{tj}} L(y_i,f_{t-1}(x_i) +c)$$</p></li><li><p>更新强学习器<br>$$f_{t}(x) = f_{t-1}(x) + \sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})$$<br>得到强学习器f(x)的表达式</p></li></ul><p>$$f(x) = f_T(x) =f_0(x) + \sum\limits_{t=1}^{T}\sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})$$</p><h5 id="GBDT分类算法"><a href="#GBDT分类算法" class="headerlink" title="GBDT分类算法"></a>GBDT分类算法</h5><p>GBDT的分类算法从思想上和GBDT的回归算法没有区别，但是由于样本输出不是连续的值，而是离散的类别，导致我们无法直接从输出类别去拟合类别输出的误差。</p><p>为了解决这个问题，主要有两个方法，一个是用指数损失函数，此时GBDT退化为Adaboost算法。另一种方法是用类似于逻辑回归的对数似然损失函数的方法。也就是说，我们用的是类别的预测概率值和真实概率值的差来拟合损失。本文仅讨论用对数似然损失函数的GBDT分类。而对于对数似然损失函数，我们又有二元分类和多元分类的区别。</p><h6 id="二元GBDT分类算法"><a href="#二元GBDT分类算法" class="headerlink" title="二元GBDT分类算法"></a>二元GBDT分类算法</h6><p>对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数为：<br>$$L(y, f(x)) = log(1+ exp(-yf(x)))$$<br>其中$y \in{-1, +1}$。则此时的负梯度误差为<br>$$r_{ti} = -\bigg[\frac{\partial L(y, f(x_i)))}{\partial f(x_i)}\bigg\rbrack_{f(x) = f_{t-1}\;\; (x)} = y_i/(1+exp(y_if(x_i)))$$</p><p>对于生成的决策树，我们各个叶子节点的最佳残差拟合值为</p><p>$$c_{tj}=\underbrace{arg\; min}<em>{c}\sum</em>{x_i\in R_{tj}}log(1+exp(-y_i(f_{t-1}(x_i)+c)))$$</p><p>由于上式比较难优化，我们一般使用近似值代替<br>$$c_{tj}=\dfrac{\sum_{x_i\in R_{tj}}r_{ti}}{\sum_{x_i\in R_{tj}}|r_{ti}|(1-|r_{ti}|)}$$</p><p>除了负梯度计算和叶子节点的最佳残差拟合的线性搜索，二元GBDT分类和GBDT回归算法过程相同。</p><h6 id="多元GBDT分类算法"><a href="#多元GBDT分类算法" class="headerlink" title="多元GBDT分类算法"></a>多元GBDT分类算法</h6><p>多元GBDT要比二元GBDT复杂一些，对应的是多元逻辑回归和二元逻辑回归的复杂度差别。假设类别数为$K$，则此时我们的对数似然损失函数为：<br>$$L(y, f(x)) = -  \sum\limits_{k=1}^{K}y_klog\;p_k(x)$$<br>其中如果样本输出类别为$k$，则$y_k=1$。第$k$类的概率$p_k(x)$的表达式为：<br>$$p_k(x) = exp(f_k(x)) \bigg / \sum\limits_{l=1}^{K} exp(f_l(x))$$<br>集合上两式，我们可以计算出第$t$轮的第$i$个样本对应类别$l$的负梯度误差为<br>$$r_{til} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f_k(x) = f_{l, t-1}\;\; (x)} = y_{il} - p_{l, t-1}(x_i)$$<br>观察上式可以看出，其实这里的误差就是样本$i$对应类别$l$的真实概率和$t-1$轮预测概率的差值。<br>对于生成的决策树，我们各个叶子节点的最佳残差拟合值为<br>$$c_{tjl} = \underbrace{arg\; min}_{c_{jl}}\sum\limits_{i=0}^{m}\sum\limits_{k=1}^{K} L(y_k, f_{t-1, l}(x) + \sum\limits_{j=0}^{J}c_{jl} I(x_i \in R_{tj}))$$<br>由于上式比较难优化，我们一般使用近似值代替<br>$$c_{tjl} =  \frac{K-1}{K} \; \frac{\sum\limits_{x_i \in R_{tjl}}r_{til}}{\sum\limits_{x_i \in R_{til}}|r_{til}|(1-|r_{til}|)}$$<br>除了负梯度计算和叶子节点的最佳残差拟合的线性搜索，多元GBDT分类和二元GBDT分类以及GBDT回归算法过程相同。</p><h5 id="GBDT常用损失函数"><a href="#GBDT常用损失函数" class="headerlink" title="GBDT常用损失函数"></a>GBDT常用损失函数</h5><p>对常用的GBDT损失函数做一个总结。<br>对于分类算法，其损失函数一般有对数损失函数和指数损失函数两种:<br>1) 如果是指数损失函数，则损失函数表达式为<br>$$L(y, f(x)) = exp(-yf(x))$$<br>其负梯度计算和叶子节点的最佳残差拟合参见Adaboost原理。<br>2) 如果是对数损失函数，分为二元分类和多元分类两种。</p><p>对于回归算法，常用损失函数有如下4种:<br>1) 均方差，这个是最常见的回归损失函数了<br>$$L(y, f(x)) =(y-f(x))^2$$<br>2) 绝对损失，这个损失函数也很常见<br>$$L(y,f(x))=|y-f(x)|$$<br>对应负梯度误差为：<br>$$sign(y_i-f(x_i))$$<br>3) Huber损失，它是均方差和绝对损失的折衷产物，对于远离中心的异常点，采用绝对损失，而中心附近的点采用均方差。这个界限一般用分位数点度量。损失函数如下：<br>$$L(y, f(x))= \begin{cases} \frac{1}{2}(y-f(x))^2&amp; {|y-f(x)| \leq \delta}\ \delta(|y-f(x)| - \frac{\delta}{2})&amp; {|y-f(x)| &gt; \delta} \end{cases}$$　　　　<br>对应的负梯度误差为：<br>$$r(y_i, f(x_i))= \begin{cases} y_i-f(x_i)&amp; {|y_i-f(x_i)| \leq \delta}\ \delta sign(y_i-f(x_i))&amp; {|y_i-f(x_i)| &gt; \delta} \end{cases}$$<br>4) 分位数损失。它对应的是分位数回归的损失函数，表达式为<br>$$L(y, f(x)) =\sum\limits_{y \geq f(x)}\theta|y - f(x)| + \sum\limits_{y &lt; f(x)}(1-\theta)|y - f(x)|$$<br>其中$θ$为分位数，需要我们在回归前指定。对应的负梯度误差为：<br>$$r(y_i, f(x_i))= \begin{cases} \theta&amp; { y_i \geq f(x_i)}\ \theta - 1 &amp; {y_i &lt; f(x_i) } \end{cases}$$<br>对于Huber损失和分位数损失，主要用于健壮回归，也就是减少异常点对损失函数的影响。</p><h5 id="GBDT的正则化"><a href="#GBDT的正则化" class="headerlink" title="GBDT的正则化"></a>GBDT的正则化</h5><p>和Adaboost一样，我们也需要对GBDT进行正则化，防止过拟合。GBDT的正则化主要有三种方式。<br>第一种是和Adaboost类似的正则化项，即步长(learning rate)。定义为ν,对于前面的弱学习器的迭代<br>$$f_k(x)=f_{k-1}(x)+h_k(x)$$<br>如果我们加上了正则化项，则有<br>$$f_k(x)=f_{k-1}(x)+νh_k(x)$$<br>ν的取值范围为$0&lt;ν≤1$。对于同样的训练集学习效果，较小的$ν$意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。</p><p>第二种正则化的方式是通过子采样比例(subsample)。取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。推荐在[0.5, 0.8]之间。</p><p>使用了子采样的GBDT有时也称作随机梯度提升树(Stochastic Gradient Boosting Tree, SGBT)。由于使用了子采样，程序可以通过采样分发到不同的任务去做boosting的迭代过程，最后形成新树，从而减少弱学习器难以并行学习的弱点。</p><p>第三种是对于弱学习器即CART回归树进行正则化剪枝。</p><h3 id="bagging"><a href="#bagging" class="headerlink" title="bagging"></a>bagging</h3><p><img src="/2018/05/22/模式识别总结6-cluster、ensemble/pic5.png" alt=""><br>其特点即为：<strong>随机采样</strong><br>随机采样(bootstrap)就是从我们的训练集里面采集固定个数的样本，但是每采集一个样本后，都将样本放回。也就是说，之前采集到的样本在放回后有可能继续被采集到。对于我们的Bagging算法，一般会随机采集和训练集样本数$m$一样个数的样本。这样得到的采样集和训练集样本的个数相同，但是样本内容不同。如果我们对有$m$个样本训练集做$T$次的随机采样，，则由于随机性，$T$个采样集各不相同。</p><p>对于一个样本，它在某一次含$m$个样本的训练集的随机采样中，每次被采集到的概率是$\dfrac{1}{m}$，不被采集到的概率为$1-\dfrac{1}{m}$。如果$m$次采样都没有被采集中的概率是$(1-\dfrac{1}{m})^m$。当m→∞时，$(1-\dfrac{1}{m})^m$→$\dfrac{1}{e}≃0.368$。也就是说，在bagging的每轮随机采样中，训练集中大约有36.8%的数据没有被采样集采集中，这部分数据称之为 <strong>袋外数据OOB</strong>。这些数据没有参与训练集模型的拟合，因此可以用来检测模型的泛化能力。</p><p>bagging对于弱学习器没有限制，这和Adaboost一样。但是最常用的一般也是 <strong>决策树和神经网络。</strong></p><p>bagging的集合策略也比较简单，对于分类问题，通常使用 <strong>简单投票法</strong>，得到最多票数的类别或者类别之一为最终的模型输出。对于回归问题，通常使用 <strong>简单平均法</strong>，对T个弱学习器得到的回归结果进行算术平均得到最终的模型输出。</p><p>由于Bagging算法每次都进行采样来训练模型，因此泛化能力很强，对于降低模型的方差很有作用。当然对于训练集的拟合程度就会差一些，也就是模型的偏倚会大一些。</p><p><strong>装袋法的算法步骤：</strong></p><ul><li>从原始样本集中抽取训练集.每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）.共进行k轮抽取，得到k个训练集.（k个训练集相互独立）</li><li>每次使用一个训练集得到一个模型，k个训练集共得到k个模型.（注：根据具体问题采用不同的分类或回归方法，如决策树、神经网络等）</li><li>对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果.</li></ul><h3 id="随机森林Random-Forest-RF"><a href="#随机森林Random-Forest-RF" class="headerlink" title="随机森林Random Forest,RF"></a>随机森林Random Forest,RF</h3><p><strong>与bagging的不同之处：</strong></p><ul><li>首先，RF使用了CART决策树作为弱学习器，这让我们想到了梯度提示树GBDT。</li><li>第二，在使用决策树的基础上，RF对决策树的建立做了改进，对于普通的决策树，我们会在节点上所有的n个样本特征中选择一个最优的特征来做决策树的左右子树划分，但是RF通过随机选择节点上的一部分样本特征，这个数字小于$n$，假设为$n_{sub}$，然后在这些随机选择的$n_{sub}$个样本特征中，选择一个最优的特征来做决策树的左右子树划分。这样进一步增强了模型的泛化能力。　　　　</li></ul><p>如果$n_{sub}=n$，则此时RF的CART决策树和普通的CART决策树没有区别。$n_{sub}$越小，则模型约健壮，当然此时对于训练集的拟合程度会变差。也就是说$n_{sub}$越小，模型的方差会减小，但是偏倚会增大。在实际案例中，一般会通过交叉验证调参获取一个合适的$n_{sub}$的值。</p><h4 id="extra-trees"><a href="#extra-trees" class="headerlink" title="extra trees"></a>extra trees</h4><p>extra trees是RF的一个变种, 原理几乎和RF一模一样，仅有区别有：</p><ul><li>对于每个决策树的训练集，RF采用的是随机采样bootstrap来选择采样集作为每个决策树的训练集，而extra trees一般不采用随机采样，即每个决策树采用原始训练集。</li><li>在选定了划分特征后，RF的决策树会基于信息增益，基尼系数，均方差之类的原则，选择一个最优的特征值划分点，这和传统的决策树相同。但是extra trees比较的激进，他会随机的选择一个特征值来划分决策树。</li></ul><p>从第二点可以看出，由于随机选择了特征值的划分点位，而不是最优点位，这样会导致生成的决策树的规模一般会大于RF所生成的决策树。也就是说，模型的方差相对于RF进一步减少，但是偏倚相对于RF进一步增大。在某些时候，extra trees的泛化能力比RF更好。</p><h4 id="Totally-Random-Trees-Embedding"><a href="#Totally-Random-Trees-Embedding" class="headerlink" title="Totally Random Trees Embedding"></a>Totally Random Trees Embedding</h4><p>Totally Random Trees Embedding(以下简称 TRTE)是一种非监督学习的数据转化方法。它将低维的数据集映射到高维，从而让映射到高维的数据更好的运用于分类回归模型。我们知道，在支持向量机中运用了核方法来将低维的数据集映射到高维，此处TRTE提供了另外一种方法。</p><p>TRTE在数据转化的过程也使用了类似于RF的方法，建立T个决策树来拟合数据。当决策树建立完毕以后，数据集里的每个数据在T个决策树中叶子节点的位置也定下来了。比如我们有3颗决策树，每个决策树有5个叶子节点，某个数据特征x划分到第一个决策树的第2个叶子节点，第二个决策树的第3个叶子节点，第三个决策树的第5个叶子节点。则x映射后的特征编码为$(0,1,0,0,0,\quad0,0,1,0,0,\quad0,0,0,0,1)$, 有15维的高维特征。这里特征维度之间加上空格是为了强调三颗决策树各自的子编码。</p><p>映射到高维特征后，可以继续使用监督学习的各种分类回归算法了。</p><h4 id="Isolation-Forest"><a href="#Isolation-Forest" class="headerlink" title="Isolation Forest"></a>Isolation Forest</h4><p>Isolation Forest(以下简称IForest)是一种异常点检测的方法。它也使用了类似于RF的方法来检测异常点。</p><p>对于在T个决策树的样本集，IForest也会对训练集进行随机采样,但是采样个数不需要和RF一样，<strong>对于RF，需要采样到采样集样本个数等于训练集个数</strong>。但是IForest不需要采样这么多，一般来说，采样个数要远远小于训练集个数？为什么呢？因为我们的目的是异常点检测，只需要部分的样本我们一般就可以将异常点区别出来了。</p><p>对于每一个决策树的建立， IForest采用随机选择一个划分特征，对划分特征随机选择一个划分阈值。这点也和RF不同。</p><p>另外，IForest一般会选择一个比较小的最大决策树深度max_depth,原因同样本采集，用少量的异常点检测一般不需要这么大规模的决策树。</p><p>对于异常点的判断，则是将测试样本点$x$拟合到$T$颗决策树。计算在每颗决策树上该样本的叶子节点的深度$h_t(x)$。，从而可以计算出平均高度$h(x)$。此时我们用下面的公式计算样本点$x$的异常概率:<br>$$s(x,m)=2^{-\frac{h(x)}{c(m)}}$$<br>其中，$m$为样本个数。$c(m)$的表达式为：<br>$$c(m)=2ln(m-1)+ξ-2\frac{m-1}{m}$$<br>$ξ$为欧拉常数<br>$s(x,m)$的取值范围是[0,1],取值越接近于1，则是异常点的概率也越大。</p><h3 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h3><p>假定我得到的$T$个弱学习器是${h_1,h_2,…h_T}$</p><h4 id="平均法"><a href="#平均法" class="headerlink" title="平均法"></a>平均法</h4><p>对于数值类的回归预测问题，通常使用的结合策略是平均法，也就是说，对于若干个弱学习器的输出进行平均得到最终的预测输出。</p><ul><li>最简单的平均是算术平均，也就是说最终预测是<br>$$H(x)=\dfrac{1}{T}\sum_1^Th_i(x)$$</li><li>如果每个个体学习器有一个权重$w$，则最终预测是<br>$$H(x)=\sum_{i=1}^Tw_ih_i(x)$$</li><li>其中$w_i$是个体学习器$h_i$的权重，通常有<br>$$w_i≥0,\sum_{i=1}^Tw_i=1$$</li></ul><h4 id="投票法"><a href="#投票法" class="headerlink" title="投票法"></a>投票法</h4><p>对于分类问题的预测，我们通常使用的是投票法。假设我们的预测类别是${c_1,c_2,…c_K}$,对于任意一个预测样本$x$，我们的$T$个弱学习器的预测结果分别是$(h_1(x),h_2(x)…h_T(x))$。</p><ul><li>最简单的投票法是 <strong>相对多数投票法</strong>，也就是我们常说的少数服从多数，也就是$T$个弱学习器的对样本$x$的预测结果中，数量最多的类别$c_i$为最终的分类类别。如果不止一个类别获得最高票，则随机选择一个做最终类别。</li><li>稍微复杂的投票法是 <strong>绝对多数投票法</strong>，也就是我们常说的要票过半数。在相对多数投票法的基础上，不光要求获得最高票，还要求票过半数。否则会拒绝预测。</li><li>更加复杂的是 <strong>加权投票法</strong>，和加权平均法一样，每个弱学习器的分类票数要乘以一个权重，最终将各个类别的加权票数求和，最大的值对应的类别为最终类别。</li></ul><h4 id="学习法"><a href="#学习法" class="headerlink" title="学习法"></a>学习法</h4><p>上两节的方法都是对弱学习器的结果做平均或者投票，相对比较简单，但是可能学习误差较大，于是就有了 <strong>学习法</strong> 这种方法，对于学习法，代表方法是 <strong>stacking</strong>，当使用stacking的结合策略时， 我们不是对弱学习器的结果做简单的逻辑处理，而是再加上一层学习器，也就是说，我们将训练集弱学习器的学习结果作为输入，将训练集的输出作为输出，重新训练一个学习器来得到最终结果。<br>在这种情况下，我们将弱学习器称为 <strong>初级学习器</strong>，将用于结合的学习器称为 <strong>次级学习器</strong>。对于测试集，我们首先用初级学习器预测一次，得到次级学习器的输入样本，再用次级学习器预测一次，得到最终的预测结果。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;聚类clustering&quot;&gt;&lt;a href=&quot;#聚类clustering&quot; class=&quot;headerlink&quot; title=&quot;聚类clustering&quot;&gt;&lt;/a&gt;聚类clustering&lt;/h2&gt;&lt;h3 id=&quot;监督学习vs非监督学习&quot;&gt;&lt;a href=&quot;#监督
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="模式识别" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>模式识别总结5_decision tree</title>
    <link href="http://yoursite.com/2018/05/22/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%80%BB%E7%BB%935-decision-tree/"/>
    <id>http://yoursite.com/2018/05/22/模式识别总结5-decision-tree/</id>
    <published>2018-05-22T05:51:19.000Z</published>
    <updated>2018-09-22T07:36:53.585Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="模式识别" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>模式识别总结4_SVM</title>
    <link href="http://yoursite.com/2018/05/18/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%80%BB%E7%BB%934-SVM/"/>
    <id>http://yoursite.com/2018/05/18/模式识别总结4-SVM/</id>
    <published>2018-05-18T05:23:55.000Z</published>
    <updated>2018-09-22T07:36:53.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="了解SVM"><a href="#了解SVM" class="headerlink" title="了解SVM"></a>了解SVM</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>支持向量机(SVM)是90年代中期发展起来的基于统计学习理论的一种机器学习方法，通过寻求结构化风险最小来提高学习机泛化能力，实现经验风险和置信范围的最小化，从而达到在统计样本量较少的情况下，亦能获得良好统计规律的目的。<br>通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，即支持向量机的学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p><h3 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h3><p>一个线性分类器的学习目标便是要在$n$维的数据空间中找到一个 <strong>超平面hyper plane</strong> ，可以表示为$w^Tx+b=0$<br><strong>Logistic回归</strong> 目的是从特征学习出一个0/1分类模型，而这个模型是将特征的线性组合作为自变量，由于自变量的取值范围是负无穷到正无穷，因此使用Logistic(或者称作sigmoid)将自变量映射到(0,1)上，映射后的值被认为是$y=1$的概率。<br>$h_{\theta}=g(\theta^Tx)=\dfrac{1}{1+e^{-\theta^Tx}}=P(y=1|x;\theta)$<br><img src="/2018/05/18/模式识别总结4-SVM/pic1.png" alt=""><br>故：当$P(y=1|x;\theta)=h_{\theta}&gt;0.5$，则为$y=1$的类，反之属于$y=0$类<br>由$h_{\theta}&gt;0.5$得$\theta^Tx&gt;0$，即有<br>$$g(z)=\begin{cases}<br>1 &amp; z&gt;=0 \<br>-1 &amp; z<0 \end{cases}$$="" 而当$\theta^tx="">&gt;0$时，$h_{\theta}=1$，反之$h_{\theta}=0(-1)$。因此模型的训练目标即为让训练数据中$y=1$的特征$\theta^Tx&gt;&gt;0$，而$y=0$的特征$\theta^Tx&lt;&lt;0$</0></p><h3 id="函数间隔与几何间隔"><a href="#函数间隔与几何间隔" class="headerlink" title="函数间隔与几何间隔"></a>函数间隔与几何间隔</h3><p>在超平面$w^Tx+b=0$确定的情况下，$|w^T+b|$能够表示点$x$到距离超平面的远近，而通过观察$w^Tx+b$的符号与类标记$y$的符号是否一致可判断分类是否正确，故可用$y(w^Tx+b)$的正负值判定。由此引出<strong>functional margin</strong><br>$\widehat{\gamma}=y(w^Tx+b)=yf(x)$<br>超平面$(w,b)$关于训练数据集$T$的函数间隔：$\widehat{\gamma}=min\widehat{\gamma}_i\quad(i=1…n)$<br>但是函数间隔有限制，若成比例地改变$w,b$，那么函数间隔也会成比例地改变，但是超平面却没有改变。<br>故引出<strong>Geometrical margin</strong><br>$\widetilde{\gamma}=\dfrac{yf(x)}{||w||}=\dfrac{\widehat{\gamma}}{||w||}$<br><img src="/2018/05/18/模式识别总结4-SVM/pic2.png" alt=""></p><h3 id="最大间隔分类器"><a href="#最大间隔分类器" class="headerlink" title="最大间隔分类器"></a>最大间隔分类器</h3><p>对一个数据点进行分类，当超平面离数据点的“间隔”越大，分类的 <strong>确信度confidence</strong> 也越大。<br><img src="/2018/05/18/模式识别总结4-SVM/pic3.png" alt=""><br>由函数间隔和几何间隔的定义，可得：<br>$$\begin{cases}<br>y_i(w^Tx_i+b)=\widehat{\gamma}_i&gt;=\widehat{\gamma} &amp; i=1…n \<br>\widetilde{\gamma}=\dfrac{\widehat{\gamma}}{||w||} &amp; make\quad\widehat{\gamma}=1<br>\end{cases}$$<br>因此可得目标函数：<br>$$max\widetilde{\gamma}=max\dfrac{1}{||w||},\quad s.t.,y_i(w^T+x_i)&gt;=1,i=1…n$$<br><img src="/2018/05/18/模式识别总结4-SVM/pic4.png" alt=""><br>如图，中间的实线即为 <strong>最优超平面Optimal Hyper Plane</strong>，虚线上的点即为支持向量，满足$y(w^Tx+b)=1$</p><h2 id="深入SVM"><a href="#深入SVM" class="headerlink" title="深入SVM"></a>深入SVM</h2><h3 id="从原始问题到对偶问题的求解"><a href="#从原始问题到对偶问题的求解" class="headerlink" title="从原始问题到对偶问题的求解"></a>从原始问题到对偶问题的求解</h3><p>将目标函数变换，得到新的目标函数：<br>$$min\dfrac{||w||^2}{2},\quad s.t.,y_i(w^T+x_i)&gt;=1,i=1…n$$<br>此时的目标函数是二次的，约束条件是线性的，因此它是一个凸二次规划问题。<strong>目标最优，损失最小。</strong><br>由 <strong>拉格朗日对偶性</strong> 得到线性可分条件下支持向量机的对偶算法：<br><strong>第一步：定义拉格朗日函数</strong><br>$$\zeta(w,b,\alpha)=\dfrac{||w||^2}{2}-\sum_{i=1}^n\alpha_i(y_i(w^Tx_i+b)-1)$$<br>当所有的约束条件都满足时，存在：<br>$$\theta(w)=\underset{\alpha_i&gt;=0}{max}\zeta(w,b,\alpha)=\dfrac{||w||^2}{2}$$<br>因此，目标函数可变成：<br>$$\underset{w,b}{min}\dfrac{||w||^2}{2}=\underset{w,b}{min}\theta(w)=\underset{w,b}{min}\underset{\alpha_i&gt;=0}{max}\zeta(w,b,\alpha)=p^* $$</p><p><strong>第二步：对偶问题</strong><br>$$\underset{\alpha_i&gt;=0}{max}\underset{w,b}{min}\zeta(w,b,\alpha)=d^* $$</p><p><strong>转换成对偶问题的优点：</strong></p><ul><li>容易求解</li><li>自然地引入核函数，进而推广到非线性分类问题</li></ul><h3 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h3><p>一般地，一个最优化数学模型能够表示成下列标准形式:<br><img src="/2018/05/18/模式识别总结4-SVM/pic5.png" alt=""><br>其中，$f(x)$是需要最小化的函数，$h(x)$是等式约束，$g(x)$是不等式约束，$p$和$q$分别为等式约束和不等式约束的数量。<br>同时，得明白以下两点：</p><ul><li>凸优化的概念：$\mathcal{X} \subset \mathbb{R}^n$ 为一凸集， $f:\mathcal{X}\to \mathbb{R}$ 为一凸函数。凸优化就是要找出一点 $x^\ast \in \mathcal{X}$ ，使得每一 $x \in \mathcal{X}$ 满足 $f(x^\ast)\le f(x)$ 。</li><li>KKT条件的意义：它是一个非线性规划(Nonlinear Programming)问题能有最优化解法的必要和充分条件。</li></ul><p>而KKT条件就是指上面最优化数学模型的标准形式中的最小点 $x^\ast $ 必须满足下面的条件：<br><img src="/2018/05/18/模式识别总结4-SVM/pic6.png" alt=""><br>而SVM的目标函数的约束条件是满足KKT条件的，因此可以等价转换成对偶问题进行优化求解。</p><h3 id="对偶问题求解的三个步骤"><a href="#对偶问题求解的三个步骤" class="headerlink" title="对偶问题求解的三个步骤"></a>对偶问题求解的三个步骤</h3><p><strong>第一步：对$w,b$求偏导，得到$\underset{w,b}{min}\zeta(w,b,\alpha)$</strong><br><img src="/2018/05/18/模式识别总结4-SVM/pic7.png" alt=""><br><img src="/2018/05/18/模式识别总结4-SVM/pic8.png" alt=""><br>此时得到的式子中只有$\alpha$变量，故只要求出$\alpha$,就可以求出$w,b$</p><p><strong>第二步：求对$\alpha$ 的极大</strong><br><img src="/2018/05/18/模式识别总结4-SVM/pic9.png" alt=""><br>若求出了$\alpha$，根据$w=\sum_{i=1}^n\alpha_iy_ix_i$可以求出$w$；根据$b^\ast=-\dfrac{max_{i;y^{(i)}=-1}w^Tx^{(i)}+min_{i;y^{(i)}=1}w^Tx^{(i)}}{2}$可以得到$b$，最终可以得到分离超平面和分类决策函数。</p><p><strong>第三步：利用SMO算法求解对偶问题中的拉格朗日乘子$\alpha$</strong><br>将求极大公式转换成：<br><img src="/2018/05/18/模式识别总结4-SVM/pic10.png" alt=""><br><strong>思路：</strong><br>在要求的目标函数中，未知量只有$\alpha$，即在$\alpha_i={\alpha_1,…\alpha_n}$上求目标函数的最小值。为了求解这些乘子，每次从中任意抽取两个乘子$\alpha_1,\alpha_2$，然后固定其他乘子${\alpha_3,…\alpha_n}$，使得目标函数只有关于$\alpha_1,\alpha_2$的函数。这样不断地从一堆乘子中任意抽取两个求解，不断地迭代求解子问题，最终达到求解原问题的目的。<br><strong>选取乘子的条件：</strong><br><img src="/2018/05/18/模式识别总结4-SVM/pic11.png" alt=""></p><ul><li>情况一：表明$\alpha_i$是正常分类，在边界内部</li><li>情况二：表明$\alpha_i$是支持向量，在边界上</li><li>情况三：表明$\alpha_i$是在两条边界之间</li></ul><p>而不满足KKT条件，需要更新的乘子满足：</p><ul><li>情况一：$y_iu_i&lt;=1\quad but\quad\alpha_i&lt;C$</li><li>情况二：$y_iu_i&gt;=1\quad but\quad\alpha_i&gt;C$</li><li>情况三：$y_iu_i=1\quad but\quad\alpha_i=C\quad or\quad\alpha_i=0$</li></ul><p><strong>优化$\alpha$乘子的原理解析：</strong><br>由$\sum_{i=1}^ny_i\alpha_i=0$可得约束条件：<br>$$\alpha_1^{new}y_1+\alpha_2^{new}y_2=\alpha_1^{old}y_1+\alpha_2^{old}y_2=-\sum_{i=3}^ny_i\alpha_i=\zeta$$<br>再综合$0&lt;=\alpha_i&lt;=C$，可得优化的$\alpha$的取值范围：<br><img src="/2018/05/18/模式识别总结4-SVM/pic12.png" alt=""><br><img src="/2018/05/18/模式识别总结4-SVM/pic13.png" alt=""></p><p>由于选取两个乘子，其他固定，故可得目标函数为：<br>$$\underset{\alpha_1,\alpha_2}{min}W(\alpha_1,\alpha_2)=m\alpha_1^2+n\alpha_2^2+k\alpha_1\alpha_2+q\alpha_1+p\alpha_2$$<br>代入转换求导，然后在范围内截断取值更新$\alpha$值<br><img src="/2018/05/18/模式识别总结4-SVM/pic15.png" alt=""><br><img src="/2018/05/18/模式识别总结4-SVM/pic14.png" alt=""></p><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;了解SVM&quot;&gt;&lt;a href=&quot;#了解SVM&quot; class=&quot;headerlink&quot; title=&quot;了解SVM&quot;&gt;&lt;/a&gt;了解SVM&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="模式识别" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>企业软件开发_EJB3.0、性能调优、web服务器</title>
    <link href="http://yoursite.com/2018/05/15/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-EJB3-0%E3%80%81%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E3%80%81web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2018/05/15/企业软件开发-EJB3-0、性能调优、web服务器/</id>
    <published>2018-05-15T11:35:05.000Z</published>
    <updated>2018-09-22T07:36:53.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="企业软件系统概述"><a href="#企业软件系统概述" class="headerlink" title="企业软件系统概述"></a>企业软件系统概述</h2><p>计算程序的基本组成:</p><ul><li>表示层</li><li>业务逻辑层</li><li>数据访问层</li></ul><p>大型互联网应用系统具有的特点：</p><ul><li>高并发、大流量</li><li>高可用</li><li>海量数量</li><li>用户分布广泛、网络情况复杂</li><li>安全环境恶劣</li><li>需求快速变更，发布频繁</li></ul><p>网站访问的二八定律：</p><ul><li>80%的访问集中在20%的数据上</li><li>20%数据集中在内存缓存</li></ul><h2 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h2><ul><li>Microsoft IIS:仅支持window,用于.net</li><li>Tomcat<ul><li>轻量级</li><li>开源</li><li>被使用最广泛</li><li>主流jsp/servlet容器，但需要配合weblogic、Jboss等容器使用EJB</li></ul></li><li>Apache<ul><li>使用排名第一</li><li>以进程为基础的结构</li><li>与Tomcat的区别<ul><li>Apache支持静态页，Tomcat支持动态的</li><li>Apache是一个web服务器环境程序，可作为web服务器使用，tomcat 是应用(java)服务器，是Apache的扩展，又独立于Apache</li><li>Apache侧重http server，Tomcat侧重servlet引擎</li></ul></li></ul></li><li>Lighttpd<ul><li>德国的</li><li>OpenSource轻量级</li><li>单线程，针对大量持续连接</li></ul></li><li>Nginx<ul><li>俄罗斯的</li><li>以事件驱动方式编写的</li><li>反向代理、负载平web服务器、http反向代理和邮件代理服务器</li><li>全球使用量第三</li><li>特点：<ul><li>高并发连接</li><li>内存消耗少</li><li>配置文件非常简单</li><li>成本低廉</li></ul></li></ul></li><li>Tengine</li></ul><h2 id="Websphere-MQ"><a href="#Websphere-MQ" class="headerlink" title="Websphere MQ"></a>Websphere MQ</h2><p>WebSphere MQ 为用户和应用开发人员提供了一种直接，简单，成熟的手段以实现应用系统在不同操作系统平台之间稳定可靠地传递，交换重要的数据和信息，确保消息不丢失/不复传。</p><p>MQ的传输协议是TCP，以安全性为主，支持文件，不支持文件目录的传输。<br>MQ的连接机制是通道、队列，传输方式是消息(消息描述符+用户数据)</p><p>消息分为</p><ul><li>请求消息</li><li>回复消息</li><li>报文消息</li><li>报告消息</li></ul><p>死信队列是存储无法发送到其正确目的地的消息的队列。</p><p>WebSphere MQ是唯一可保证信息一次性传输的中间件,确保对消息一次仅且一次(once-and-only-once)的传递，做到不丢失、不重传、次序不乱。</p><p>触发应用程序是指MQ能够在触发条件满足时，唤醒应用程序的执行，即应用程序不必总是在运行中的。<br>触发的对象：</p><ul><li>应用程序</li><li>通道</li></ul><h2 id="EJB3-0"><a href="#EJB3-0" class="headerlink" title="EJB3.0"></a>EJB3.0</h2><p>相比EJB2.0：</p><ul><li>使用java元数据注释</li><li>简化访问EJB环境的API</li><li>不需要home接口、对象接口以及组件接口</li><li>提供另外两种获取资源的方式<ul><li>在EJB2.0:通过InitialContext的lookup方法来获取资源;</li><li>在EJB3.0:通过EJBContext的lookup方法;</li><li>通过依赖注入方式;</li></ul></li><li>消除了持久实体需要的所有接口</li></ul><h2 id="EJB性能优化"><a href="#EJB性能优化" class="headerlink" title="EJB性能优化"></a>EJB性能优化</h2><h3 id="无状态会话bean调优"><a href="#无状态会话bean调优" class="headerlink" title="无状态会话bean调优"></a>无状态会话bean调优</h3><ul><li>调整实例池大小</li><li>设置实例池空闲延时</li><li>有效缓存资源</li></ul><h3 id="有状态会话bean调优"><a href="#有状态会话bean调优" class="headerlink" title="有状态会话bean调优"></a>有状态会话bean调优</h3><ul><li>调整缓存大小</li><li>有效控制序列化</li></ul><h3 id="实体bean调优"><a href="#实体bean调优" class="headerlink" title="实体bean调优"></a>实体bean调优</h3><ul><li>使用CMP 2.x或JPA。</li><li>提供本地接口；</li><li>对实例池大小进行调整；</li><li>调整缓存大小；</li><li>选择合适的事务语义和事务隔离级别；</li><li>在获得大量数据时，建议使用JDBC；</li><li>在BMP中优化JDBC操作；</li><li>选择合适的RDBMS驱动；</li><li>批量更新或获取。</li></ul><h3 id="MDB调优"><a href="#MDB调优" class="headerlink" title="MDB调优"></a>MDB调优</h3><ul><li>调整实例池大小</li><li>JMS相关调整</li></ul><h3 id="web服务器调优"><a href="#web服务器调优" class="headerlink" title="web服务器调优"></a>web服务器调优</h3><ul><li>如果Web应用是无状态的，则关闭HTTP会话支持这一特性。&lt;%page session=“false”%&gt;</li><li>不要在session中存储大量的对象，及时释放会话。</li><li>针对不同HTTP keek-alive设置，设置相应的优化值。</li><li>将JSP重新编译选项关闭；</li><li>使用Web服务提供的JSP、Servlet缓存技术；</li><li>不要使用Servlet规范已经丢弃的单线程模型。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;企业软件系统概述&quot;&gt;&lt;a href=&quot;#企业软件系统概述&quot; class=&quot;headerlink&quot; title=&quot;企业软件系统概述&quot;&gt;&lt;/a&gt;企业软件系统概述&lt;/h2&gt;&lt;p&gt;计算程序的基本组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示层&lt;/li&gt;
&lt;li&gt;业务逻辑层&lt;/li
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="企业软件开发" scheme="http://yoursite.com/tags/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>企业软件开发_J2EE</title>
    <link href="http://yoursite.com/2018/05/14/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-J2EE/"/>
    <id>http://yoursite.com/2018/05/14/企业软件开发-J2EE/</id>
    <published>2018-05-14T08:49:01.000Z</published>
    <updated>2018-09-22T07:36:53.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h2><ul><li>J2ME:嵌入式设备及消费类电器</li><li>J2SE:普通PC应用</li><li>J2EE：企业网应用<ul><li>平台无关性</li><li>支持异构环境</li><li>可伸缩性强</li><li>保留现有系统</li><li>稳定的可用性</li><li>高效开发：开发人员只需集中精力处理商业逻辑</li><li>多层架构体系</li></ul></li></ul><h2 id="J2EE规范概述"><a href="#J2EE规范概述" class="headerlink" title="J2EE规范概述"></a>J2EE规范概述</h2><ul><li>Sun公司为企业计算推出的企业级Java平台，工业标准、开放路线</li><li>用于开发、部署和管理N层结构、面向Web的，以服务器为中心的企业级应用</li><li>简化企业解决方案的开发、部署和管理相关的复杂问题</li><li>以核心Java平台和Java 2平台的标准版为技术基础</li><li>J2EE应用编程模型：商业逻辑、表示逻辑</li><li>J2EE平台本质上是一个分布式的服务器应用程序设计环境<ul><li>为应用提供运行时的基础框架环境</li><li>一套用来创建应用的Java扩展编程接口API</li></ul></li></ul><h2 id="J2EE体系结构"><a href="#J2EE体系结构" class="headerlink" title="J2EE体系结构"></a>J2EE体系结构</h2><p>J2EE使用多层的分布式应用模型，应用逻辑按功能划分为组件，各个应用组件根据他们所在的层分布在不同的机器上。事实上，sun设计J2EE的初衷正是为了解决两层模式(client/server)的弊端，在传统模式中，客户端担当了过多的角色而显得臃肿，在这种模式中，第一次部署的时候比较容易，但难于升级或改进，可伸展性也不理想，而且经常基于某种专有的协议，通常是某种数据库协议。它使得重用业务逻辑和界面逻辑非常困难。现在J2EE的多层企业级应用模型将两层化模型中的不同层面切分成许多层。一个多层化应用能够为不同的每种服务提供一个独立的层，以下是J2EE典型的四层结构:</p><ul><li>运行在客户端机器上的客户层组件</li><li>运行在J2EE服务器上的Web层组件</li><li>运行在J2EE服务器上的业务逻辑层组件</li><li>运行在EIS服务器上的企业信息系统(Enterprise information system)层软件</li></ul><p><img src="/2018/05/14/企业软件开发-J2EE/pic1.png" alt=""></p><h3 id="J2EE应用程序组件"><a href="#J2EE应用程序组件" class="headerlink" title="J2EE应用程序组件"></a>J2EE应用程序组件</h3><p>J2EE应用程序是由组件构成的.J2EE组件是具有独立功能的软件单元，它们通过相关的类和文件组装成J2EE应用程序，并与其他组件交互。J2EE说明书中定义了以下的J2EE组件:</p><ul><li>应用客户端程序和applets是客户层组件.</li><li>Java Servlet和JavaServer Pages(JSP)是web层组件.</li><li>Enterprise JavaBeans(EJB)是业务层组件.</li></ul><h4 id="客户层组件"><a href="#客户层组件" class="headerlink" title="客户层组件"></a>客户层组件</h4><p>J2EE应用程序可以是基于web方式的,也可以是基于传统方式的.</p><h4 id="web-层组件"><a href="#web-层组件" class="headerlink" title="web 层组件"></a>web 层组件</h4><p>J2EE web层组件可以是JSP 页面或Servlets.按照J2EE规范，静态的HTML页面和Applets不算是web层组件。<br>正如下图所示的客户层那样，web层可能包含某些 JavaBean 对象来处理用户输入，并把输入发送给运行在业务层上的enterprise bean 来进行处理。<br><img src="/2018/05/14/企业软件开发-J2EE/pic2.png" alt=""></p><h4 id="业务层组件"><a href="#业务层组件" class="headerlink" title="业务层组件"></a>业务层组件</h4><p>业务层代码的逻辑用来满足银行，零售，金融等特殊商务领域的需要,由运行在业务层上的enterprise bean 进行处理. 下图表明了一个enterprise bean 是如何从客户端程序接收数据，进行处理(如果必要的话), 并发送到EIS 层储存的，这个过程也可以逆向进行。<br><img src="/2018/05/14/企业软件开发-J2EE/pic3.png" alt=""><br>有三种企业级的bean: 会话(session) beans, 实体(entity) beans, 和消息驱动(message-driven)beans. 会话bean 表示与客户端程序的临时交互. 当客户端程序执行完后, 会话bean 和相关数据就会消失. 相反, 实体bean 表示数据库的表中一行永久的记录. 当客户端程序中止或服务器关闭时, 就会有潜在的服务保证实体bean 的数据得以保存.消息驱动 bean 结合了会话bean 和 JMS(java消息服务,java message service)的消息监听器的特性, 允许一个业务层组件异步接收JMS 消息.</p><h3 id="企业信息系统层"><a href="#企业信息系统层" class="headerlink" title="企业信息系统层"></a>企业信息系统层</h3><p>企业信息系统层处理企业信息系统软件包括企业基础建设系统例如企业资源计划 (ERP), 大型机事务处理, 数据库系统,和其它的遗留信息系统. 例如，J2EE 应用组件可能为了数据库连接需要访问企业信息系统</p><h2 id="J2EE的结构"><a href="#J2EE的结构" class="headerlink" title="J2EE的结构"></a>J2EE的结构</h2><p>这种基于组件，具有平台无关性的J2EE结构使得J2EE程序的编写十分简单，因为业务逻辑被封装成可复用的组件，并且J2EE 服务器以容器的形式为所有的组件类型提供后台服务. 因为你不用自己开发这种服务, 所以你可以集中精力解决手头的业务问题.</p><h3 id="容器和服务"><a href="#容器和服务" class="headerlink" title="容器和服务"></a>容器和服务</h3><p>容器设置定制了J2EE服务器所提供得内在支持，包括安全，事务管理，JNDI(Java Naming and Directory Interface)寻址,远程连接等服务，以下列出最重要的几种服务：</p><ul><li><strong>J2EE安全(Security)</strong> 模型可以让你配置 web 组件或enterprise bean ,这样只有被授权的用户才能访问系统资源. 每一客户属于一个特别的角色，而每个角色只允许激活特定的方法。你应在enterprise bean的布置描述中声明角色和可被激活的方法。由于这种声明性的方法，你不必编写加强安全性的规则。</li><li><strong>J2EE事务管理(Transaction Management)</strong> 模型让你指定组成一个事务中所有方法间的关系，这样一个事务中的所有方法被当成一个单一的单元. 当客户端激活一个enterprise bean中的方法，容器介入一管理事务。因有容器管理事务，在enterprise bean中不必对事务的边界进行编码。要求控制分布式事务的代码会非常复杂。你只需在布置描述文件中声明enterprise bean的事务属性，而不用编写并调试复杂的代码。容器将读此文件并为你处理此enterprise bean的事务。</li><li><strong>JNDI寻址(JNDI Lookup)</strong> 服务向企业内的多重名字和目录服务提供了一个统一的接口,这样应用程序组件可以访问名字和目录服务.</li><li><strong>J2EE远程连接(Remote Client Connectivity)</strong> 模型管理客户端和enterprise bean间的低层交互. 当一个enterprise bean创建后, 一个客户端可以调用它的方法就象它和客户端位于同一虚拟机上一样.</li><li><strong>生存周期管理(Life Cycle Management)</strong> 模型管理enterprise bean的创建和移除,一个enterprise bean在其生存周期中将会历经几种状态。容器创建enterprise bean，并在可用实例池与活动状态中移动他，而最终将其从容器中移除。即使可以调用enterprise bean的create及remove方法，容器也将会在后台执行这些任务。</li><li><strong>数据库连接池(Database Connection Pooling)</strong> 模型是一个有价值的资源。获取数据库连接是一项耗时的工作，而且连接数非常有限。容器通过管理连接池来缓和这些问题。enterprise bean可从池中迅速获取连接。在bean释放连接之可为其他bean使用。</li></ul><h3 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h3><p>J2EE应用组件可以安装部署到以下几种容器中去:</p><ul><li><strong>EJB容器</strong> 管理所有J2EE应用程序中企业级bean的执行. enterprise bean和它们的容器运行在J2EE服务器上.</li><li><strong>Web容器</strong> 管理所有J2EE应用程序中JSP页面和Servlet组件的执行. Web组件和它们的容器运行在J2EE服务器上.</li><li><strong>应用程序客户端容器</strong> 管理所有J2EE应用程序中应用程序客户端组件的执行. 应用程序客户端和它们的容器运行在J2EE 服务器上.</li><li><strong>Applet容器</strong> 是运行在客户端机器上的web浏览器和Java插件的结合.</li></ul><p><img src="/2018/05/14/企业软件开发-J2EE/pic4.png" alt=""></p><h2 id="J2EE核心技术"><a href="#J2EE核心技术" class="headerlink" title="J2EE核心技术"></a>J2EE核心技术</h2><p>J2EE平台由一整套服务(Services)、应用程序接口(APIs)和协议构成，它对开发基于Web的多层应用提供了功能支持，下面对J2EE中的13种技术规范进行简单的描述(限于篇幅，这里只能进行简单的描述):</p><ul><li><strong>JDBC(Java Database Connectivity):</strong> JDBC API为访问不同的数据库提供了一种统一的途径，象ODBC一样，JDBC对开发者屏蔽了一些细节问题，另外，JDCB对数据库的访问也具有平台无关性。</li><li><strong>JNDI(Java Name and Directory Interface):</strong> JNDI API被用于执行名字和目录服务。它提供了一致的模型来存取和操作企业级的资源如DNS和LDAP，本地文件系统，或应用服务器中的对象。</li><li><strong>EJB(Enterprise JavaBean):</strong> J2EE技术之所以赢得某体广泛重视的原因之一就是EJB。它们提供了一个框架来开发和实施分布式商务逻辑，由此很显著地简化了具有可伸缩性和高度复杂的企业级应用的开发。EJB规范定义了EJB组件在何时如何与它们的容器进行交互作用。容器负责提供公用的服务，例如目录服务、事务管理、安全性、资源缓冲池以及容错性。但这里值得注意的是，EJB并不是实现J2EE的唯一途径。正是由于J2EE的开放性，使得有的厂商能够以一种和EJB平行的方式来达到同样的目的。</li><li><strong>RMI(Remote Method Invoke):</strong> 正如其名字所表示的那样，RMI协议调用远程对象上方法。它使用了序列化方式在客户端和服务器端传递数据。RMI是一种被EJB使用的更底层的协议。</li><li><strong>Java IDL/CORBA:</strong> 在Java IDL的支持下，开发人员可以将Java和CORBA((Common Object Request Broker Architecture,公共对象请求代理体系结构,通用对象请求代理体系结构)是由OMG组织制订的一种标准的面向对象应用程 序体系规范)集成在一起。他们可以创建Java对象并使之可在CORBA ORB中展开, 或者他们还可以创建Java类并作为和其它ORB一起展开的CORBA对象的客户。后一种方法提供了另外一种途径，通过它Java可以被用于将你的新的应用和旧的系统相集成。</li></ul><hr><ul><li><strong>JSP(Java Server Pages):</strong> JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端所请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。</li></ul><p><strong>1、JSP概述</strong></p><ul><li>在HTML语言中混合Java程序代码，由服务器端Java语言引擎解释执行</li><li>HTML负责描述信息显示格式，JSP负责描述处理逻辑</li><li>JSP代码执行需要JSP引擎，如Tomcat和Apache</li><li>JSP开发的典型方式<ul><li>直接使用：显示简单的动态效果</li><li>JSP + JavaBeans：需要与数据库连接，管理诸如帐号之类的信息</li><li>JSP + JavaBeans + Servlet：将事务逻辑与表现逻辑分开，JSP负责表现逻辑的处理和输出，Servlet专注于处理Web的关键业务逻辑</li></ul></li></ul><p><strong>2、JSP引擎的工作原理</strong></p><ul><li>将JSP页面翻译成一个Servlet(Java文件)</li><li>JSP引擎调用Java编译器对这个Servlet进行编译，得到可执行的class文件</li><li>JSP引擎调用java虚拟机来解释执行class文件，生成向客户端发送的应答，然后发送给客户<br>  <strong>上述步骤在JSP页面第一次被访问时才会执行，以后会因为类文件已经生成而提高效率</strong><br><img src="/2018/05/14/企业软件开发-J2EE/pic5.png" alt=""></li></ul><p><strong>3、JSP和ASP的比较</strong></p><ul><li>相似之处<ul><li>均是运行于服务器，都属于动态网页生成技术</li><li>都使用HTML来决定网页的版面，在HTML 代码中混合某种程序代码，由语言引擎解释执行程序代码</li><li>HTML负责描述显示样式，程序代码描述处理逻辑</li></ul></li><li>区别<ul><li>JSP基于JavaServlet及整个J2EE体系，支持跨平台</li><li>ASP由微软推出，只能在Windows平台上运行</li><li>ASP下的编程语言是 VBScript 之类的脚本语言，而JSP 使用的是Java</li><li>ASP与JSP还有一个更为本质的区别：两种语言引擎用完全不同的方式处理页面中嵌入的程序代码<ul><li>在ASP下，VBScript代码被ASP引擎解释执行</li><li>在JSP下，代码被编译成Servlet并由Java虚拟机执行，这种编译操作仅在对JSP页面的第一次请求时发生</li></ul></li></ul></li></ul><hr><ul><li><strong>Java Servlet:</strong> Servlet是一种小型的Java程序，它扩展了Web服务器的功能。作为一种服务器端的应用，当被请求时开始执行，这和CGI Perl脚本很相似。Servlet提供的功能大多与JSP类似，不过实现的方式不同。JSP通常是大多数HTML代码中嵌入少量的Java代码，而servlets全部由Java写成并且生成HTML。</li></ul><p><strong>1、Servlet概述</strong><br><strong>Servlets＝Server ＋Applet</strong></p><ul><li>运行于Web服务器端的Java小程序，用来扩展Web服务器功能</li><li>一种扩展Web服务器功能的技术，且由于用Java编写，所以能够访问整个Java API库，包括用于访问企业数据库的JDBC API</li><li>用特定的Java解决方案替代了其它的Web服Servlets务器方编程模式(如：CGI，ISAPI等)，因而继承了Java的所有特性(跨平台、多线程、OO)</li><li>用来编写Servlets的Servlet API对于服务器环境和协议没有任何特殊的要求，所以Servlets具有很强的可移植性，也不像利用CGI程序等其它方式那样具有性能局限</li><li>Servlets也同样使用HTTP协议与客户端进行通讯，所以有时也称Sevlets为“HTTP Servlets”</li></ul><p><strong>2、java servlet 和JSP的比较</strong></p><ul><li>相似之处<ul><li>均基于Java技术，都继承了Java的所有特性，且都可以使用Java API</li><li>工作方式相似：JSP代码先被JSP容器转换为Servlet代码再编译为类</li><li>两者在J2EE体系结构中的工作层次相同，都负责与客户端的连接</li></ul></li><li>区别<ul><li>编程方式不同：Servlets是一些运行于Web服务器端的Java小程序；而JSP是脚本，编写起来更简单容易</li><li>应用目的不同：Servlet主要用于从客户端接收请求信息，而JSP主要负责将服务器端信息传送到客户端</li><li>JSP真正意义：可将界面设计和业务逻辑设计分离</li></ul></li></ul><hr><ul><li><strong>XML(Extensible Markup Language):</strong> XML是一种可以用来定义其它标记语言的语言。它被用来在不同的商务过程中共享数据。XML的发展和Java是相互独立的，但是，它和Java具有的相同目标正是平台独立性。通过将Java和XML的组合，您可以得到一个完美的具有平台独立性的解决方案。</li><li><strong>JMS(Java Message Service):</strong> MS是用于和面向消息的中间件相互通信的应用程序接口(API)。它既支持点对点的域，有支持发布/订阅(publish/subscribe)类型的域，并且提供对下列类型的支持：经认可的消息传递,事务型消息的传递，一致性消息和具有持久性的订阅者支持。JMS还提供了另一种方式来对您的应用与旧的后台系统相集成。</li><li><strong>JTA(Java Transaction Architecture):</strong> JTA定义了一种标准的API，应用系统由此可以访问各种事务监控。</li><li><strong>JTS(Java Transaction Service):</strong> JTS是CORBA OTS事务监控的基本的实现。JTS规定了事务管理器的实现方式。该事务管理器是在高层支持Java Transaction API (JTA)规范，并且在较底层实现OMG OTS specification的Java映像。JTS事务管理器为应用服务器、资源管理器、独立的应用以及通信资源管理器提供了事务服务。</li><li><strong>JavaMail:</strong> JavaMail是用于存取邮件服务器的API，它提供了一套邮件服务器的抽象类。不仅支持SMTP服务器，也支持IMAP服务器。</li><li><strong>JAF(JavaBeans Activation Framework):</strong> JavaMail利用JAF来处理MIME编码的邮件附件。MIME的字节流可以被转换成Java对象，或者转换自Java对象。大多数应用都可以不需要直接使用JAF。</li></ul><hr><ul><li><strong>JavaBean</strong></li></ul><p><strong>1、概述</strong></p><ul><li>JavaBean是基于Java的组件模型，类似于Microsoft的COM组件<ul><li>JavaBean通过Java虚拟机执行</li><li>可以无限扩充Java程序的功能，通过组合快速生成新的应用程序</li><li>JavaBean传统的应用在于可视化的领域，如AWT下的应用<ul><li>自从JSP诞生后，JavaBean更多的应用在了非可视化领域，在服务器端应用方面表现出来了越来越强的生命力</li></ul></li></ul></li><li>JavaBean区别于Java类的特点<ul><li>有公共无参数的构造函数</li><li>每一个属性都要有set，get方法</li><li>实现Serializable接口</li></ul></li></ul><p><strong>2、JavaBean的组成</strong></p><ul><li>属性<ul><li>在设计Bean时可以改变的外观和行为特征</li><li>开发工具通过对Bean进行内省来获知其属性，进而发布其属性</li></ul></li><li>方法<ul><li>JavaBean中的方法就是通常的Java方法，它可以从其他组件或在脚本环境中调用</li><li>默认情况下，所有bean的公有方法都可以被外部调用，但bean一般只会引出其公有方法的一个子集</li></ul></li><li>事件<ul><li>Bean与其他组件交流信息的主要方式是发送和接收事件</li></ul></li></ul><hr><h2 id="J2EE安全机制"><a href="#J2EE安全机制" class="headerlink" title="J2EE安全机制"></a>J2EE安全机制</h2><p><strong>1、J2EE的安全概念</strong></p><ul><li>主体(Principal)<br>被在企业安全服务验证了的实体，常用主体名(用户登陆名)作为他的标识，通过与主体相关的验证数据(登陆密码)进行验证</li><li>安全策略域(Security Policy Domain)<br>从安全策略角度划分的逻辑区域，同一区域内的主体采用相同的安全策略</li><li>安全技术域(Security Technology Domain)<br>在一个安全技术域中使用同样的安全机制来执行安全策略，一个安全技术域可包括多个安全策略域</li><li>安全属性(Security Attributes)<br>每个主体都有一系列与之相关的安全属性，用于访问被保护的资源，检查用户身份和完成其他安全相关功能</li><li>凭证(Credential)<br>包含或引用为J2EE系统验证一个主体的安全属性。若通过，将获得一个包含安全属性的凭证</li></ul><p><strong>2、授权</strong><br>基于用户权限或用户类别管理对受保护系统资源的访问</p><ul><li>代码授权(Code Authorization)<ul><li>通过Java 2安全模型来限制特定J2SE的类和方法的执行，以保护系统安全</li></ul></li><li>调用者授权(Caller Authorization)<ul><li>由应用程序装配者或应用程序部署者分配的安全角色(具有相同安全属性的逻辑组)</li></ul></li><li>安全角色引用<ul><li>由应用程序提供者用来引用安全角色的标识</li></ul></li><li>用户和组<ul><li>实际环境中的用户及用户的集合</li></ul></li><li>访问控制<ul><li>确保安全角色只能访问已授予它安全权限的授权对象(EJB的远程方法、Web资源等)，访问控制在应用程序描述文件中与安全角色关联</li></ul></li><li>映射<ul><li>将实际环境中的用户和角色与安全角色联系起来，使实际用户具有对企业资源访问的适当权限</li></ul></li><li>被传播的调用者身份标识(Propagated Caller Identity)<ul><li>用传播调用者标识作为web组件和ejb组件调用者的标识来进行验证 ,要注意的是在调用链中传递的是用户的标识，而不是凭证(credentials)</li></ul></li></ul><p><strong>3、验证</strong><br>用户或组件调用者向系统证明身份的过程</p><ul><li>Web客户端的验证<ul><li>HTTP基本验证：利用用户名和密码作为验证信息</li><li>基于表单的验证：可根据用户需求定制登陆和出错界面</li><li>基于客户端证书的验证：通过HTTPS(HTTP over SSL)来保证验证的安全性</li></ul></li><li>Application客户端的验证(微信网页版怎么验证)<ul><li>单点登陆SSO<ul><li>在特定的逻辑安全区域中，只需要登陆一次即可访问不同应用系统中的授权资源</li><li>J2EE通过凭证来实现单点登陆</li></ul></li><li>惰性验证：用户访问受保护资源时才执行验证过程</li></ul></li></ul><p><strong>4、SSO的主要实现方式</strong></p><ul><li>共享cookies<br>基于共享同域的cookie是Web刚开始阶段时使用的一种方式，它利用浏览同域名之间自动传递cookies机制，实现两个域名之间系统令牌传递问题；另外，关于跨域问题，虽然cookies本身不跨域，但可以利用它实现跨域的SSO 。如：代理、暴露SSO令牌值等。<br><strong>缺点：不灵活而且有不少安全隐患，已经被抛弃。</strong></li></ul><p><strong>cookies原理</strong><br>当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们可以从： [系统盘]:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。有了Cookie这样的技术实现，服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。</p><hr><ul><li>Broker-based(基于经纪人)<br>这种技术的特点就是，有一个集中的认证和用户帐号管理的服务器。经纪人给被用于进一步请求的电子身份存取。中央数据库的使用减少了管理的代价，并为认证提供一个公共和独立的 “第三方”。例如Kerberos、Sesame、IBM KryptoKnight(凭证库思想)等。Kerberos是由麻省理工大学发明的安全认证服务，已经被UNIX和Windows作为默认的安全认证服务集成进操作系统。</li><li>Agent-based(基于代理人)<br>在这种解决方案中，有一个自动地为不同的应用程序认证用户身份的代理程序。这个代理程序需要设计有不同的功能。比如，它可以使用口令表或加密密钥来自动地将认证的负担从用户移开。代理人被放在服务器上面，在服务器的认证系统和客户端认证方法之间充当一个“翻译”。例如SSH等。</li><li>Token-based<br>例如SecureID,WebID，现在被广泛使用的口令认证，比如FTP、邮件服务器的登录认证，这是一种简单易用的方式，实现一个口令在多种应用当中使用。</li><li>基于网关</li><li>基于SAML<br>SAML(Security Assertion Markup Language，安全断言标记语言)的出现大大简化了SSO，并被OASIS批准为SSO的执行标准。开源组织OpenSAML实现了SAML规范。</li></ul><h2 id="J2EE平台的角色分类"><a href="#J2EE平台的角色分类" class="headerlink" title="J2EE平台的角色分类"></a>J2EE平台的角色分类</h2><p><strong>角色分类</strong></p><ul><li>J2EE产品提供者<ul><li>实现提供了容器、API及其他特征的J2EE产品</li></ul></li><li>应用组件提供者<ul><li>开发应用程序构建块(如HTML文档、EJBs、JSPs等)</li><li>在许多场合该角色可进一步细分</li></ul></li><li>应用组装者<ul><li>使用由组件提供者开发的组件，并将他们组装成一个完整的J2EE应用</li></ul></li><li>部署者<ul><li>部署、配置和运行EJB及Web应用</li></ul></li><li>系统管理员<ul><li>配置和管理架构环境</li></ul></li><li>工具提供者<ul><li>提供应用组件开发和打包工具</li></ul></li></ul><p><strong>J2EE部署</strong></p><ul><li>JAR—Java Archive<ul><li>Java类文件</li><li>EJBs</li></ul></li><li>WAR—Web Archive<ul><li>Servlets</li><li>JSPs</li></ul></li><li>EAR—Enterprise Archive<ul><li>包含构成整个应用的所有其他JARs和WARs</li></ul></li><li>配置描述符<ul><li>XML</li><li>EJB JARs，WAR及EARs均需要</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;J2EE&quot;&gt;&lt;a href=&quot;#J2EE&quot; class=&quot;headerlink&quot; title=&quot;J2EE&quot;&gt;&lt;/a&gt;J2EE&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;J2ME:嵌入式设备及消费类电器&lt;/li&gt;
&lt;li&gt;J2SE:普通PC应用&lt;/li&gt;
&lt;li&gt;J2EE：企业网应
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="企业软件开发" scheme="http://yoursite.com/tags/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>企业软件开发_大型系统设计关键技术</title>
    <link href="http://yoursite.com/2018/05/12/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/05/12/企业软件开发-大型系统设计关键技术/</id>
    <published>2018-05-12T11:54:20.000Z</published>
    <updated>2018-09-22T07:36:53.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大型网站架构的目标与挑战"><a href="#大型网站架构的目标与挑战" class="headerlink" title="大型网站架构的目标与挑战"></a>大型网站架构的目标与挑战</h2><p><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic1.png" alt=""></p><h2 id="网站架构演变及其技术脉络"><a href="#网站架构演变及其技术脉络" class="headerlink" title="网站架构演变及其技术脉络"></a>网站架构演变及其技术脉络</h2><h3 id="硬件方面"><a href="#硬件方面" class="headerlink" title="硬件方面"></a>硬件方面</h3><ul><li><strong>处理能力的提升：</strong> 部署多颗CPU，选择多核心、具备更高运算频率、更大高速缓存的CPU；<br>处理能力的提升最直接的反应在于Web请求的处理效率和应用程序的执行效率。</li><li><strong>内存带宽与容量：</strong><br>内存带宽与容量的提升最直接的反应在于应对数据库大量的数据交换。</li><li><strong>磁盘搜索与I/O能力：</strong> 选择更高的转速、更大的硬盘缓存、组件磁盘阵列RAID<br>磁盘搜索与I/O能力的提升最直接反应在于数据库大量的查询和读写以及文件的读写。</li><li><strong>网络带宽的提升：</strong> 更大带宽、多线路接入、独享带宽</li></ul><h3 id="部署方面"><a href="#部署方面" class="headerlink" title="部署方面"></a>部署方面</h3><h4 id="1-web动静态资源分离及其与DB物理分离"><a href="#1-web动静态资源分离及其与DB物理分离" class="headerlink" title="1.web动静态资源分离及其与DB物理分离"></a>1.web动静态资源分离及其与DB物理分离</h4><p><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic2.png" alt=""></p><ul><li>优点：“简单”、安全性提高</li><li>缺点：存在单点，谈不上高可用性(high availability架构目标)</li><li>技术点：应用设计要保证可扩展(framework很重要Spring/Beetle)、Web Server动/静态资源分离、Web Server(Apache\Nginx\IIS\JBoss…)、Database Server(Mysql\Oracle\Redis…)</li></ul><p><strong>注意：</strong> 一般地，本文提到的物理服务器都是泛指pc级物理服务器；Web Server泛指HTTP服务器和应用服务器综合体对于一个试水性网站来说为了节约成本，Web Server和DB Server都放在同一台pc Server服务器上是常见的事情。当网站访问量增大，cpu处理能力是瓶颈的时候，通过把web Server和Db Server简单物理分开的，效果明显！</p><p>web动静态资源分离：</p><ul><li>img,doc,js,css等静态资源使用单独的Web HTTP Server处理请求</li><li>动态页面静态化处理</li></ul><p><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic3.png" alt=""></p><ul><li>效率最高、消耗最小的就是纯静态化的html页面，所以网站尽可能使用静态页面来实现。但是对于大量内容且频繁更新的网站，无法全部手动实现，于是出现了常见的信息发布系统CMS，像各门户站点的新闻频道，甚至其他频道，都是通过信息发布系统来管理和实现的，信息发布系统可以实现最简单的信息录入自动生成静态页面，还能具备频道管理、权限管理、自动抓取等功能。对于一个大型网站来说，拥有一套高效、可管理的CMS是必不可少的。</li><li>除了门户和信息发布类型的网站，对于交互性要求很高的社区类型网站来说，尽可能的静态化也是提高性能的必要手段，将社区内的帖子、文章进行实时的静态化，有更新的时候再重新静态化也是大量使用的策略，像Mop的大杂烩就是使用了这样的策略，网易社区等也是如此。</li><li>同时，html静态化也是某些缓存策略使用的手段，对于系统中频繁使用数据库查询但是内容更新很小的应用，可以考虑使用html静态化来实现，比如论坛中论坛的公用设置信息，这些信息目前的主流论坛都可以进行后台管理并且存储再数据库中，这些信息其实大量被前台程序调用，但是更新频率很小，可以考虑将这部分内容进行后台更新的时候进行静态化，这样避免了大量的数据库访问请求。</li></ul><h4 id="2-采取缓存处理"><a href="#2-采取缓存处理" class="headerlink" title="2.采取缓存处理"></a>2.采取缓存处理</h4><p>访问量持续增大，页面响应越来越慢。考虑到网站还处在试水性成长阶段，节约成本，硬件不动，着重应用本身优化。采取缓存处理机制是个必然的选择。<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic4.png" alt=""></p><ul><li>优点：简单有效、维护方便</li><li>缺点：依然存在单点</li><li><p>技术点：客户端(浏览器)缓存、前端页面缓存、页面片段缓存、本地数据缓存/数据库缓存</p><ul><li>客户端(浏览器)缓存<br>能够让浏览器缓存的数据一定要缓存；浏览器能够处理的运算，决不放在服务器端来处理。<ul><li>根据HTTP协议特性，修改Header参数(Cache-Control、Expires、Pragma、Last-Modified、Etag)，让浏览器来缓存页面(一些优秀开发框架会对此做透明的封装，例如：Beetle)</li><li>使用HTTP1.1协议，由于http pipelining技术特性，能够使用get请求的决不采取post请求</li><li>为了节约带宽，压缩页面(Content-Encoding: gzip)；页面各个元素能“小”即“小”，例如：js包压缩，js合并，图片压缩等</li><li>会话状态信息采取Cookie代替传统使用服务器Sessions对象存储习惯做法；使用Ajax实现页面局部刷新</li><li>如果可能，可采取浏览器插件技术突破浏览器功能限制，将原本在服务器端运算，尽量迁到浏览器端。ActiveX/Applet/Flash/….HTML5(最值得期待，她的出现必定改变整个Web世界)</li></ul></li><li><p>前端页面缓存</p><ul><li><p>访客向网站发出访问请求,由前端页面缓存器负担原服务器的处理进程做出响应,获取原服务器的相应网页内容,将其储存在自身的内存中,与此同时,传送给访客这一缓存的内容;如有另一访客也请求访问之前的相同内容,前端页面缓存器毋须再次获取原服务器上的相应内容,而直接从自身的内存中获取,将这一内容传送给访客。反之,前端页面缓存器也可缓存访客的GET和POST请求。</p></li><li><p>访客实际面对的是前端页面缓存器,与网站之间的通讯完全由前端页面缓存器反向代理,而非原服务器直接响应访客,这将大大加快访客上网流畅度,有效提升访问量,显著降低带宽占用,减轻原始服务器的繁忙度,加快响应速度,毋须不停地购置大内存,大硬盘,扩容电力设施为服务器端节省成本。<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic5.png" alt=""><br><strong>注意：</strong> 采用具备缓存功能的http反向代理服务器作前端页面缓存器，Varnish\Squid\Ncache\AiCache(商业)…[硬件F5]</p></li></ul></li><li><p>页面片段缓存ESI(Edge Side Includes)</p><ul><li>ESI是一个基于XML的标记语言，目的是在HTTP中组装各种资源。在实际环境中，一个动态生成的页面，当中可能只有少量的内容是频繁变化的或是个性化的，对于传统的Cache服务器来说，为了能够保证页面的时效性，却由于页面中这些少量的动态内容而无法将整个页面进行缓存。ESI通过使用简单的标记语言来对那些可以缓存和不能缓存的网页中的内容片断进行描述，每个网页都被划分成不同的小部分分别赋予不同的缓存控制策略，使Cache服务器可以根据这些策略在将完整的网页发送给用户之前将不同的小部分动态地组合在一起。通过这种控制，可以有效地减少从服务器抓取整个页面的次数，而只用从原服务器中提取少量的不能缓存的片断，因此可以有效降低原服务器的负载，同时提高用户访问的响应时间。</li><li>ESI需要服务器端支持，常见apache(mod_esi)、WebLogic、JSP标签库(JESI)等。</li></ul></li><li><p>本地数据缓存</p><ul><li>关系数据库系统(如：Oracle\MySql)<br>Query Cache策略：<ul><li>一般以sql为key来缓存查询结果，尽量不要拼sql，使用PreparedStatement的“？”模式sql；</li><li>Query Cache大小要根据数据库系统具体情况合理设置，过大只会浪费内存，参考值：128M</li></ul></li><li>关系数据库系统Data<br>Buffer策略：就是数据库数据内存缓存器，其访问命中率决定数据库性能，可根据实际物理内存大小适量增大，如：MySql建议buffer值为物理内存60-80%</li><li>应用服务器Cache包括：对象缓存(例如：对象线程安全，做成单例)，更新频率不大数据考虑缓存(如：基表数据、配置文件信息)，考虑使用线程池，对象池，连接池等</li><li>常见java解决方案：map\OSCache\EHCache等<br><strong>注意：</strong> 1、需要从数据库系统和Web应用服务器两个层面考虑缓存优化<br>2、常见缓存算法：（贝莱蒂算法、最近最少使用算法、最近最频繁使用算法、伪LRU算法）</li></ul></li></ul></li></ul><h4 id="3-增加机器做HA、数据库读写分离"><a href="#3-增加机器做HA、数据库读写分离" class="headerlink" title="3.增加机器做HA、数据库读写分离"></a>3.增加机器做HA、数据库读写分离</h4><p><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic6.png" alt=""></p><ul><li>优点：增加服务器和HA机制，系统性能及可用性得到保证</li><li>缺点：读写分离，增加程序难度，架构变复杂，维护难度增加</li><li>技术点：负载均衡、DAL、数据库读写分离<ul><li>负载均衡<br>LVS(LVS集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序)<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic7.png" alt=""><br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic8.png" alt=""></li><li>数据库读写分离及DAL<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic9.png" alt=""><br>各个关系数据库厂商针对dal及replication都有自己方案<br>独立的DAL Proxy服务器(MySQL: mysqlproxy,Amoeba；PostgreSQL: PL/Proxy)DAL API(Java: Hibernate Shard,Ibatis Shard,HiveDB,Guzz；Python: Pyshards)</li></ul></li></ul><h4 id="4-CDN、分布式缓存、分库"><a href="#4-CDN、分布式缓存、分库" class="headerlink" title="4.CDN、分布式缓存、分库"></a>4.CDN、分布式缓存、分库</h4><p>网站业务发展迅速，数据量大幅增大是当前最大的挑战，用户分散各地区，某些地方用户访问响应很慢，影响体验和业务发展；同时，由于数据量过大，数据缓存在本地内存已经不现实，分布式缓存是必然选择了。<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic10.png" alt=""></p><ul><li>优点：异地缓存有效解决不同地方用户访问过慢的问题；分库策略带来网站性能整体提升</li><li>缺点：成本大幅增加，架构进一步复杂化，也维护难度进一步增大，架构开始臃肿了</li><li>技术点：CDN、分布式缓存、Shard分库<ul><li>CDN<br>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络”边缘”，使用户可以就近取得所需的内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因所造成的用户访问网站响应速度慢的问题。 (也就是一个服务器的内容，平均分部到多个服务器上，服务器智能识别，让用户获取离用户最近的服务器，提高速度。</li><li>分布式缓存<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic11.png" alt=""><ul><li>本地缓存性能优秀，但容量有限，无伸缩性</li><li>采用分布式缓存方案突破容量限制，具备良好伸缩性；但分布式涉及远程网络通信消耗其性能本地缓存来得优秀，并可涉及节点状态维护及数据复制问题，其稳定性和可靠性是个挑战。</li><li>目前流行分布式缓存方案：memcached、membase、redis等，基本上当前的NoSQL方案都可以用来做分布式缓存方案</li></ul></li><li>分库：垂直分区和水平分区两种。<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic12.png" alt=""><br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic13.png" alt=""><br>垂直分库后，各模块数据之间如何关联查询？垂直分库前提是良好的松耦合的模块化设计<br>水平分区中，Shard是分布式解决方案，与数据库集中式的表空间分区是两个不同方案(分片Key识别(划分检索依据)是关键)</li></ul></li></ul><h4 id="5-多个数据中心，向分布式存储和计算的架构体系迈进"><a href="#5-多个数据中心，向分布式存储和计算的架构体系迈进" class="headerlink" title="5.多个数据中心，向分布式存储和计算的架构体系迈进"></a>5.多个数据中心，向分布式存储和计算的架构体系迈进</h4><p><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic14.png" alt=""></p><ul><li>优点：多数据中心，带来更高质量区域服务体验；分布式存储及计算架构有效解决pb级数据量存储、检索及计算性能问题</li><li>缺点：架构复杂、数据同步、一致性及系统维护、技能要求等成本十分高</li><li>技术点：分布式文件系统、Map/Reduce、Key-Value存储<ul><li>分布式存储计算解决方案[DFS、Map/Reduce、Key-Value DB]<br>DFS提供了一个全局命名空间的高可用(通过跨机器(和跨机架)的文件数据复制来达到高可用性，免受传统文件存储系统无法避免的许多失败的影响)文件系统，解决高容量数据高效、可靠存储问题；Map/Reduce的计算框架，它与DFS紧密协作，帮助处理收集到的海量数据;Key-Value DB代替传统的数据库，通过一些主键来组织海量数据，并实现高效的查询。<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic15.png" alt=""><ul><li>DFS分布式文件系统，如：Lustre\HDFS\GFS\TFS\FreeNas等</li><li>Map/Reduce算法（计算框架），基本上现有NoSQL数据库中都支持此算法。</li><li>Key-Value DB，也作为NoSQL解决方案，如：BigTable\Tair\Hbase\ HyperTable等</li><li>提供完整解决方案：<ul><li>Google(GFS|Map/Reduce|BigTable)</li><li>Apache Hadoop(HDFS|Map/Reduce|HBase)<h2 id="架构设计理念与原则"><a href="#架构设计理念与原则" class="headerlink" title="架构设计理念与原则"></a>架构设计理念与原则</h2></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大型网站架构的目标与挑战&quot;&gt;&lt;a href=&quot;#大型网站架构的目标与挑战&quot; class=&quot;headerlink&quot; title=&quot;大型网站架构的目标与挑战&quot;&gt;&lt;/a&gt;大型网站架构的目标与挑战&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/05/12/企业软件开发-大
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="企业软件开发" scheme="http://yoursite.com/tags/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>企业软件开发_开发模式SSH、SOA、ESB</title>
    <link href="http://yoursite.com/2018/05/12/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8FSSH%E3%80%81SOA%E3%80%81ESB/"/>
    <id>http://yoursite.com/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/</id>
    <published>2018-05-12T11:52:57.000Z</published>
    <updated>2018-09-22T07:36:53.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic1.png" alt=""><br><a href="http://jackeyzzhold.xyz/2018/03/10/java-ssh%E6%A1%86%E6%9E%B6-3/" target="_blank" rel="noopener">见另外一篇博客内容</a></p><h2 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h2><p>SOA的全称是Service-Oriented Architecture，面向服务架构。它是一种架构，不是一种具体的开发技术。<br>SOA是通过功能组件化、服务化来实现系统集成、解决信息孤岛，这就是其主要目标。而更进一步则是实现更快响应业务的变化、更快推出新的应用系统。与此同时，SOA还实现了整合资源、资源复用。<br><strong>软件开发四阶段：</strong></p><ul><li>汇编语言开发</li><li>面向过程的软件</li><li>面向对象的组件开发</li><li>面向服务的架构开发，即SOA</li></ul><p><strong>SOA特点：</strong></p><ul><li>SOA是一种开发思想。是一种松耦合的框架。可以让软件超越开发语言。</li><li>SOA的开发需要SOA体系的支撑，就像J2EE应用一样，离不开应用服务器。SOA也一样，也有一个类似J2EE服务器的东西支持着整个SOA体系架构—-ESB(Enterprise Service Bus)，企业服务总线。通过这个总线，将多个系统连接起来。</li><li>SOA是基于消息请求响应的一个系统，对请求类型有高度的兼容性。与一个Web应用容器相比，web应用容器只能处理HTTP请求，而 SOA的ESB可以接受HTTP、FTP、WebService、JMS…等请求。这就使得SOA架构具有高度的兼容性，可以将不同的平台集成到一起，从而相互协调工作。</li></ul><p><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic2.png" alt=""></p><p><strong>SOA的使用场景：</strong><br><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic3.png" alt=""><br>通过上面的图我们可以看出，多个子系统直接相互交互，相互调用非常凌乱，这样我们就很不爽，所以我们就用到了我们的SOA架构，SOA又叫服务治理，SOA就是帮助我们把服务之间调用的乱七八糟的关系给治理起来，然后提供一个统一的标准，把我们的服务治理成下图所示，以前我们的服务是互相交互，现在是只对数据总线进行交互，这样系统就变得统一起来。<br><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic4.png" alt=""><br>统一标准：各系统的协议、地址、交互方式。<br>新的交互方式：各个系统分别根据统一标准向数据总线进行注册，各子系统调用其他子系统时，我们并不关心如果找到其他子系统，我们只招数据总线，数据总线再根据统一标准找其他子系统，所以数据总线在这里充当一个只路人的作用。<br><strong>SOA的好处：</strong></p><ul><li>降低用户成本，用户不需要关心各服务之间是什么语言的、不需要知道如果调用他们，只要通过统一标准找数据总线就可以了。</li><li>程序之间关系服务简单</li><li>识别哪些程序有问题（挂掉）</li></ul><p><strong>缺点：</strong> 提示了系统的复杂程度，性能有相应影响。</p><p><strong>数据总线：</strong><br><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic5.png" alt=""><br>数据总线是起到调度服务的作用，数据总线不是集成服务，数据总线更新一个调度框架，每个服务需要根据约定向数据总线注册服务，那么如何注册那？其实数据总线就像一个字典结构，<br>数据总线里面一个key对于一个value，key指的是服务名，value则是服务的调度方式，还有一点需要说明的是，数据总线只是指路人，服务是不经过数据总线的，如上图的黄色线的路径。<br>数据总线通过域名解析实现:一个域名绑定多台服务器，ajax也可以，dns也可以，解析域名嘛。<br>其实数据总线还有一些高级应用，比如心跳检测，实现负载均衡等等，就不细说了，目前应用数据总线的有阿里的dubbo,还有zookeeper。</p><h2 id="ESB"><a href="#ESB" class="headerlink" title="ESB"></a>ESB</h2><p>ESB是一种在松散耦合的服务和应用之间的标准的集成方式，可以作用于：</p><ul><li>面向服务的架构-分布式的应用由可重用的服务组成</li><li>面向消息的架构-应用之间通过ESB发送和接受消息</li><li>事件驱动的架构-应用之间异步地产生和接收消息</li></ul><p><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic6.png" alt=""><br><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic7.png" alt=""><br><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic8.png" alt=""></p><p><strong>ESB服务：</strong></p><ul><li>传输服务<ul><li>安全、可靠的数据传输</li><li>永久性/非永久性</li><li>同步/异步</li></ul></li><li>仲裁服务<ul><li>路由</li><li>格式转换</li></ul></li><li>事件服务<ul><li>事件发现和发布</li><li>Publish/Subscribe</li></ul></li></ul><p><strong>ESB功能：</strong></p><ul><li>通信</li><li>集成</li><li>服务交互</li><li>服务质量</li><li>安全性</li><li>消息处理</li><li>服务级别</li><li>管理和自治</li><li>建模</li><li>基础架构智能</li></ul><p><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic9.png" alt=""><br><strong>WebSphere DataPower</strong></p><ul><li>简化SOA</li><li>保护SOA</li><li>加速SOA</li></ul><p>应用场景：</p><ul><li>保护对外的web服务</li><li>传统系统集成</li><li>hub式的中介服务</li><li>加速动态的web站点</li></ul><p><strong>不采用传统架构，而采用ESB总线的原因：</strong></p><ul><li>利用开放标准，将软件资产展现为服务的架构</li><li>面向服务的体系架构</li><li>总体性价比</li></ul><hr><p><strong>OSB</strong></p><ul><li>易用性加强</li><li>性能提升<ul><li>采用Cache机制，为静态响应信息提升性能。静态响应信息是指在一段时间内不会发生变化的信息，如天气预报，手机套餐，人民币汇率等，这些数据变化的周期通常是1天，1月。</li><li>实现手段：采用比较成熟的开源Memcached或者轻量级的JCACHE。</li></ul></li><li>管控能力增强</li></ul><hr><p><strong>Mule</strong></p><ul><li>社区活跃度</li><li>易用性<br>“让一切变得更简单”是Mule的宗旨。2次重构核心架构、推出接入云应用，消息流，基于模式的配置以及热部署；Mule IDE3.0，将支持图元拖拽，简化开发。</li><li>扩展性<br>增加一个新协议非常简单，只需实现5个接口类即可</li><li>管理性<ul><li>异常处理框架<br><strong>异常策略设置级别:</strong> model和service<br><strong>异常处理方式：</strong><ul><li>1.将异常路由到指定的目的地</li><li>2.根据异常类型过滤异常，并路由到指定目的地</li><li>3.设置重试次数</li><li>4.当采用了事务时，可以在异常处理策略中设置当发生异常时是继续提交还是回滚事务。</li></ul></li></ul></li><li>文档<br>文档非常丰富，降低了使用门槛。</li></ul><hr><p><strong>ServiceMix</strong><br><strong>优势：</strong></p><ul><li>无缝集成CXF,ActiveMQ,Camel和ODE</li><li>JBI的优势</li><li>基于OSGI</li><li>基于Karaf</li></ul><p><strong>缺点：</strong></p><ul><li>JBI规范太复杂</li><li>架构复杂</li><li>缺少IDE的支持</li><li>缺少governor的支持</li><li>学习门槛高</li></ul><hr><p><strong>Synapse/WSO2 ESB</strong><br>WSO2 ESB对Synapse增加了企业级特征：</p><ul><li>1.基于WSO2的Carbon平台（OSGi框架）</li><li>2.支持集群、负载均衡和failover routing</li><li>3.支持流量控制和数据缓存</li></ul><p>还增加了外围产品：</p><ul><li><ol><li>WSO2 Governance Registry，服务注册产品</li></ol></li><li><ol><li>WSO2 ESB management console，ESB管理控制台</li></ol></li><li><ol><li>WSO2 Carbon Studio，开发ESB的studio</li></ol></li></ul><p><strong>WSO2 ESB的优势：</strong></p><ul><li>基于Axis</li><li>基于WSO2的Carbon平台</li><li>支持集群<br>集群中节点间的通信框架基于Apache Tribes（组通信框架）<br>相关信息持久化在内嵌的Derby中<br>支持一个主节点和多个从节点</li><li>failover routing<br>在集群环境中，所有的请求只能被主节点接收，从节点只能作为备份节点。</li><li>支持流量控制<br>在单个ESB实例或者集群中，可以在服务级别配置流量控制。当请求数超过阀值时，ESB将被拒绝访问。<br>实现机制：借助组件Throttling Mediator</li><li>支持数据缓存<br>集群中的各个ESB实例共享缓存的数据。当一个请求被ESB实例1处理完后返回响应信息，当再次向ESB实例1或者集群中其他的ESB实例发送该请求时，直接从缓存中取出原来的响应信息。<br>实现机制：借助组件Caching Mediator</li><li>WSO2 Governance Registry：开源中最优秀的服务注册项目</li><li>WSO2 ESB management console<br>创建和管理各组件（接入层、中介层和接出层）；<br>图形化地方式统计系统资源（CPU,内存）；<br>图像化统计ESB中各组件（接入层、中介层和接出层）接收发送消息的大小以及响应时间；<br>记录系统日志、SOAP日志；图形化显示消息的流向</li><li>文档丰富</li><li>大量使用实例</li></ul><p><strong>缺点：</strong></p><ul><li>架构不够清晰</li><li>扩展性差</li><li>组件比较混乱</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=&quot;SSH&quot;&gt;&lt;/a&gt;SSH&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="企业软件开发" scheme="http://yoursite.com/tags/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>企业软件开发_负载均衡</title>
    <link href="http://yoursite.com/2018/05/12/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2018/05/12/企业软件开发-负载均衡/</id>
    <published>2018-05-12T11:51:09.000Z</published>
    <updated>2018-09-22T07:36:53.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>负载均衡</strong> 是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。一个典型的使用负载均衡策略的是：在软件或者硬件四层交换的基础上搭建squid集群，低成本、高性能还有很强的扩张性，随时往架构中增减节点都非常容易。</p><h2 id="硬件四层交换"><a href="#硬件四层交换" class="headerlink" title="硬件四层交换"></a>硬件四层交换</h2><ul><li>第四层交换使用第三层和第四层信息包的报头信息，根据应用区间识别业务流，将整个区间段的业务流分配到合适的应用服务器进行处理。</li><li>第四层交换功能就像是虚拟IP，指向物理服务器。</li></ul><p>知名产品有：Alteon,F5等。Yahoo中国的近2000台服务器用了三四台Alteon。</p><h2 id="软件四层交换"><a href="#软件四层交换" class="headerlink" title="软件四层交换"></a>软件四层交换</h2><ul><li>YAHOO网站应用—-DNS</li><li>简单的应用—-URL重定向方式</li><li>不太重要的纯linux应用—-LVS</li><li>重要、流量大、应用简单、预算充足—-硬件(F5)(做双机)</li><li>企业应用，复杂、跨平台—-专业负载均衡软件<h3 id="URL重定向方式"><a href="#URL重定向方式" class="headerlink" title="URL重定向方式"></a>URL重定向方式</h3><strong>存在的问题:</strong></li><li>容易在浏览器上形成死循环</li><li>location存放位置问题、带session时重定向可能会出问题</li><li>一般只适用于HTTP方式</li><li>效率低于IP隧道</li><li>实时性不好</li></ul><h3 id="基于DNS"><a href="#基于DNS" class="headerlink" title="基于DNS"></a>基于DNS</h3><p>最早的负载均衡技术是通过DNS来实现的，<strong>在DNS中为多个地址配置同一个名字，因而查询这个名字的客户机将得到其中一个地址，从而使得不同的客户访问不同的服务器，达到负载均衡的目的。</strong></p><ul><li>DNS不能区分服务器的差异，也不能反映服务器的当前运行状态，当使用DNS负载均衡时，必须尽量保证不同的客户机均匀获得不同的地址。</li><li>为了使得地址能随机分配，应该使DNS数据中的刷新时间尽量短，不同地方的DNS服务器能更新对应的地址，达到随机获得地址，但是若设置过短，将使DNS流量大增造成额外的网络问题。</li><li>若某台服务器出现错误，即使及时修改了DNS设置，也需等待足够的时间(刷新时间)才能发挥作用。</li><li>与专业的负载均衡软件如PCL相比，DNS的问题有：<ul><li>往往不能根据系统与服务的状态来判断负载</li><li>往往不能建立较复杂的负载均衡算法</li></ul></li></ul><h3 id="基于LVS"><a href="#基于LVS" class="headerlink" title="基于LVS"></a>基于LVS</h3><p>LVS是一个开源的软件，可以实现LINUX平台下的简单负载均衡。负载均衡集群是在应用服务器高负载的情况下，由多台节点提供可伸缩的，高负载的服务器组以保证对外提供良好的服务响应，LVS就是实现这一功能的技术，是一种Linux操作系统上基于IP层的负载均衡调度技术，<strong>它在操作系统核心层上将来自IP层的TCP/UDP请求均衡地转移到不同的服务器。</strong><br><strong>优点：</strong></p><ul><li>开源免费</li><li>在网上能找到一些相关技术资源</li><li>具有软件负载均衡的一些优点</li></ul><p><strong>缺点：</strong></p><ul><li>没有可靠的支持服务</li><li>功能较为简单</li><li>开启隧道方式需重编译内核</li><li>配置复杂</li><li>只支持linux</li></ul><h3 id="专业负载均衡软件"><a href="#专业负载均衡软件" class="headerlink" title="专业负载均衡软件"></a>专业负载均衡软件</h3><p><strong>特点：</strong></p><ul><li>基于IP隧道的，独立于应用—-对比URL重定向</li><li>支持不同平台—-对比LVS</li><li>实时的—-对比DNS</li><li>能够根据系统、应用的情况来决定负载—-对比硬件</li><li>适用于企业级应用，可靠性、服务保障</li></ul><h2 id="session及负载均衡"><a href="#session及负载均衡" class="headerlink" title="session及负载均衡"></a>session及负载均衡</h2><p>在WEB开发中，服务器可以为每个用户浏览器创建一个 <strong>会话对象（session对象）</strong>，注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。<br>在搭建java web应用程序时，对http session的处理策略很大程度决定了应用程序的扩展性、可用性，处理方案如下：</p><ul><li>在服务器端不保存session，完全无状态：<strong>采用Stateless</strong>，典型例子 <strong>REST</strong>。</li><li>基于浏览器CooKie的session共享<ul><li>把用户相关的session信息存储到浏览器的cookie中，也称为客户端session</li><li><strong>缺点：</strong> 只能够存储字符串、数值等基本类型的数据；cookie大小存在限制；安全性；带宽及数据解压缩、网络传输性能问题。</li></ul></li><li>基于数据库的session共享，实现分布式应用间session共享<ul><li>把session信息存储到数据库表，实现不同应用服务器间session信息的共享。如websphere portal、weblogic portal</li><li>优点：实现简单</li><li>缺点：数据库服务器相对于应用服务器更难扩展且资源更为宝贵，在高并发的web应用中，最大的性能瓶颈通常在于数据库服务器。</li></ul></li><li>基于应用服务器/servlet容器的clustering机制<ul><li>这个机制可以实现session replication的功能，如tomcat clustering/session replication、Jboss buddy replication</li><li>缺点：基于clustering的session复制性能很差，扩展性不行</li></ul></li><li>基于NFS的session共享<ul><li>实现共享各台服务器只需要mount共享服务器的存储session的磁盘即可，实现较为简单。但NFS对高并发读写性能不高、在硬盘I/O性能和网络带宽上存在较大瓶颈。</li></ul></li><li>基于Terracotta、Ehcache、JBossCache等java caching方案实现session共享</li><li>基于Memcached/Tokyo Tyrant等key-value DB的session共享：扩展性最好</li></ul><h2 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h2><ul><li>随着业务增加拆分为小系统</li><li>将所有内容部署在一起，依赖于 <strong>集群分发到多个节点上去做负载均衡</strong>，以实现切割</li><li><strong>独立工具、模块、服务的独立化和集群化，基于SOA服务的企业级应用</strong></li><li>数据库拆分<ul><li>散列</li><li>分区</li><li>分表</li><li>读写分离</li><li>多实例运算</li><li>采用nosql或内存数据库</li></ul></li></ul><h2 id="系统通信"><a href="#系统通信" class="headerlink" title="系统通信"></a>系统通信</h2><p>系统拆分导致系统需要通信，拆分时要尽量减少相互之间的通信，做到系统的低耦合、高内聚、减少外部依赖。</p><ul><li>早期的socket</li><li>RMI</li><li>基于RPC的web services</li><li>httpclient</li></ul><h2 id="负载均衡实例解决"><a href="#负载均衡实例解决" class="headerlink" title="负载均衡实例解决"></a>负载均衡实例解决</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><blockquote><p>怎样相对准确获取同时在线用户数，怎样实现类似于聊天室的管理员把用户踢出聊天室的功能，怎样实现类似在线聊天室的功能？</p></blockquote><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><blockquote><p>怎样实现同一账号同一时间点只能有一个账号在线</p></blockquote><p><strong>流程图：</strong><br><img src="/2018/05/12/企业软件开发-负载均衡/pic1.png" alt=""></p><ul><li>在账户表的基础上，我新建了一个账户account_session表，用来记录登录账户的account_id和最新一次登录成功用户的session_id。</li><li>然后首先要修改登录方法：每次登录成功后，要将登录用户信息写入Session的同时还要更新account_session表里相应账户的session_id（当然，如果是第一次登录时，进行的便是插入动作）。</li><li>然后要修改获取当前用户信息的方法，在里面要做两重判断：<br>首先，看当前会话是否存在登录用户信息，如果没有，则肯定是未登录，不再赘述，如果有，还要再进一步要用当前会话里存的account_id去account_session表查询最新的session_id，与当前会话中的session_id作比较，如果是一致的，说明当前会话是最新的会话，登录状态正常，如果不一致，说明在当前登录会话创建后，被新的登录会话覆盖掉了，当前的登录会话已经失效，这时候，服务器应该删除当前的登录会话并返回提示给客户端，至此，限制账户同一时间单终端登录功能便实现了。</li></ul><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><blockquote><p>在多标签的浏览器中（例如ie8、firefox、chrome），用户开几个标签使用同一个web应用，是一个session还是多个session</p></blockquote><p>在IE6中，每启动1个IE，在进程中就会增加1个iexplor.exe进程，一个此进程就表示1个session对象，就会产生1个唯一sessionID与之对应。但是在多页签的浏览器例如IE7，IE8 ，没启动一个IE，此时浏览器中会有俩个iexplor.exe进程存在，1个代表当前窗口对象，另1个代表页签对象，如果在窗口中新增加页签的话，iexplor.exe的数量会加1.<br>在多页签的浏览器中，进行测试，页面的page_load事件中，增加代码测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string a = Session.SessionID;</span><br><span class="line">Response.Write(a + <span class="string">"&lt;br&gt;"</span>);</span><br></pre></td></tr></table></figure></p><p>发现在1个窗口中，无论打开多少个页签，都是同1个sessionID，那么问题就出现了，比如说：我在一个多标签的浏览器中，打开了俩个页签，分别叫A页签与B页签，那么我此时在A页签中打开1个登陆界面，输入A账户的用户名与密码，并且用session保存这个A用户的账号与密码，然后在B页签里面输入B的账户与密码，并且用session保存起来，那么此时你回头再刷新下A的页签，你会发现A页签里的session保存的A的信息全部被B的信息所覆盖了，这就是多页签使用同1sessionID的产生覆盖的核心机制。那么我们该如何处理呢？<br>我的解决方案是：1个IE窗口只能做1个登陆操作，如果你想再登陆，那么重新打开1个IE对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">(object sender, EventArgs e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Session[<span class="string">"a"</span>] != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                PublicMethods.ShowMessageBox(<span class="keyword">this</span>, <span class="string">"同一浏览器不能重复登录！"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Session[<span class="string">"a"</span>] = <span class="keyword">this</span>.txtName.Text.Trim();</span><br><span class="line">            Response.Redirect(<span class="string">"Test.aspx"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>原理说明：1个多页签IE窗口无论打开多少个页签都是一个sessionID，那么这个sessionID对象下有1个key为a的session内容，如果你第一次登陆的话，这个session为a的内容为Null状态，如果你打开1个页签再做1个登陆操作的话，那么此时session a 就不为Null，提示用户新开1个窗口进行操作。因为新打开的IE会产生1个新的不重复的sessionID，此时这个sessionID对象对应的session a 还是为Null，那么可以进行登陆操作了。</p><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><blockquote><p>struts2中避免用户重复提交同一页面的机制？</p></blockquote><p>防止表单重复提交，这是个很重要的知识点，而且很有用。当用户提交了一个表单，此时，地址栏显示的是处理这个表单的Action的地址，若此时刷新，则会重新发送一次表单数据，即又进行了一次提交，若这个Action是用来处理用户注册的，那么重复提交会再一次向数据库中插入之前已经插入的数据，这显然不是我们想要的。有两种方法，可以防止表单重复提交，一种是用Action的重定向，一种是用Session Token（Session令牌）。</p><p>第一种方法，Action处理完用户提交的数据后，重定向到另一个Action或是一个页面，使用户提交后，所停留的位置，不是当前处理数据的Action，这样用户再刷新时，就不会再次执行这个Action了，就会避免表单重复提交的问题了。</p><p>第二种方法，是一种很经典的处理这个问题的机制。这种方法是在用户要提交的表单中，加入一个&lt;s:token&gt;标签，这样，当浏览器第一次访问这个带有&lt;s:token&gt;标签的页面时，在服务器中，解析&lt;s:token&gt;标签的类（TokenTag.class），会生成一个随机的字符串（这个字符串，查看网页的源代码可以看到），并且发送给客户端的浏览器，同时，在服务器中，会把这个随机字符串保存到用户的session对象中。当第一次提交表单时，在服务器中，会比较客户端和服务器中分别保存的这个随机字符串，因为是第一次提交，所以这两个字符串相等，然后进行正常的业务处理。第一次提交后，在服务器中的session中保存的这个随机字符串，会改变为其他的随机值，注意，这是很重要的一步！此时，地址栏停留在处理用户提交数据的Action中，客户端中保存的随机字符串没有改变，若是刷新页面，即重复提交，服务器再进行两个字符串的比较，会不相等，就会跳转到name为invalid.token的结果页面中，这样就会防止表单重复提交了。<br>举例说明一下session token的机制:<br><strong>Login.jsp:</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:form action=<span class="string">"/test/token"</span> theme=<span class="string">"simple"</span>&gt;  </span><br><span class="line">        username:&lt;s:textfield name="username"&gt;&lt;/s:textfield&gt;&lt;br&gt;  </span><br><span class="line">        password:&lt;s:password name="password"&gt;&lt;/s:password&gt;&lt;br&gt;  </span><br><span class="line">        &lt;s:submit value="submit"&gt;&lt;/s:submit&gt;  </span><br><span class="line">        &lt;s:token&gt;&lt;/s:token&gt;&lt;!--一定要有这个标签--&gt;  </span><br><span class="line">    &lt;/s:form&gt;</span><br></pre></td></tr></table></figure></p><p><strong>struts.xml:</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;action name=<span class="string">"token"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.suo.actions.TokenAction"</span>&gt;  </span><br><span class="line">            &lt;result name="success"&gt;/WEB-INF/result/LoginResult.jsp&lt;/result&gt;  </span><br><span class="line">            &lt;result name="invalid.token"&gt;/WEB-INF/result/TokenFailed.jsp&lt;/result&gt;  </span><br><span class="line">            &lt;!-- 若重复提交，则会跳转到这个页面，注意这里result的名字，一定要是invalid.token --&gt;  </span><br><span class="line"></span><br><span class="line">            &lt;interceptor-ref name="token"&gt;&lt;/interceptor-ref&gt;  </span><br><span class="line">            &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;  </span><br><span class="line">            &lt;!-- 这里一定要有这两个拦截器 --&gt;  </span><br><span class="line">        &lt;/action&gt;</span><br></pre></td></tr></table></figure></p><p><strong>TokenAction.java:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.suo.actions;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;  </span><br><span class="line"><span class="keyword">import</span> org.apache.struts2.ServletActionContext;  </span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionContext;  </span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String username;  </span><br><span class="line">    <span class="keyword">private</span> String password;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> username;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.username = username;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> password;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.password = password;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;     </span><br><span class="line">        <span class="keyword">return</span> SUCCESS;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h3><blockquote><p>怎样实现类似于gmail、sina等大型网站的用户自动登录功能</p></blockquote><p>在用户登录后，将用户的用户名和密码保存到cookie中发送给浏览器，浏览器下次再次访问的时候会把cookie内容带回来，服务器从cookie中区出用户名和密码进行验证，如果验证通过，则允许进入首页等，从而达到自动登录的目的。<br><strong>降低风险：</strong><br>1.通过将cookie中保存的信息进行加密处理，用户登陆成功以后，将时间戳和随机数合并通过MD5加密处理形成Token。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　String token = Utils.MD5(System.currentTimeMillis()+Math.Rand(<span class="number">0</span>,<span class="number">9999999</span>));</span><br></pre></td></tr></table></figure></p><p>当然，也可以通过用户名+系统时间生产Token或者将sessionId加密生产Token也可以。<br>2.将用户ID（uid或者userName）和有效时间（1个月）以及Token保存在cookie中，同时记录到数据库表中（Remember_Key）。<br>3.用户访问网站时，后台读取Cookie，获取uid和Token，去数据库对比，如果都存在，且在有效期内，则通过uid直接获取用户信息并保存session，直接跳转到首页。<br>前端可对此进行处理，获取到后台返回的数据后，展示用户名以及头像信息等。<br>4.后台需要做过滤器，过滤网站的所有页面，每当打开页面时，首先判断是否登陆，如果已经登陆则跳过，如果未登陆，需要先读取Cookie，判断是否匹配，如果匹配则跳过登陆，直接获取用户信息，否则跳转到登陆页面。</p><h3 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h3><blockquote><p>怎样实现类似于在线投票防止同一用户重复投票的功能。</p></blockquote><p><strong>方法一：利用Session对象</strong><br>在Global.asa的Session_OnStart事件中设置逻辑变量IsVoted，初始值为FALSE（表示还没有投票），投票之后在.asp程序中把IsVoted的值改为TRUE(表示已投过票)。每次投票之前都要判断IsVoted的值。如果IsVoted的值为TRUE，就不能再投票；如果值为FALSE，则可以投票。<br>因为Session对象的使用必须与浏览器的Cookies功能相配合，所以在判断IsVoted值之前，必须先判断浏览器的Cookies功能是否打开。如处于关闭状态，则此种方法失效，所以在这种情况下必须给出提示信息并用Response.End命令中断.asp程序的执行，防止连续反复投票。<br><strong>漏洞：</strong> 如果再打开一个新浏览器窗口，会发现在新打开的浏览器窗口中仍然可以投票。这是因为Session是私有的，一个Session中变量的改变并不影响另一个Session的同名变量的值。<br><strong>方法二：利用Cookies对象</strong><br>因为Cookies对象把变量的值保存在浏览器客户端，所以可以根据Cookies保存的IsVoted的值来判断用户是否投过票。Cookies变量和Session变量一样是私有的，但是如果我们定义了Cookies变量的生存期限，则Cookies变量是公有的，凡是从同一台机器上登录的用户在规定的时间期限没有达到时，都无法投票，这在一定程度上也能防止反复投票。<br><strong>漏洞：</strong> 在Windows 9x环境下，只要把 Windows/Cookies目录下所有＊.txt文件删除，又可重复投票。为了再进一步防止反复投票。<br><strong>方法三：验证IP地址与登录时间</strong><br>此方法首先利用Request.ServerVariables(REMOTE_ADDR)取得用户的IP地址。在Web Server端建立一个标准的MDB类型的数据库，此数据库有一个表，该表只有两个字段：IP地址和登录时间。之所以设置登录时间这个字段，是考虑到拨号上网用户可能共用同一个IP地址，如果一个IP地址只能投一次票，那么显然不合理。同时，我们还采用方法二同样的思想，必须每隔一个设定的时间段，同一个IP地址才能再次投票。所以这种方法比方法一、方法二在防止反复投票方面要严格得多。<br><strong>方法四：小范围调查</strong><br>这种方法只适用于小范围调查，思想与方法三相同，只是把方法三中的 IP地址换成可以唯一代表用户的字段，如学生证号、工作证号等。这时建立的MDB数据库只包括两个字段：证件号码与IsVoted(其中IsVoted是逻辑型字段， TRUE表示已投过票，FALSE表示还未投票，在建库时所有记录的IsVoted的值都设为 FALSE)。在投票之前，要求先输入正确的证件号码，然后再判断IsVoted的值。</p><h3 id="问题7"><a href="#问题7" class="headerlink" title="问题7"></a>问题7</h3><blockquote><p>微信网页版如何验证？<br>问题：<br>（1）如何将手机上的微信号与网页版上的二维码关联起来？<br>（2）如何验证登录并保证唯一性？<br>（3）为什么不直接用用户名和密码登录，而且 采用二维码？<br>（4）如何保证手机端和网页端信息的同步？<br>（5）如何保证在超时、网络断开、其他设备上登录后，原先已经登录的能够自动断开？</p></blockquote><p>1、微信网页版有一个二维码，这个二维码里面的信息其实就是一个url：<a href="https://login.weixin.qq.com/l/8fb2531b276849，" target="_blank" rel="noopener">https://login.weixin.qq.com/l/8fb2531b276849，</a> 当然后面带的那个参数是唯一的。<br>2、微信网页版打开后，就会向服务器发出一个ajax请求，请求的url却不是二维码里的url，而是这种格式：<br><a href="https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login?uuid=c758718a7fb844&amp;tip=1&amp;__=1410184901947，" target="_blank" rel="noopener">https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login?uuid=c758718a7fb844&amp;tip=1&amp;__=1410184901947，</a> (里面有三个参数，一个是二维码里面的url后面那个唯一的识别码uuid，一个是tip=1，一个是当前时间戳，参数名是一个下划线 _ )，如下图所示：<br><img src="/2018/05/12/企业软件开发-负载均衡/pic2.png" alt=""><br>同时把很多登录后才需要的相关资源都预先加载进来了，所以长连接等待登录用户得到确认后展示用户信息的速度很快，因为无需刷页面和加载头像外的其他资源。<br>3、服务器收到请求，就去数据库相应的表里面查询有没有这样一条记录：即get请求传过来的参数(uuid)跟一个微信用户id(其实就是微信号)绑定的一条记录，如下图所示：<br><img src="/2018/05/12/企业软件开发-负载均衡/pic3.png" alt=""></p><ul><li>1）如果没有这条记录，该请求会在服务器端保持27秒左右（如果用php实现，估计就是sleep一下，再查一下数据库，sleep一下，又查一下数据库，27秒之后还没有查到上面那条记录，就返回window.code=408）<br><img src="/2018/05/12/企业软件开发-负载均衡/pic4.png" alt=""><br><img src="/2018/05/12/企业软件开发-负载均衡/pic5.png" alt=""><br>页面收到这个返回值，则又发出一条请求（还是同样的请求，在服务器端保持27秒左右没有结果，就返回window.code=408，页面收到之后，再次发出请求，如此循环下去，直接找到这条记录）</li><li>2）如果有这条记录，而且ischeck=0，就显示<br><img src="/2018/05/12/企业软件开发-负载均衡/pic6.png" alt=""></li></ul><p>4、微信页面继续发送刚才的请求，这次就是查询ischeck字段是不是为1了：</p><ul><li>1）如果为1，则服务器给这个uuid对应的微信号做一个登录（比如session登录的，就用写入一个session），并返回一个cookie给浏览器用于保存登录状态，说这个微信号网页版已经登录了，而且还返回了登录跳转url，微信页面根据这个返回值，用js的window.location.href类似的方法，跳转一下，并加载登录后所需要的资源，到此，微信网页版登录完成。</li><li>2）如果不为1，则在服务器端保持27秒左右后，又回到原始的登录页面（相当于没有用手机扫描过，而且手机端再点登录网页版微信的时候，会提示那个二维码已经失效）</li></ul><p>5、至于微信查询的数据库的那条信息是执行插入呢？那肯定是手机了，手机访问二维码上的链接，带着唯一的uuid和自己的微信号，去插入这条信息，插入成功后，服务器会返回一个状态给微信，微信上就变成了一个按钮，要你确认是否登录微信，如果你点了确认，那么服务器上的这个uuid对应的那条记录的ischeck字段，就会被标记为1，由于客户端一直在反复查询是否有这条记录以及如果有这条记录，ischeck字段是否为1，所以能实现手机点击了确认，客户端就立刻跳转登录了。<br>6、对于验证过程，Open API 一般是通过授权令牌（Token）来解决的，原理是当用户通过授权后，分配一个限定条件下的令牌（如限制本机访问、限制授权有效时间、限制同时登录设备数等），使获得授权的用户仅在有限的前提下能访问相关服务。 像计算机休眠后曾做的授权就自动收回了，这样就有效的避免了在别人电脑上（尤其是网吧）打开，但忘记关闭或退出这类安全问题了。同时，整个授权过程的验证部分在手机端进行，有效杜绝了 PC 上泛滥的各类木马、『安全工具』的监听，大大降低了帐号被盗的风险。所以说，核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server 的帐号信息进行展示。 并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。 在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt; 是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。一个典型的使用负载均衡策略的是：在软件
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="企业软件开发" scheme="http://yoursite.com/tags/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>项目管理_知识点总结</title>
    <link href="http://yoursite.com/2018/05/02/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/02/项目管理-知识点总结/</id>
    <published>2018-05-02T09:24:23.000Z</published>
    <updated>2018-09-22T07:36:53.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目管理概述"><a href="#项目管理概述" class="headerlink" title="项目管理概述"></a>项目管理概述</h2><h3 id="项目与运营"><a href="#项目与运营" class="headerlink" title="项目与运营"></a>项目与运营</h3><p><strong>项目(project)</strong> 是“为创造一个特定的产品、服务或者成果而采取的临时性的努力”<br><strong>运营(operation)</strong> 是在组织中为了维持业务而进行的工作</p><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><ul><li>项目有一个特定的目的</li><li>项目是临时性的</li><li>项目是通过不断完善细节而逐步开展的</li><li>项目通常需要来自不同领域的资源</li><li>项目应有一个主要客户或发起人 <strong>(project sponsor)</strong>–一般为项目提供方向和资金</li><li>项目含有不确定性</li></ul><h3 id="项目约束"><a href="#项目约束" class="headerlink" title="项目约束"></a>项目约束</h3><p><strong>三项约束(triple constraint)</strong></p><ul><li>范围</li><li>时间</li><li>成本<br>有些人将质量与三项约束合称为 <strong>四项约束</strong></li></ul><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p><strong>project management</strong> 是指“在项目活动中运用专门的知识、技能、工具和技术，以满足项目需求”</p><h4 id="项目干系人"><a href="#项目干系人" class="headerlink" title="项目干系人"></a>项目干系人</h4><p><strong>stakeholder</strong> 是指参与项目或受项目活动影响的人，包括项目发起人、项目团队、支持人员、客户、使用者、供应商，甚至是项目的反对者</p><h4 id="项目管理知识领域"><a href="#项目管理知识领域" class="headerlink" title="项目管理知识领域"></a>项目管理知识领域</h4><p><strong>project management knowledge area</strong> 指的是项目经理必须具备的一些重要知识和能力</p><ul><li>项目范围管理</li><li>项目时间管理</li><li>项目成本管理</li><li>项目质量管理</li><li>项目人力资源管理</li><li>项目沟通管理</li><li>项目风险管理</li><li>项目采购管理</li><li>项目干系人管理</li><li>项目综合管理</li></ul><h4 id="项目管理工具和技术"><a href="#项目管理工具和技术" class="headerlink" title="项目管理工具和技术"></a>项目管理工具和技术</h4><p><strong>project management tool and technique</strong> 用来帮助项目经理和他们的团队进行十大知识领域的项目管理从而完成工作</p><ul><li>甘特图(Gantt chart)</li><li>项目网络图(project network diagram)</li><li>关键路径分析(critical path analysis)</li></ul><h4 id="项目成功的标准"><a href="#项目成功的标准" class="headerlink" title="项目成功的标准"></a>项目成功的标准</h4><ul><li>项目达到了范围、时间和成本目标</li><li>项目使客户或者项目发起人感到满意</li><li>项目的结果达到了主要目标</li></ul><h3 id="项目群和项目组合管理"><a href="#项目群和项目组合管理" class="headerlink" title="项目群和项目组合管理"></a>项目群和项目组合管理</h3><p><strong>program</strong> 是指“一组相互联系的项目，宜使用协同方法进行管理来获得收益和进行控制，而这种收益和控制在单独管理这些项目时是不易获得的”<br><strong>项目群经理program manager</strong> 对领导项目群内项目的项目经理进行领导并指明方向。同样会协调项目团队、职能部门、供应商和运营员工的努力，以支持项目并保证项目产品和过程达到最大的收益。<br><strong>项目组合管理project portfolio management</strong> 将项目以及项目群组合并进行管理，使其作为一个投资组合，从而促成整个企业的成功</p><ul><li>项目管理致力于 <strong>战术目标Tactical goals</strong> ，即为短期的更为具体的目标</li><li>项目组合管理致力于 <strong>战略目标Strategic goals</strong> ，即为一个组织的长期目标</li></ul><h3 id="项目经理"><a href="#项目经理" class="headerlink" title="项目经理"></a>项目经理</h3><h3 id="项目管理专业"><a href="#项目管理专业" class="headerlink" title="项目管理专业"></a>项目管理专业</h3><p><strong>甘特图Gantt chart</strong> 是一种标准格式，它通过在日程表上列出各种项目活动及各自的开始和结束的时间来显示项目的进度信息。<br><strong>关键路径critical path</strong> 就是网络图中最长的路径，它决定着一个项目最早完成的日期，显示了一个项目的哪些任务影响了目标完成日期，并且它可以随着工作进展和更多信息变得可用而发生改变。<br><strong>项目管理办公室project management office,PMO</strong> 是一个有组织的团队，负责协调整个组织中的项目管理功能。<br><strong>项目管理协会Project management Institute,PMI</strong> ，国际性的项目管理专业协会,PMI提供 <strong>项目管理师Project management Professional,PMP</strong> 职业认证。</p><hr><h2 id="项目管理和IT背景"><a href="#项目管理和IT背景" class="headerlink" title="项目管理和IT背景"></a>项目管理和IT背景</h2><h3 id="项目管理的系统观点"><a href="#项目管理的系统观点" class="headerlink" title="项目管理的系统观点"></a>项目管理的系统观点</h3><p><strong>系统思维system thinking</strong> 描述了在组织的背景中执行项目的整体观点。<br><strong>系统方法system approach</strong> 是指采用整体的和分析的方法来解决复杂问题，包括使用系统哲学、系统分析和系统管理等方法。<br><strong>系统哲学system philosophy</strong> 是一整套系统地思考事物的思维模式。<br><strong>系统System</strong> 是为达到某些目的而在一个环境中运行的、由相互作用的要素组成的集合。<br><strong>系统分析system analysis</strong> 是解决问题的一种方法，需要定义所研究系统的范围，然后将它分解成各个部分来确认与评估相应的问题、机会、约束和需求。<br><strong>系统管理system management</strong> 处理与系统的创建、维护和改变相关的业务、技术和组织问题。<br><strong>三球模型the three-sphere model</strong> 处理三类问题： <strong>业务business、组织organization、技术technology</strong></p><h3 id="组织问题"><a href="#组织问题" class="headerlink" title="组织问题"></a>组织问题</h3><h4 id="组织框架"><a href="#组织框架" class="headerlink" title="组织框架"></a>组织框架</h4><ul><li><strong>结构框架structural frame</strong> 角色和责任，合作，控制。</li><li><strong>人力资源框架human resources frame</strong> 在组织需要和人力需求之间进行协调。</li><li><strong>政治框架political frame</strong> 由不同个人和利益集团联合组成，冲突和权利是关键问题。</li><li><strong>符号框架symbolic frame</strong> 事件相关的符号和意义。文化、语言、传统以及形象是这个框架的所有部分。</li></ul><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p><strong>组织结构organization structure</strong> 一般分为三类：</p><ul><li><strong>职能型fuctional</strong></li><li><strong>项目型project</strong></li><li><strong>矩阵型matrix</strong></li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic1.png" alt=""><br><img src="/2018/05/02/项目管理-知识点总结/pic2.png" alt=""></p><h4 id="组织文化"><a href="#组织文化" class="headerlink" title="组织文化"></a>组织文化</h4><p><strong>organization culture</strong> 是一系列共同的能够刻画组织职能的设想、价值和行为<br>组织文化有10个特点：</p><ul><li>成员认同度member identity</li><li>团队专注度group emphasis</li><li>人员聚集度people focus</li><li>单元集成度unit integration</li><li>控制力control</li><li>抗风险能力risk tolerance</li><li>奖励标准reward criteria</li><li>抗冲突能力conflict tolerance</li><li>结果导向度means-ends orientation</li><li>开放系统聚集度open-systems focus</li></ul><h3 id="干系人管理"><a href="#干系人管理" class="headerlink" title="干系人管理"></a>干系人管理</h3><h4 id="高层管理承诺的重要性"><a href="#高层管理承诺的重要性" class="headerlink" title="高层管理承诺的重要性"></a>高层管理承诺的重要性</h4><p>一些项目有一个称为 <strong>倡导者champion</strong> 的高级经理，扮演着项目的关键支持者。<br><strong>Top management Commitment</strong> 对于项目经理来说至关重要。原因如下：</p><ul><li>项目经理需要足够的资源</li><li>项目经理经常需要及时得到对于特定项目需求的认可</li><li>项目经理必须与组织内其他部门的人进行合作</li><li>项目经理通常需要在领导力方面获得指导和帮助</li></ul><h4 id="组织对信息技术投入的需求"><a href="#组织对信息技术投入的需求" class="headerlink" title="组织对信息技术投入的需求"></a>组织对信息技术投入的需求</h4><p><strong>The Need for Organizational Commitment to Information Technology</strong><br><strong>首席信息官CIO</strong> ，公司为IT主管设立的副总裁或者相当的职位。</p><h4 id="组织对标准的需求"><a href="#组织对标准的需求" class="headerlink" title="组织对标准的需求"></a>组织对标准的需求</h4><p><strong>首席项目官CPO</strong> ，进一步增加项目管理的力度。</p><h3 id="项目阶段和项目生命周期"><a href="#项目阶段和项目生命周期" class="headerlink" title="项目阶段和项目生命周期"></a>项目阶段和项目生命周期</h3><p><strong>项目生命周期project life cycle</strong> 是一系列项目阶段的集合，定义了在每个阶段中要进行的工作，包括什么时候给出什么样的可交付成果，每个阶段涉及的人员和时间，以及管理层将如何控制和验证每个阶段中产生的工作。<br><strong>可交付成果deliverable</strong> 是一个产品或者服务，作为项目的一部分而生产或提供的。</p><blockquote><p>在项目生命周期的早期阶段，对资源的需求是最低的，而不确定性的程度是最高的。  </p></blockquote><p><strong>项目可行性project feasibility</strong> 是指前两个传统的项目阶段(概念和开发)关注计划编制。<br><strong>项目获取project acquisition</strong> 是指后两个阶段(实施和收尾)关注实际工作的交付。<br><strong>工作分解结构WBS</strong> 通过把工作分解成不同级别的任务粗略描述了项目的工作。<br><img src="/2018/05/02/项目管理-知识点总结/pic3.png" alt=""><br><img src="/2018/05/02/项目管理-知识点总结/pic4.png" alt=""><br><strong>系统开发生命周期system devalopment life cycle,SDLC</strong> 是一个描述开发信息系统不同阶段的框架。其通用模型都是 <strong>可预测生命周期predictive life cycle</strong> 的模型，意味着可以很明确地表达项目的范围，并且可以精确预测进度和成本。包括：</p><ul><li>瀑布模型waterfall model</li><li>螺旋模型spiral model</li><li>渐增式构建模型incremental build model</li><li>原型模型prototyping model</li><li>快速应用开发模型Rapid Application Development,RAD</li></ul><p><strong>自适应软件开发adaptive software Development,ASD</strong> 生命周期模型假定软件开发是遵循一种自适应的方法的，因为在生命周期的早期需求不能被清晰地描述。<br><strong>敏捷软件开发agile software Development</strong> 已经成为一种流行的新方法，强调开发团队和业务专家之间的紧密协作。<br>高层管理的评审通常称为 <strong>阶段出口Phase exit</strong> 或者 <strong>检查点kill point</strong> ，对于保持项目的进度以及决定是否应该继续、改变方向或者终止项目是非常重要的。</p><h3 id="IT项目的环境"><a href="#IT项目的环境" class="headerlink" title="IT项目的环境"></a>IT项目的环境</h3><ul><li>IT项目的本质<ul><li>IT项目可能有很多变化</li><li>IT项目同样支持每一种可能的行业和业务功能</li></ul></li><li>IT项目团队成员的特征</li><li>多样的技术</li></ul><h3 id="影响IT项目管理的最新趋势"><a href="#影响IT项目管理的最新趋势" class="headerlink" title="影响IT项目管理的最新趋势"></a>影响IT项目管理的最新趋势</h3><ul><li><strong>全球化globalization</strong> ，当运作全球化项目时，项目经理需要解决：<ul><li>沟通</li><li>信任</li><li>共同的工作方式</li><li>工具</li></ul></li><li><strong>外包outsourcing</strong> 即一个组织从外部寻找来源以获取需要的产品和服务； <strong>海外外包offshoring</strong> 用来描述安排在另外一个国家的外包(跨国完成的外包工作)。</li><li><strong>虚拟团队virtual team</strong> 是指运用通讯技术实现跨时间和跨地域工作的个人组成的团队</li></ul><p><strong>Scrum</strong> 是为了完成具有复杂的、创新的工作范围项目的一种领先的敏捷开发方法。</p><hr><h2 id="项目管理过程组"><a href="#项目管理过程组" class="headerlink" title="项目管理过程组"></a>项目管理过程组</h2><p><strong>过程process</strong> 是针对某一特定结果的一系列行动。<br><strong>项目管理过程组project management process group</strong> 包括：</p><ul><li><strong>预启动</strong>：商业论证business case</li><li><strong>启动过程initiating process</strong> 包括定义和批准项目或者项目阶段。</li><li><strong>计划过程planning process</strong> 包括制定和维护一个可执行的计划，以保证项目满足组织的要求。其 <strong>输出</strong> 包括要完成项目范围说明、工作分解结构、项目进度表和其他内容</li><li><strong>执行过程executing process</strong> 包括协调人力和其他资源来执行项目的计划，以产生项目或者项目阶段的产品、服务或者结果。其 <strong>主要成果</strong> 是产生项目的实际工作。</li><li><strong>监控过程monitoring and controlling process</strong> 包括有规律地测量和监视项目进展，以保证项目团队能够满足项目目标。其 <strong>理想产出</strong> 是通过交付满足时间、成本和质量约束的项目来成功地完成项目。</li><li><strong>收尾过程closing process</strong> 包括对项目或者项目阶段的正式验收，并有效地终止。其 <strong>关键产出</strong> 是工作的正式验收和结束文档的撰写。</li></ul><blockquote><p>通常执行过程是最需要资源和时间的，其次是计划过程。启动和收尾过程通常是最短的，要求资源和时间也最少。</p></blockquote><p><strong>将过程组映射到知识领域</strong><br><img src="/2018/05/02/项目管理-知识点总结/pic5.png" alt=""><br><strong>方法学methodology</strong> 描述应该如何去做事情，不同的组织通常有不同做事方式。</p><ul><li>受控环境下的项目管理(PRINCE2)：定义了45个独立子进程，并将它们分为8个过程组</li><li>敏捷方法:一般用于 <strong>项目业务团队在产品生命周期早期不能清楚表达项目范围，但团队确实想在项目早期而不是后期提供一个潜在的可交付产品</strong> 的这类项目。</li><li>统一软件开发过程(RUP)框架：迭代的软件开发过程</li><li>六西格码方法论：DMAIC、DMADV</li></ul><hr><h2 id="项目综合管理"><a href="#项目综合管理" class="headerlink" title="项目综合管理"></a>项目综合管理</h2><p><strong>项目综合管理project integration management</strong> 涉及在整个项目生命周期中协调所有其他项目管理的知识领域。主要包括：</p><ul><li><strong>制定项目章程Developing the project charter</strong></li><li><strong>开发项目管理计划Developing the project management plan</strong></li><li><strong>指挥并管理项目执行Directing and managing project work</strong></li><li><strong>监控项目工作monitoring and controlling project work</strong></li><li><strong>综合变更控制performing integrated change control</strong></li><li><strong>项目或阶段收尾Closing the project or phase</strong></li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic6.png" alt=""><br>项目综合管理包括 <strong>接口管理interface management</strong> ，涉及识别和管理项目众多要素间相互作用的交接点。随着参与项目的人数的增加，这种接口的数量会呈指数增加。因此项目经理需要建立并维持组织界面间良好沟通和关系。</p><h3 id="战略计划与项目选择"><a href="#战略计划与项目选择" class="headerlink" title="战略计划与项目选择"></a>战略计划与项目选择</h3><p><strong>战略计划strategic planning</strong> 包括通过分析组织的优势和劣势，研究在商业环境中的机会和威胁，预测未来的趋势，以及预测对新产品和新服务的需求来确定长期目标。<br><strong>SWOT分析</strong> 包括分析 <strong>优势strength、劣势weakness、机会opportunity、威胁threat</strong> 。<br>SWOT分析的流行方法有 <strong>思维导图mind mapping</strong> ，是一种结构分解的技术，通过从一种核心理念发散出来的方式将想法和概念结构化。<br><img src="/2018/05/02/项目管理-知识点总结/pic17.png" alt=""></p><p><strong>选择项目的方法</strong> ：</p><ul><li>聚焦于广泛的组织需求:确定它们是否满足 <strong>需求need、资金funding、意愿will</strong></li><li>将IT项目分类<ul><li><strong>问题problem</strong> 是人们不期望出现的那些造成组织无法实现其目标的情况。</li><li><strong>机遇opportunity</strong> 是改善组织的机会。</li><li><strong>指示directive</strong> 是由管理层、政府或者某些外部影响施加的新要求。</li></ul></li><li>进行净现值分析、投资回报率和投资回收期分析<ul><li><strong>净现值NPV分析</strong> 就是一种计算预期净货币收益或损失的方法，该计算方法将当前时间点之后的所有未来预期现金流入和流出都作折现计算。NPV分析是一种对持续多年项目的现金流的一种公平比较。正的NPV值意味着一个项目的回报超过了其 <strong>资本成本cost of capital</strong> ，即把资金投资在别的地方可以获得的回报。在其他因素都一样的情况下，具有较高NPV值的项目比具有较低NPV值的项目更理想。<br>要确定NPV，按照以下步骤进行：<ul><li>为项目生命周期和其产出的产品确定预期成本和收益</li><li>确定 <strong>折现率discount rate</strong> ，将未来现金流折现的比率，也称为 <strong>资本率capitalization rate、资本的机会成本opportunity cost of capital</strong></li><li>计算NPV<br>$NPV=\sum_{t=0…n}A_t/(1+r)^t$，其中t为现金流的某年，n为现金流的最后一年，A是每年的现金流数目，r是折现率。</li></ul></li><li><strong>投资回报率ROI</strong> 是项目的收益减去成本并处以成本的结果。<br><strong>ROI=(折现收益总额-折现成本总额)/折现成本</strong><br><strong>要求回报率required rate of return</strong> 是每项投资中要求要达到的最低回报率。<br>通过发现导致项目的NPV为0的折现率，来确定投资的 <strong>内部收益率IRR</strong></li><li><strong>投资回收期分析payback period</strong> 是指净现金流的形式补偿项目总的投资所需要的时间，换言之，就是确定需经过多长时间累积收益等于累积成本以及后续成本。</li></ul></li><li>使用加权评分模型<br><strong>weighted scoring model</strong> 是一种基于多种标准进行项目选择的系统方法</li><li>实施平衡记分卡<br><strong>balanced scorecard</strong> 是一种方法论，将组织的价值驱动因素转换成一组定义好的衡量维度。</li></ul><p><strong>制定项目章程project charter</strong> ，用来正式确认项目存在并明确项目目标和项目管理的一种文件。启动过程的主要输出为项目章程，可以有以下输入：</p><ul><li><strong>项目工作说明书a project statement of work</strong></li><li><strong>商业论证a business case</strong></li><li><strong>合同agreements</strong></li><li><strong>企业环境因素enterprise environmental factors</strong></li><li><strong>组织过程资产信息organizational process assets</strong></li></ul><h3 id="创建项目管理计划"><a href="#创建项目管理计划" class="headerlink" title="创建项目管理计划"></a>创建项目管理计划</h3><p><strong>project management plan</strong> 是用于协调所有项目计划文档，并帮助指导项目的执行和控制的一种文件。项目管理计划应该是动态的、灵活的，并且随着环境或项目的变化而变化。</p><h3 id="指导和管理项目实施"><a href="#指导和管理项目实施" class="headerlink" title="指导和管理项目实施"></a>指导和管理项目实施</h3><p>主要内容是管理和实施在项目管理计划中确定的工作，还包括批准的变更请求、企业环境因素以及组织过程资产。</p><ul><li>协调计划和执行</li><li>提供强大领导力和支持性文化</li><li>利用产品、业务和应用领域知识</li><li>项目执行工具和技术<ul><li>专家评审法</li><li>会议</li><li>项目管理信息系统</li></ul></li></ul><h3 id="监控项目工作"><a href="#监控项目工作" class="headerlink" title="监控项目工作"></a>监控项目工作</h3><p>包括收集、衡量与发布绩效信息。还涉及评估度量与分析趋势以确定可以做出怎样的过程优化。<br><strong>基线baseline</strong> 是批准的项目管理计划加上批准的变更。<br><strong>重要输入：</strong></p><ul><li>项目管理计划</li><li>进度表</li><li>成本预算</li><li>变更确认</li><li>工作绩效信息</li><li>企业环境因素</li><li>组织过程资产</li></ul><p><strong>重要输出是：</strong></p><ul><li>变更请求<ul><li>推荐的纠正措施</li><li>预防措施</li><li>缺陷补救措施</li></ul></li><li>工作绩效报告</li></ul><h3 id="执行综合变更控制"><a href="#执行综合变更控制" class="headerlink" title="执行综合变更控制"></a>执行综合变更控制</h3><p><strong>综合变更控制integrated change control</strong> 涉及在项目的全生命周期中识别、评估及管理变更。主要的3个目标：</p><ul><li>影响那些产生变更的因素以确保变更都是有利的</li><li>确定一个变更已经出现过</li><li>及时地管理真正的变更</li></ul><p><strong>重要输入：</strong></p><ul><li>项目管理计划</li><li>工作绩效信息</li><li>变更请求</li><li>企业环境因素</li><li>组织过程资产</li></ul><p><strong>重要输出：</strong></p><ul><li>被批准的变更请求</li><li>变更日志</li><li>项目管理计划</li><li>文档的更新</li></ul><p><strong>变更控制系统change control system</strong> 是一个正式的、文档化的过程，描述了正式文档何时以及如何可以被变更。包括;</p><ul><li><strong>变更控制委员会change control board,CCB</strong> 是负责批准或否决项目变更的正式团体，主要职责是为准备变更请求提供指南、评价变更请求以及管理和实施核准的变更。</li><li><strong>配置管理configuration management</strong> 确保关于项目产品的描述是正确且完整的。</li><li><strong>用于沟通变更的流程</strong></li></ul><h3 id="项目或阶段收尾"><a href="#项目或阶段收尾" class="headerlink" title="项目或阶段收尾"></a>项目或阶段收尾</h3><p>将所有活动终止，并将已完成或取消的工作移交给适当的人员。<br><strong>主要输入：</strong></p><ul><li>项目管理计划</li><li>已接受的交付物</li><li>组织过程资产</li></ul><p><strong>主要工具和技术：</strong> 专家评审<br><strong>主要输出：</strong></p><ul><li>最终产品、服务或成果转移</li><li>组织过程资产更新</li></ul><p><strong>业务服务管理business service management,BSM</strong> 有助于将项目与企业战略相匹配的工具。</p><hr><h2 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h2><p><strong>范围scope</strong> 是指开发项目产品所涉及的所有工作和用来开展工作的所有过程。<br><strong>可交付成果deliverable</strong> 指作为项目的一部分而生产的产品。<br><strong>项目范围管理project scope management</strong> 是指对项目包括什么与不包括什么的界定和控制的过程。</p><ul><li><strong>制定范围管理计划</strong> 是指确定项目的范围和需求如何管理。<strong>输出</strong> 是范围管理计划和需求管理计划。</li><li><strong>收集需求collecting requirement</strong> 是指定义并记录项目最终产品的特点和功能，以及创造这些产品的过程。<strong>输出</strong> 是项目团队编制的需求文档和需求跟踪矩阵。<ul><li>通常是最困难的。</li><li>收集方法：原型法和文档分析法</li><li><strong>基准测试bench marking</strong> 是通过与执行组织的内部或外部的其他项目或产品进行比较，以获得具体项目实践或产品特征的需求思想。</li><li><strong>需求跟踪矩阵Requirement Traceability Matrix,RTM</strong> 是列出各种需求、需求属性和需求状态的一种表格，以确保所有需求被跟踪。</li></ul></li><li><strong>定义范围scope definition</strong> 是指评审范围管理计划、项目章程、需求文档和组织过程资产来创建一份范围说明书，并且随着需求的扩展和变更请求得到批准而增加更多的信息。<strong>输出</strong> 是项目范围说明书以及项目文档的更新。</li><li><strong>创建工作分解结构creating the WBS</strong> 是指将主要的项目可交付成果分解成更细小更易管理的部分。<strong>输出</strong> 是范围基线(工作分解结构、WBS词典)及项目文档的更新<ul><li><strong>WBS</strong> 是对项目所涉及工作面向交付成果的分组，定义了项目的全部范围。</li><li><strong>WBS分级</strong><ul><li>层级1：项目名称</li><li>层级2：工作分组，“概念”</li><li>层级3：定义需求</li><li>层级4：定义用户需求、(工作包)</li></ul></li><li><strong>工作包work package</strong> 即为WBS最底层的一项任务。</li><li>制作WBS的方法：<ul><li><strong>使用指南</strong></li><li><strong>类比法analogy approach</strong></li><li><strong>自上而下法top-down approach</strong> ，从项目最大条目开始，将它们分解为次一级的条目。</li><li><strong>自下而上法bottom-up approach</strong> ，先识别尽可能多的与项目有关的具体任务，再将这些具体任务集中并组织成概要任务或WBS中较高层次。</li><li><strong>思维导图法</strong></li></ul></li><li><strong>WBS字典dictionary</strong> 是一个描述WBS每项条目详细信息的文件。</li></ul></li><li><strong>验证范围validation scope</strong> 是指项目可交付成果的正式接受。<strong>输出</strong> 是被接受的可交付成果、变更请求、工作绩效信息以及项目文档更新。<ul><li><strong>范围蔓延scope creep</strong> 项目范围不断扩大的趋势。</li></ul></li><li><strong>控制范围controlling scope</strong> 是指对整个项目生命周期内的范围变化进行控制。<strong>输出</strong> 是工作绩效信息、变更请求、项目管理计划、项目文档和组织过程资产的更新。<ul><li>主要工具：实施偏差分析。<strong>偏差variance</strong> 是计划的与实际的效果之间的区别。</li><li>对于减少不完善和不断变化的需求的建议：<ul><li><strong>原型开发prototyping</strong> 是指开发系统或者系统的某些方面的可运行的副本，以帮助定义用户需求。</li><li><strong>用例建模</strong> 是一种对业务事件、启动者及系统响应方式进行识别与建模的过程。</li><li><strong>联合应用设计JAD</strong> 使用高度组织化和集中式的工作会议将项目干系人结合起来共同定义设计信息系统。</li></ul></li></ul></li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic7.png" alt=""></p><hr><h2 id="项目时间管理"><a href="#项目时间管理" class="headerlink" title="项目时间管理"></a>项目时间管理</h2><p><strong>project time management</strong> 就是确保项目按时完成所需的过程。</p><ul><li><strong>计划进度管理</strong> 是指确定将用于计划、执行和控制项目进度的政策、流程和文档。<strong>输出</strong> 是进度管理计划。<ul><li>项目进度模型的开发</li><li>在开发项目进度模型中使用的方法和工具：关键路径和关键链方法</li><li>精度水平和计量单位</li><li>控制阈值</li><li>性能测量的规划</li><li>报告格式</li><li>过程描述</li></ul></li><li><strong>定义活动</strong> 是指识别项目团队成员和干系人必须执行并产生项目的可交付成果的特定活动。<strong>活动activity或任务task</strong> 是工作的组成要素，通常出现在WBS中，有预计的工期、成本和资源要求。<strong>输出</strong> 是活动清单、活动属性、里程碑清单和更新的项目管理计划。<ul><li><strong>活动清单activity list</strong> 是包含在项目进度中的活动列表，包括活动名称、活动标识以及活动的简短描述。</li><li><strong>活动属性activity attribute</strong> 提供了与进度相关的更多信息，例如前导活动predecessors、后继活动successors、逻辑关系logical relationships等。</li><li><strong>项目的里程碑milestone</strong> 是项目中一个通常没有工期的重要事件。</li><li>活动定义过程的目标是保证项目团队完全理解他们必须做的所有工作是作为项目范围的一部分，以便他们能够开始安排工作进度。</li></ul></li><li><strong>排序活动</strong> 是指识别和记录项目活动之间的依赖关系。<strong>输出</strong> 是项目的进度网络图和更新的项目文档。<ul><li><strong>依赖dependency或关系relationship</strong> 与项目活动或任务的排序相关。</li><li>为项目活动之间创建依赖关系有三个基本原因：<ul><li><strong>强调依赖mandatory dependencies</strong> 是项目工作中内在的一种关系。某些时候称为 <strong>硬逻辑</strong></li><li><strong>自由依赖discretionary dependencies</strong> 是由项目团队定义的项目活动之间的关系</li><li><strong>外部依赖external dependencies</strong> 涉及项目和非项目活动之间的关系</li></ul></li><li><strong>网络图network diagram</strong> 是表示活动排序的首选技术，是项目活动之间的逻辑关系或者顺序的示意性的表示。<ul><li>网络图的格式使用的是 <strong>双代号网络图AOA或者箭线图法ADM</strong></li><li>网络图表示的是那些完成项目所必须执行的活动。</li><li>并不是WBS的每个项都出现在网络图上，只有与活动有关的依赖项需要显示</li><li><strong>前导图法PDM</strong> 也是一种网络图技术，使用方框表示活动</li><li>活动间的4种类型的依赖或者关系：<ul><li>完成-开始(finish-to-start)</li><li>开始-开始(start-to-start)</li><li>完成-完成(finish-to-finish)</li><li>开始-完成(start-to-finish)</li></ul></li><li>前导图比AOA网络图的优势所在:<ul><li>多数的项目管理软件使用前导图</li><li>前导图法避免了 <strong>虚活动dummy activity</strong> 的需要</li></ul></li></ul></li></ul></li><li><strong>估算活动资源</strong> 是指估算一个项目团队应该使用多少资源(人力、设备和原料)来执行项目活动。<strong>输出</strong> 是活动资源需求、资源分解结构(resource breakdown structure)和更新的项目文档。</li><li><strong>估算活动工期</strong> 是指估算完成单项活动所需的工作时间。<strong>输出</strong> 是活动工期估算和更新的项目文档。<ul><li><strong>工期duration</strong> 包括活动上花费的实际时间和占用时间。</li><li>工期估算：离散的数字、时间范围、<strong>三点估算three-point estimate</strong> 包括乐观、最可能和悲观的估算。</li></ul></li><li><p><strong>制定进度计划</strong> 是指分析活动序列、活动资源估算和活动工期估算来创建项目进度。<strong>输出</strong> 是进度基线、项目进度、进度数据、项目日历、更新的项目管理计划和更新的项目文件。</p><ul><li><strong>甘特图Gantt chart</strong><ul><li>在甘特图上增加里程碑。根据 <strong>SMART准则</strong> ，里程碑应当是;<ul><li>明确的specific</li><li>可度量的measurable</li><li>可分配的assignable</li><li>现实的realistic</li><li>有时间限制的time-framed</li></ul></li><li>使用跟踪甘特图来比较计划和实际的日期<ul><li><strong>跟踪甘特图tracking Gantt chart</strong> 一个比较计划和实际项目进度信息的甘特图。</li><li><strong>基线日期baseline date</strong> 活动的计划进度日期</li><li><strong>进度基线schedule baseline</strong> 整个经过审批的计划进度</li><li><strong>偏移的里程碑slipped milestone</strong> 意味着里程碑活动的实际完成时间比原来计划的要晚。白色菱形white diamond</li></ul></li></ul></li><li><p><strong>关键路径法critical path method,CPM</strong> 又称为 <strong>关键路径分析</strong> ，是一种网络图技术，用来预测整个项目的工期。</p><ul><li>项目的 <strong>关键路径</strong> 决定了项目最早完成时间的活动序列，是网络图的最长路径，其时差或者浮动时间最少。</li><li><strong>时差slack或者浮动时间float</strong> 指的是在不延误后继活动或者项目完成时间的情况下，任务可以推后的时间。</li><li><p>使用关键路径分析来保持进度均衡</p><ul><li><strong>自由时差free slack或者自由浮动时间free float</strong> 是一个活动在不延误紧接活动的最早开始时间的情况下可以被延误的时间。</li><li>一个活动的 <strong>最早开始时间early start date</strong> 是基于项目网络逻辑可以开始的最早的可能时间。</li><li><strong>总时差total slack或者总浮动时间</strong> 是一个活动从它最早开始时间起，在没有拖延计划项目完成日期的情况下被耽搁的时间。</li><li>利用正推和逆推计算自由时差和总时差<ul><li><strong>正推法forward pass</strong> 决定每个活动的最早开始和最早完成时间。一个活动的 <strong>最早完成时间early finish date</strong> 是基于项目网络逻辑最早可能完成的时间，最早开始时间加上第一个活动的工期就等于第一个活动的最早完成时间。</li><li><strong>逆推法backward pass</strong> 可决定最晚开始和最晚完成时间。一个活动的的 <strong>最晚开始时间late start date</strong> 是一个活动在不延迟项目完成时间的最晚可能开始的时间；一个活动的 <strong>最晚完成时间late finish date</strong> 是一个活动在不延迟项目完成时间的最晚可能完成的时间。</li></ul></li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic9.png" alt=""></p></li><li>使用关键路径来缩短项目的进度<ul><li><strong>赶工crashing</strong> 是一种为了以最少的成本最大限度地压缩工期，而在成本与进度之间进行均衡的技术。</li><li><strong>快速跟进fast tracking</strong> 包括并行执行那些通常以顺序方式执行的活动。</li></ul></li></ul></li><li><strong>关键链调度critical chain scheduling</strong> 是一种进度计划方法，在创建项目进度时考虑有限的资源，并且将缓冲包括进来以保护项目完成期限。<ul><li><strong>约束理论TOC</strong></li><li><strong>多任务multitasking</strong> 发生在一个资源在同一时间用于多个任务的时候。</li><li>使用关键链调度时，提高项目完成时间：<ul><li><strong>项目缓冲project buffer</strong> 在项目的完工日期之前增加的附加时间。</li><li><strong>汇入缓冲feeding buffer</strong> 指的是在那些前导是非关键路径任务的关键链任务之前增加的附加时间。</li></ul></li></ul></li><li><strong>计划评审技术PERT</strong><br>PERT使用 <strong>概率时间估算probabilistic time estimate</strong><br><strong>PERT加权平均=(乐观时间+4*最可能时间+悲观时间)/6</strong></li></ul></li><li><strong>控制进度</strong> 是指控制和管理项目进度的变更。<strong>输出</strong> 是工作绩效信息、进度预测、请求变更、项目管理计划的更新、项目文档的更新和组织过程资产的更新。</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic8.png" alt=""></p><hr><h2 id="项目成本管理"><a href="#项目成本管理" class="headerlink" title="项目成本管理"></a>项目成本管理</h2><p><strong>project cost management</strong> 包括用来确保在批准的预算范围内完成项目的必要过程。有4个过程：</p><ul><li>计划成本管理：包括确定用于计划、执行、控制项目成本的政策、程序和文档。<strong>输出</strong> 是成本管理计划。</li><li>成本估算：包括完成项目所需资源的近似或估算成本。<strong>输出</strong> 是活动的成本估算、估算的基础和更新的项目文档。</li><li>确定估算：包括将整体成本估算配置到各单项工作，以建立一个衡量绩效的基线。<strong>输出</strong> 是成本基线、项目资金需求和更新的项目文档。</li><li>成本控制：包括控制项目预算的变更。<br><img src="/2018/05/02/项目管理-知识点总结/pic10.png" alt=""></li></ul><h3 id="成本管理"><a href="#成本管理" class="headerlink" title="成本管理"></a>成本管理</h3><p><strong>利润profit</strong> 是收入减去支出。<br><strong>利润率profit margin</strong> 是利润和收入的比值。<br><strong>生命周期成本life cycle costing</strong> 是对贯穿于整个项目生命周期的成本状况的总体认识。<br><strong>现金流分析cash flow analysis</strong> 是用于确定项目每年的估计成本和收益以及由此产生的年度现金流的一种方法。<br><strong>有形成本或有形收益tangible costs or benefits</strong> 是能够容易地用货币来衡量的成本或收益。<br><strong>无形成本或无形收益intangible</strong> 是那种很难用货币来衡量成本或收益。<br><strong>直接成本direct costs</strong> 是与项目的产品和服务的生产直接相关的成本。例如工作人员的薪金，软硬件的成本等，可控的。<br><strong>间接成本indirect costs</strong> 是与项目的产品和服务的生产不直接相关的成本，但是间接地与项目的绩效挂钩。例如电力费用、纸巾等，不可控的。<br><strong>沉没成本sunk costs</strong> 是过去已经花掉的钱。<br><strong>学习曲线理论learning curve theory</strong> 指出当重复生产许多产品时，那些产品的单位成本随着数量的增多而呈现规律性的递减。<br><strong>储备金reserves</strong> 是包含于成本估算中，为减轻未来难以预测情形带来的成本风险而准备的那部分资金。<br><strong>应急储备金contingency reserves</strong> 是为一些可以部分预计的未来情况(也称已知的不确定事件)做准备，包含于项目的成本基线中。<br><strong>管理储备金management reserves</strong> 是为不能预测的未来情况(也称未知的不确定事件)做准备。</p><h3 id="计划成本管理"><a href="#计划成本管理" class="headerlink" title="计划成本管理"></a>计划成本管理</h3><p>成本管理计划包括：</p><ul><li>精确度</li><li>测量单位</li><li>组织程序链接</li><li>控制临界值</li><li>绩效测量规划</li><li>报告模板</li><li>过程描述</li></ul><h3 id="成本估算"><a href="#成本估算" class="headerlink" title="成本估算"></a>成本估算</h3><p>三种基本的成本估算类型：</p><ul><li>粗粒度估算rough order of magnitude,ROM 提供了项目成本的一个粗略估算。</li><li>预算估算budgetary estimate 用于将资金分配到组织的预算中。</li><li>确定性估算definitive estimate 提供一个精确的项目成本估算</li></ul><p>成本估算的工具和技术</p><ul><li>专家判断</li><li>类比成本估算</li><li>自下而上估算</li><li>三点估算</li><li>参数估算</li><li>质量成本</li><li>项目管理估算软件</li><li>供应商报价分析和储备分析</li></ul><h3 id="成本预算"><a href="#成本预算" class="headerlink" title="成本预算"></a>成本预算</h3><p>成本预算涉及将项目成本估算随时间分配给个体材料资源或单个工作项，这些个体材料资源或工作项是以项目工作分解结构为基础的。成本预算的目的就是编制一个成本基线，用来衡量项目绩效和资金需求。<br><strong>成本基线</strong> 是分时段的预算，项目经理用它来衡量和监控成本性能。</p><h3 id="成本控制"><a href="#成本控制" class="headerlink" title="成本控制"></a>成本控制</h3><p>项目成本控制包括检测成本执行情况、确保一个修改的成本基线中仅仅包括适当的项目变更，以及通知项目干系人那些经核准、影响成本的项目变更。<br><strong>挣值管理earned value management,EVM</strong> 是一个成本控制工具，综合了项目范围、时间和成本数据的项目绩效测量技术。其涉及WBS中的三个值：</p><ul><li><strong>计划值planned value,PV</strong> 也叫预算，是在给定时间内计划花费在某个活动上的已批准总成本估算的部分。</li><li><strong>实际成本actual cost,AC</strong> 是在给定时间内，完成一项活动所产生的直接成本和间接成本的总和。</li><li><strong>挣值earned value,EV</strong> 是实际完成工作的估算值。它是基于项目或活动初始计划成本的，是项目组当前实际完成工作的比率。<strong>完成百分比rate of performance,RP</strong> 是实际完成工作与在项目或活动周期给定时间内已完成计划工作的比率。</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic11.png" alt=""></p><hr><h2 id="项目质量管理"><a href="#项目质量管理" class="headerlink" title="项目质量管理"></a>项目质量管理</h2><p><strong>需求一致性conformance to requirement</strong> 是指项目过程和产品满足书面规范的要求。<br><strong>适用性fitness for use</strong> 是指产品能像它被预期的那样使用。<br><strong>项目质量管理</strong> 的目的是确保项目满足它所应满足的需求。客户是质量是否可接受的最终裁判者。项目质量管理有三个主要过程：</p><ul><li><strong>计划质量管理planning quality management</strong> 包括确认与项目有关的质量需求和标准以及如何满足它们。<strong>输出</strong> 是质量管理计划、过程改进计划、质量度量、质量检查表和项目文档更新。<strong>度量标准metric</strong> 是一个测量的标准，包括产品故障率、产品和服务的可行性以及客户满意度。</li><li><strong>实施质量保证</strong> 包括对整个项目绩效进行定期的评估以确保项目能够满足相关的质量标准。<strong>输出</strong> 是变更请求、项目管理计划更新、项目文档更新和组织过程资产更新。</li><li><strong>控制质量</strong> 包括监控特定的项目结果，确保它们遵循相关质量标准，并确定提高整体质量的方法。工具和技术：<strong>帕累托图、质量控制图、统计抽样</strong> ，<strong>输出</strong> 是质量控制度量、有效的变更、有效的可交付成果、工作绩效信息、变更请求、项目管理计划更新、项目文档更新和组织过程资产更新。</li></ul><h3 id="计划质量管理"><a href="#计划质量管理" class="headerlink" title="计划质量管理"></a>计划质量管理</h3><p><strong>实验设计design of experiment</strong> 是一种质量计划技术，用以帮助确认哪个变量对一个过程的整体结果影响最大。<br>IT项目中影响质量的重要范围部分包括：</p><ul><li><strong>功能性functionality</strong> 是一个系统执行其预定功能的程度。<strong>特色feature</strong> 是吸引用户的系统特性。</li><li><strong>系统输出system output</strong> 是系统产生的界面和报告</li><li><strong>性能performance</strong> 是一个产品或服务如何有效执行客户预期的功能。</li><li><strong>可靠性reliability</strong> 是指一个产品或服务在正常条件下表现出符合预期情况的能力。</li><li><strong>可维护性maintainability</strong> 说明进行产品维护的容易程度。</li></ul><h3 id="质量保证"><a href="#质量保证" class="headerlink" title="质量保证"></a>质量保证</h3><p><strong>质量保证quality assurance</strong> 包括满足一个项目相应质量标准的所有相关活动。<br><strong>持续改善kaizen</strong> 是一个日语词汇，意指更好的改善和改变<br><strong>精益lean</strong> 的目的是实现客户价值最大化，同时尽量减少浪费。<br>几个工具用于质量保证：</p><ul><li>实验设计</li><li>基准比较法benchmarking</li><li>质量审计quality audit</li></ul><h3 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h3><p>主要输出：</p><ul><li><strong>验收决策acceptance decision</strong> 确定作为项目的一部分而生产的产品或服务是否通过验收的决策。</li><li><strong>返工rework</strong> 指为使被拒收的项目达到和满足产品需求、规范或干系人的其他期望而采取的行动。</li><li><strong>过程调整process adjustment</strong> 指根据质量控制的度量结果，纠正或防止进一步的质量问题而作的调整。</li></ul><p>用于质量控制的工具和技术：</p><ul><li>七种质量工具<ul><li>因果图cause-and-effect diagram 或者 鱼骨图fishbone diagram 或者 石川图Ishikawa diagram</li><li>控制图control chart、七点运行法则seven run rule(星号表示)</li><li>检查表checksheet</li><li>散点图scatter diagram</li><li>直方图histogram</li><li>帕累托图pareto diagram、帕累托分析又称为80-20法则</li><li>流程图flowchart</li></ul></li><li>统计抽样statistical sampling</li><li>六西格玛法则<br>应用六西格玛进行质量控制的项目通常遵循称为DMAIC的五阶段改进流程：<ul><li>界定define</li><li>度量measure</li><li>分析analyze</li><li>改进improve</li><li>控制control</li></ul></li></ul><h3 id="现代质量管理"><a href="#现代质量管理" class="headerlink" title="现代质量管理"></a>现代质量管理</h3><h3 id="提高IT项目质量"><a href="#提高IT项目质量" class="headerlink" title="提高IT项目质量"></a>提高IT项目质量</h3><ul><li>领导</li><li>质量成本：是一致成本加上不一致成本。<ul><li>一致conformance 指交付满足要求的和适用的产品</li><li>不一致成本cost of nonconformance 指对故障或没有满足质量期望负责<br>与质量相关的5类主要成本：</li><li>预防成本prevention cost</li><li>评估成本appraisal cost</li><li>内部故障成本internal failure cost</li><li>外部故障成本external failure cost</li><li>测量和测试设备成本</li></ul></li><li>组织影响、工作环境因素和质量</li><li>质量中的期望与文化差异</li><li>成熟度模型maturity model<ul><li>软件质量功能配置模型software quality function deployment(SQFD)model</li><li>能力成熟度模型集成capability maturity model integration,CMMI</li><li>项目管理成熟度模型OPM3</li></ul></li></ul><hr><h2 id="项目人力资源管理"><a href="#项目人力资源管理" class="headerlink" title="项目人力资源管理"></a>项目人力资源管理</h2><p>项目人力资源管理就是最有效地发挥每个参与项目人员的作用的过程。包括：</p><ul><li>计划人力资源管理</li><li>组建项目团队</li><li>建设项目团队</li><li>管理项目团队</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic12.png" alt=""></p><h3 id="制定人力资源计划"><a href="#制定人力资源计划" class="headerlink" title="制定人力资源计划"></a>制定人力资源计划</h3><ul><li>项目组织结构图：组织分解结构OBS</li><li>责任分配矩阵RAM：就是将WBS中描述的项目工作与OBS中负责实施的人员相匹配的矩阵<ul><li>责任人responsibility</li><li>批准人accountability</li><li>审核人consultation</li><li>告知人informed</li></ul></li><li>人员配置管理计划staffing management plan和资源直方图resource histogram</li></ul><h3 id="组建项目团队"><a href="#组建项目团队" class="headerlink" title="组建项目团队"></a>组建项目团队</h3><ul><li>人力资源分配</li><li>资源负荷resource loading：是指在特定时段内，既定进度计划所需的个体资源的数量。<ul><li>过度分配overallocation:是指在给定时间内分配给某项工作的资源超过了它可用的资源。</li></ul></li><li>资源平衡resource leveling</li></ul><h3 id="建设项目团队"><a href="#建设项目团队" class="headerlink" title="建设项目团队"></a>建设项目团队</h3><p>团队建设team development的主要目标是帮助人们更有效地一起工作来提高项目绩效</p><ul><li>培训</li><li>团队建设活动<ul><li>梅耶斯-布里格性格类型指示器MBTI</li><li>社交类型模型</li><li>DISC模型</li></ul></li><li>奖励和赏识系统</li></ul><h3 id="管理项目团队"><a href="#管理项目团队" class="headerlink" title="管理项目团队"></a>管理项目团队</h3><p>管理项目团队的工具和技术：</p><ul><li>观察与交谈</li><li>项目绩效评价</li><li>人际技能</li><li>冲突管理</li></ul><hr><h2 id="项目沟通管理"><a href="#项目沟通管理" class="headerlink" title="项目沟通管理"></a>项目沟通管理</h2><p>项目沟通管理的目标是确保项目信息能够及时且适当地生成、收集、发送、存储和部署</p><ul><li>计划沟通管理</li><li>管理沟通<ul><li>用技术手段加强信息的创建和分配</li><li>选择适当的沟通方法和媒介<ul><li>互动沟通</li><li>推送沟通</li><li>拉式沟通</li></ul></li><li>报告绩效<ul><li>状态报告status report</li><li>进度报告progress report</li></ul></li></ul></li><li>控制沟通</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic13.png" alt=""></p><hr><h2 id="项目风险管理"><a href="#项目风险管理" class="headerlink" title="项目风险管理"></a>项目风险管理</h2><p>项目风险管理是关于识别、分析、响应项目全生命周期内的风险，并最好地满足项目目标的科学与艺术。<br><strong>风险偏好risk appetite</strong> 是指实体为了获得期望的回报愿意承担的不确定性程度。<br><strong>风险承受力risk tolerance</strong> 是指在项目或业务目标的潜在影响中实体能够接受的最大的偏差。<br><strong>风险效用risk utility</strong> 是指从潜在回报中得到的满意度。分为：</p><ul><li><strong>风险厌恶型risk-averse</strong></li><li><strong>风险喜好型risk-seeking</strong></li><li><strong>风险中性型risk-neutral</strong></li></ul><p>风险管理涉及的6个主要过程：</p><ul><li>计划风险管理<ul><li>风险管理计划</li><li>应急计划contingency plan</li><li>退路计划fallback plan</li><li>应急储备金contingency或者应急津贴contingency allowance</li></ul></li><li>识别风险<br><strong>风险分解结构</strong> 用来帮助考虑各类潜在风险的工具。<ul><li>识别风险的技术：<ul><li><strong>头脑风暴brainstorming</strong></li><li><strong>德尔菲技术Delphi technique</strong></li><li><strong>访谈interviewing</strong></li><li><strong>SWOT分析</strong></li><li>检查表</li><li>假设分析</li><li>创建图表</li></ul></li><li><strong>风险登记表risk register</strong> 是一份包含了各个风险管理过程结果的文档。</li></ul></li><li>实施定性风险分析<ul><li>使用 <strong>概率/影响矩阵</strong> 计算 <strong>风险因子</strong></li><li>风险定性分析工具：<strong>十大风险事项跟踪</strong></li></ul></li><li>实施定量风险分析<ul><li>决策树是一种图像方法，可以帮助在未来结果不确定的情况下选择最好的行动路径。</li><li>预期货币值EMV是风险事件概率和风险事件货币值的乘积。</li><li>模拟技术：<strong>蒙特卡罗分析MonteCarlo analysis</strong></li><li><strong>灵敏度分析sensitivity analysis</strong></li></ul></li><li>计划风险响应<ul><li>应对负面风险<ul><li>风险规避risk avoidance</li><li>风险承担risk acceptance</li><li>风险转移risk transference</li><li>风险缓解risk mitigation</li></ul></li><li>应对正面风险<ul><li>风险开发risk exploitation</li><li>风险共享risk sharing</li><li>风险增强risk enhancement</li><li>风险承担risk acceptance</li></ul></li><li><strong>残余风险residual risk</strong></li><li><strong>二次风险secondary risk</strong></li></ul></li><li>控制风险</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic14.png" alt=""></p><hr><h2 id="项目采购管理"><a href="#项目采购管理" class="headerlink" title="项目采购管理"></a>项目采购管理</h2><p><strong>project procurement management</strong> 包括为一个项目从外部组织获得商品或服务所需要的过程。包括4个主要过程：</p><ul><li>计划采购管理:<strong>自制/外购决策make-or-buy decision</strong><ul><li>合同类型<ul><li><strong>固定价格合同fixed-price contract或总付合同lump-sum contract</strong>–(买方风险最低)<ul><li><strong>严格固定价格FFP合同</strong></li><li><strong>有奖励的固定价格FPIF合同</strong></li><li><strong>经济价格调整的固定价格合同FP-EPA</strong></li><li>固定价格激励合同可以包括 <strong>总假设点PTA</strong><br><strong>PTA=(最高限价-目标价)/政府份额+目标成本</strong></li></ul></li><li><strong>成本补偿合同cost-reimbursable contract</strong> 包含向供应商支付直接与间接实际成本的合同。。以买方风险从低到高分为：<ul><li><strong>成本加激励合同CPIF contract</strong></li><li><strong>成本加固定费合同CPFF contract</strong></li><li><strong>成本加奖励费合同CPAF contract</strong></li><li><strong>成本加百分比合同CPPC contract</strong></li></ul></li><li><strong>时间与材料合同T&amp;M contract</strong> 是固定价格合同和成本补偿合同的混合。</li></ul></li><li>工具和技术<ul><li>自制/外购分析</li><li>专家评判</li><li>市场调研</li></ul></li><li>采购管理计划</li><li>工作说明书SOW</li><li>采购文档<ul><li><strong>建议书邀请函RFP</strong></li><li><strong>报价邀请函RFQ</strong></li></ul></li></ul></li><li>实施采购<br><strong>建议性变更单 constructive change order</strong> 指具有实际或明显权力的人，以口头或非正式的书面形式提出的意见。</li><li>控制采购</li><li>采购收尾</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic15.png" alt=""></p><hr><h2 id="项目干系人管理"><a href="#项目干系人管理" class="headerlink" title="项目干系人管理"></a>项目干系人管理</h2><p>项目干系人管理第一次提出是在2012年<strong>PMBOK Guide</strong>上。</p><ul><li>干系人识别<ul><li>内部internal:project sponsor,project team,support staff,internal customers。</li><li>外部external：customers,competitors,suppliers</li></ul></li></ul><p><strong>干系人登记表stakeholder register</strong>：识别信息、评估信息、干系人分类<br><strong>干系人分析stakeholder analysis</strong> 是一种技术，通过分析信息来确定干系人关注什么，以及如何提高干系人对项目的支持。</p><ul><li><strong>权利兴趣网格power/interest grid</strong><ul><li><strong>high interest and high authority</strong> —-manage closely</li><li><strong>high interest and low authority</strong>—-keep inform</li><li><strong>low interest and high authority</strong>—-keep satisfied</li><li><strong>low interest and low authority</strong>—-monitor</li></ul></li><li>干系人管理计划<br>干系人管理计划通常包括敏感信息，<strong>不属于正式的项目文档</strong> ，通常用于所有干系人审查。<ul><li>干系人登记表上的信息</li><li>当前水平和期望水平</li><li>干系人之间的相互关系</li><li>沟通需求</li><li>每个干系人的潜在管理策略</li><li>干系人管理计划更新方法</li></ul></li><li>参与干系人管理<br><strong>期望管理矩阵expectation management matrix</strong> 平衡三项约束进行优先级排序。<br><strong>问题日志issue log</strong> 用来记录、监控和跟踪需要解决问题的一种工具。</li><li>参与干系人控制(早期阶段)</li><li>软件辅助<ul><li>提高通信和协作的技术</li><li>社交媒体</li><li>“击掌庆祝”</li><li>发布评论</li></ul></li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic16.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目管理概述&quot;&gt;&lt;a href=&quot;#项目管理概述&quot; class=&quot;headerlink&quot; title=&quot;项目管理概述&quot;&gt;&lt;/a&gt;项目管理概述&lt;/h2&gt;&lt;h3 id=&quot;项目与运营&quot;&gt;&lt;a href=&quot;#项目与运营&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="项目管理" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>java_随记整理</title>
    <link href="http://yoursite.com/2018/04/17/java-%E9%9A%8F%E8%AE%B0%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/04/17/java-随记整理/</id>
    <published>2018-04-17T09:03:18.000Z</published>
    <updated>2018-09-22T07:36:53.153Z</updated>
    
    <content type="html"><![CDATA[<h2 id="用命令行运行java程序"><a href="#用命令行运行java程序" class="headerlink" title="用命令行运行java程序"></a>用命令行运行java程序</h2><ul><li>找到<code>.java</code>文件所在位置</li><li>在<code>cmd</code>上运行<code>javac xx.java</code>，生成<code>.class</code>编译文件</li><li>执行<code>java 主类名字</code>(注意：此处的主类名字为<code>main</code>所在的类名，区分大小写)</li><li>java的<code>String[] args</code>中不包括<code>java 主类名字</code>两个字符串，故<code>args[0]</code>为主类名字后面跟着的字符串</li><li>如果有多个<code>package</code>，则在<code>.../bin</code>路径下运行<code>java 包名.class名称</code></li><li>windows的目录上一级用<code>../</code>表示</li></ul><h2 id="正则表达式Pattern和Matcher类"><a href="#正则表达式Pattern和Matcher类" class="headerlink" title="正则表达式Pattern和Matcher类"></a>正则表达式Pattern和Matcher类</h2><ul><li><p>Pattern类：编译正则表达式后创建一个匹配模式</p><ul><li><code>Pattern compile(String regex)</code><br>由于Pattern的构造函数是私有的，不可以直接创建，所有通过静态方法<code>compile(String regex)</code>方法来创建，将给定的正则表达式编译并赋予给pattern类。</li><li><code>String pattern()</code>：返回正则表达式的字符串形式，其实就是返回<code>regex</code>参数</li><li><code>Pattern.matcher(CharSequence input)</code>对指定输入的字符串创建一个Matcher对象</li><li><code>String split(CharSequence input)</code>分割字符串</li><li><code>matches()</code>方法编译给定的正则表达式并且对输入的字符串以该正则表达式为模开展匹配，该方法适合于该正则表达式只会使用一次的情况，也就是只进行一次匹配工作，因为这种情况下并不需要生成一个matcher实例<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String regex = <span class="string">"\\?|\\*"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">String patternStr = pattern.pattern();<span class="comment">//返回\?|\*  (\为转义字符)</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line">Pattern pattern = Pattern.compile(<span class="string">"\\?&#123;2&#125;"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="string">"??"</span>);</span><br><span class="line"><span class="keyword">boolean</span> matches = matcher.matches();<span class="comment">// true</span></span><br><span class="line"><span class="comment">///////////////////////////////////////////////////////</span></span><br><span class="line">String regex = <span class="string">"\\?|\\*"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line">String[] splitStrs = pattern.split(<span class="string">"123?123*456*456"</span>);<span class="comment">//123 123 456 456</span></span><br><span class="line">String[] splitStrs2 = pattern.split(<span class="string">"123?123*456*456"</span>, <span class="number">2</span>);<span class="comment">// 123 123*456*456</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////////////</span></span><br><span class="line">String regex = <span class="string">"\\?|\\*"</span>;</span><br><span class="line">Pattern pattern = Pattern.compile(regex);</span><br><span class="line"><span class="keyword">boolean</span> matches = pattern.matches(regex, <span class="string">"?"</span>);<span class="comment">//返回true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Matcher类：使用Pattern实例提供的模式信息对正则表达式进行匹配</p><ul><li><code>boolean matches()</code>尝试对整个目标字符展开匹配检测，也就是只有整个目标字符串完全匹配时才返回真值</li><li><code>boolean lookingAt()</code>对前面的字符串进行匹配，只有匹配到的字符串在最前面才会返回true</li><li><code>boolean find()</code>对字符串进行匹配，匹配到的字符串可以在任意位置</li><li><code>int start()</code>返回当前匹配到的字符串在原目标字符串中的位置</li><li><code>int end()</code>返回当前匹配的字符串的最后一个字符在原目标字符串中的索引位置</li><li><code>String group</code>返回匹配到的子字符串<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">Pattern pattern = Pattern.compile(<span class="string">"\\?&#123;2&#125;"</span>);</span><br><span class="line">Matcher matcher = pattern.matcher(<span class="string">"??"</span>);</span><br><span class="line"><span class="keyword">boolean</span> matches = matcher.matches();<span class="comment">//true</span></span><br><span class="line">System.out.println(matches);</span><br><span class="line">matcher=pattern.matcher(<span class="string">"?"</span>);</span><br><span class="line">matches = matcher.matches();<span class="comment">//false</span></span><br><span class="line">System.out.println(matches);</span><br><span class="line"><span class="comment">/////////////////////////////////////////////</span></span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">Matcher m = p.matcher(<span class="string">"22bb23"</span>);</span><br><span class="line"><span class="keyword">boolean</span> match = m.lookingAt();<span class="comment">//true</span></span><br><span class="line">System.out.println(match);</span><br><span class="line">m = p.matcher(<span class="string">"bb2233"</span>);</span><br><span class="line">match= m.lookingAt();</span><br><span class="line">System.out.println(match);<span class="comment">//false</span></span><br><span class="line"><span class="comment">////////////////////////////////////////////////</span></span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">Matcher m = p.matcher(<span class="string">"22bb23"</span>);</span><br><span class="line">m.find();<span class="comment">// 返回true</span></span><br><span class="line">Matcher m2 = p.matcher(<span class="string">"aa2223"</span>);</span><br><span class="line">m2.find();<span class="comment">// 返回true</span></span><br><span class="line">Matcher m3 = p.matcher(<span class="string">"aa2223bb"</span>);</span><br><span class="line">m3.find();<span class="comment">// 返回true</span></span><br><span class="line">Matcher m4 = p.matcher(<span class="string">"aabb"</span>);</span><br><span class="line">m4.find();<span class="comment">// 返回false</span></span><br><span class="line"><span class="comment">//////////////////////////////////////////////////</span></span><br><span class="line">Pattern p = Pattern.compile(<span class="string">"\\d+"</span>);</span><br><span class="line">Matcher m = p.matcher(<span class="string">"aa22bb23"</span>);</span><br><span class="line">m.find();</span><br><span class="line"><span class="keyword">int</span> start = m.start();<span class="comment">//2</span></span><br><span class="line">String group = m.group();<span class="comment">//22</span></span><br><span class="line"><span class="keyword">int</span> end = m.end();<span class="comment">//4</span></span><br><span class="line">System.out.println(start);</span><br><span class="line">System.out.println(group);</span><br><span class="line">System.out.println(end);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="getPath、getAbsolutePath、getCanonicalPath的区别"><a href="#getPath、getAbsolutePath、getCanonicalPath的区别" class="headerlink" title="getPath、getAbsolutePath、getCanonicalPath的区别"></a><code>getPath、getAbsolutePath、getCanonicalPath</code>的区别</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">"user.dir"</span>));</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> System.out.println(<span class="string">"-----默认相对路径：取得路径不同------"</span>);</span><br><span class="line"> File file1 =<span class="keyword">new</span> File(<span class="string">"..\\src\\test1.txt"</span>);</span><br><span class="line"> System.out.println(file1.getPath());</span><br><span class="line"> System.out.println(file1.getAbsolutePath());</span><br><span class="line"> System.out.println(file1.getCanonicalPath());</span><br><span class="line"> System.out.println(<span class="string">"-----默认相对路径：取得路径不同------"</span>);</span><br><span class="line"> File file =<span class="keyword">new</span> File(<span class="string">".\\test1.txt"</span>);</span><br><span class="line"> System.out.println(file.getPath());</span><br><span class="line"> System.out.println(file.getAbsolutePath());</span><br><span class="line"> System.out.println(file.getCanonicalPath());</span><br><span class="line"></span><br><span class="line"> System.out.println(<span class="string">"-----默认绝对路径:取得路径相同------"</span>);</span><br><span class="line"> File file2 =<span class="keyword">new</span> File(<span class="string">"D:\\workspace\\test\\test1.txt"</span>);</span><br><span class="line"> System.out.println(file2.getPath());</span><br><span class="line"> System.out.println(file2.getAbsolutePath());</span><br><span class="line"> System.out.println(file2.getCanonicalPath());</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"> e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回的结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">F:\eclipseworkspace\testejb</span><br><span class="line">-----默认相对路径：取得路径不同------</span><br><span class="line">..\src\test1.txt</span><br><span class="line">F:\eclipseworkspace\testejb\..\src\test1.txt</span><br><span class="line">F:\eclipseworkspace\src\test1.txt</span><br><span class="line">-----默认相对路径：取得路径不同------</span><br><span class="line">.\test1.txt</span><br><span class="line">F:\eclipseworkspace\testejb\.\test1.txt</span><br><span class="line">F:\eclipseworkspace\testejb\test1.txt</span><br><span class="line">-----默认绝对路径:取得路径相同------</span><br><span class="line">D:\workspace\test\test1.txt</span><br><span class="line">D:\workspace\test\test1.txt</span><br><span class="line">D:\workspace\test\test1.txt</span><br></pre></td></tr></table></figure></p><ul><li>当输入为绝对路径时，返回的都是绝对路径</li><li>当输入为相对路径时<ul><li><code>getPath</code>返回的是File构造方法里的路径，是什么就是什么，不可解析</li><li><code>getAbsolutePath</code>返回的其实是<code>user.dir+getPath</code>的内容，不可解析</li><li><code>getCanonicalPath</code>返回的就是标准的将符号完全解析的路径</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;用命令行运行java程序&quot;&gt;&lt;a href=&quot;#用命令行运行java程序&quot; class=&quot;headerlink&quot; title=&quot;用命令行运行java程序&quot;&gt;&lt;/a&gt;用命令行运行java程序&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;找到&lt;code&gt;.java&lt;/code&gt;文件所在
      
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>leetcode_array</title>
    <link href="http://yoursite.com/2018/04/17/leetcode-array/"/>
    <id>http://yoursite.com/2018/04/17/leetcode-array/</id>
    <published>2018-04-16T16:40:39.000Z</published>
    <updated>2018-09-22T07:36:53.162Z</updated>
    
    <content type="html"><![CDATA[<h2 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11.Container With Most Water"></a>11.Container With Most Water</h2><h3 id="题目解析"><a href="#题目解析" class="headerlink" title="题目解析"></a>题目解析</h3><p>给定一个数组$a_n$，相对应产生数组长度数量的点$(i,a_i)$，各个点$(i,a_i)$与点$(i,0)$组成$n$条线段，由任意两条线段加上$x$轴组成一个水桶，判断能够盛水最大容量桶的面积是多少？</p><h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><p>由数组左右两边出发，求解较短线段对应的面积，再判断左右两边线段的长短：</p><ul><li>若$left&gt;right$，此时如果判断$left$的右边的下一条线段$left_{next}$：<ul><li>若$left&gt;left_{next}$，那么只有两种情况：<ul><li>$left_{next}&gt;right$，那么面积不变</li><li>$left_{next}&lt;right$，那么面积减小，对于最大面积的求解没有意义</li></ul></li><li>若$left&lt;left_{next}$，那么面积不变<br>综上，判断$left_{next}$没有意义，因此选择判断$right_{next}$</li></ul></li><li>若$left&lt;right$，同时，选择判断$left_{next}$</li><li>直至$left==right$，返回最大面积</li></ul><h3 id="leetcode代码"><a href="#leetcode代码" class="headerlink" title="leetcode代码"></a>leetcode代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxArea</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> area=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r=height.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r&amp;&amp;l&gt;=<span class="number">0</span>&amp;&amp;r&lt;=height.length-<span class="number">1</span>)&#123;</span><br><span class="line">            area=Math.max(area,Math.min(height[r],height[l])*(r-l));</span><br><span class="line">            <span class="keyword">if</span>(height[l]&gt;height[r])&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> area;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="16.3Sum Closest"></a>16.3Sum Closest</h2><h3 id="题目解析-1"><a href="#题目解析-1" class="headerlink" title="题目解析"></a>题目解析</h3><p>给定一个数组$a_n$和一个目标值$target$，要求找到数组中的三个值之和最接近目标值，返回这三个值的和。</p><h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><p>先对数组进行排序，再对数组$a_{n-2}$遍历，遍历期间对于后面的数组进行首尾出发判断：</p><ul><li>若$sum&gt;target$，那么先判断接近值是多少，并更新最小接近值，同时执行$right–$(这是因为数组已经排序，要接近目标值，下一步只能判断$right_{next}$，才会使得$sum$减小，从而出现更接近目标值的和)</li><li>若$sum&lt;target$，同理，先判断并更新最小接近值，同时执行$left++$</li></ul><p>直至遍历完成，返回得到的最小接近值。</p><h3 id="leetcode代码-1"><a href="#leetcode代码-1" class="headerlink" title="leetcode代码"></a>leetcode代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length&lt;<span class="number">3</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="keyword">int</span> closeDic=Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">int</span> result=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i-<span class="number">1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> left=i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> right=nums.length-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                sum=nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum&gt;target)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((sum-target)&lt;closeDic)&#123;</span><br><span class="line">                        closeDic=sum-target;</span><br><span class="line">                        result=sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((target-sum)&lt;closeDic)&#123;</span><br><span class="line">                        closeDic=-sum+target;</span><br><span class="line">                        result=sum;</span><br><span class="line">                    &#125;</span><br><span class="line">                    left++;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> sum;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41.First Missing Positive"></a>41.First Missing Positive</h2><h3 id="题目解析-2"><a href="#题目解析-2" class="headerlink" title="题目解析"></a>题目解析</h3><p>给定一个未排序的数组$a_n$，找到这个数组第一个丢失的正整数。要求时间复杂度为$O(n)$，空间复杂度为常数。</p><h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><p>由于时间复杂度为$O(n)$，因此不可能使用嵌套循环，只能一层遍历。又由于空间复杂度为常数，因此只能在原数组中进行处理。思路是遍历整个数组，判断元素值$a[i]$是否等于$i+1$，若不等于，则与$a[a[i]-1]$交换，此时元素$a[a[i]-1]$必然满足元素值等于下标索引+1，然后继续判断直至满足判断条件才接下去遍历。遍历完成后，再重新遍历一次，判断第一个不符合判断条件的即找到了结果。</p><h3 id="leetcode代码-2"><a href="#leetcode代码-2" class="headerlink" title="leetcode代码"></a>leetcode代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(A==<span class="keyword">null</span> || A.length==<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(A[i]&lt;=A.length &amp;&amp; A[i]&gt;<span class="number">0</span> &amp;&amp; A[A[i]-<span class="number">1</span>]!=A[i])  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">int</span> temp = A[A[i]-<span class="number">1</span>];  </span><br><span class="line">            A[A[i]-<span class="number">1</span>] = A[i];  </span><br><span class="line">            A[i] = temp;  </span><br><span class="line">            i--;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;A.length;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">if</span>(A[i]!=i+<span class="number">1</span>)  </span><br><span class="line">            <span class="keyword">return</span> i+<span class="number">1</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> A.length+<span class="number">1</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55.Jump Game"></a>55.Jump Game</h2><h3 id="题目解析-3"><a href="#题目解析-3" class="headerlink" title="题目解析"></a>题目解析</h3><p>给定一个正整数的数组$a[n]$，初始位置在第一个元素，每一个元素表示你可以跳跃的最大步长，例如$a[0]=2$，那么你可以跳跃到的位置有$a[1]$、$a[2]$。最终返回的结果是你是否可以跳到最后一个元素位置。</p><h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><p>动态规划的特点：  </p><ul><li>每遍历一个元素都有可能影响最后的结果</li><li>都有局部解和最终解</li><li>都是通过解决局部解这个小问题而逐渐解决最终解的大问题</li></ul><p>遍历$1-&gt;(nums.length-2)$，局部解就是$i+nums[i]$，遍历过程中保留当前能够跳跃的最远位置$max$，并进行两个判断</p><ul><li>判断保留的$max$是否允许进行下一个元素的遍历，如果连下一个元素都无法达到，直接返回$false$</li><li>判断保留的$max$是否达到$nums.length$或者更大，则返回$true$</li></ul><h3 id="leetcode代码-3"><a href="#leetcode代码-3" class="headerlink" title="leetcode代码"></a>leetcode代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            max=Math.max(max,i+nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(max&lt;i+<span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(max&gt;=(nums.length-<span class="number">1</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45.Jump Game II"></a>45.Jump Game II</h2><h3 id="题目解析-4"><a href="#题目解析-4" class="headerlink" title="题目解析"></a>题目解析</h3><p>给定一个正整数的数组$a[n]$，初始位置在第一个元素，每一个元素表示你可以跳跃的最大步长，例如$a[0]=2$，那么你可以跳跃到的位置有$a[1]$、$a[2]$。最终返回到达最后一个元素位置的最小跳转次数</p><h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><p>在$Jump\quad Game$思路中，将全局最优转换成step(reach)最优和step-1(lastreach)最优。当走到超过step-1步最远的位置时，说明了step-1(lastreach)不能到达当前一步，则更新步数step+1。时间复杂度为$O(n)$，空间复杂度为$O(1)$</p><h3 id="leetcode代码-4"><a href="#leetcode代码-4" class="headerlink" title="leetcode代码"></a>leetcode代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">jump</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>||nums.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> lastreach=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> reach=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=reach&amp;&amp;i&lt;nums.length;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;lastreach)&#123;</span><br><span class="line">                step++;</span><br><span class="line">                lastreach=reach;</span><br><span class="line">            &#125;</span><br><span class="line">            reach=Math.max(reach,nums[i]+i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(reach&lt;nums.length-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="54-Spiral-matrix"><a href="#54-Spiral-matrix" class="headerlink" title="54.Spiral matrix"></a>54.Spiral matrix</h2><h3 id="题目解析-5"><a href="#题目解析-5" class="headerlink" title="题目解析"></a>题目解析</h3><p>给定一个$m*n$的矩阵，按照螺旋顺序返回包含所有元素的一维数组。</p><h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>解法1</strong><br>按照上下左右遍历，根据遍历的上下左右偏移数目找到遍历的行列数，并将每个元素都赋给List集合，判断上下或者左右的偏移数目之和是否等于行数或者列数，跳出循环，返回结果。<br><strong>解法2</strong><br>遍历所有的元素，根据两个数组 $[0,1,0,-1]$与$[1,0,-1,0]$ 作为步长实现螺旋顺序取数赋值，最后返回结果。时间复杂度与空间复杂度都为 $O(m*n)$。</p><h3 id="leetcode代码-5"><a href="#leetcode代码-5" class="headerlink" title="leetcode代码"></a>leetcode代码</h3><p><strong>解法1</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List&lt;Integer&gt; result=<span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">if</span>(matrix.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m=matrix.length;</span><br><span class="line">        <span class="keyword">int</span> n=matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span> top=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> bottom=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="comment">//top</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=left;i&lt;n-right;i++)&#123;</span><br><span class="line">                result.add(matrix[top][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            top++;</span><br><span class="line">            <span class="keyword">if</span>((top+bottom)==m)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//right</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=top;i&lt;m-bottom;i++)&#123;</span><br><span class="line">                result.add(matrix[i][n-right-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="keyword">if</span>((left+right)==n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//bottom</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=n-right-<span class="number">1</span>;i&gt;=left;i--)&#123;</span><br><span class="line">                result.add(matrix[m-bottom-<span class="number">1</span>][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            bottom++;</span><br><span class="line">            <span class="keyword">if</span>((top+bottom)==m)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=m-bottom-<span class="number">1</span>;i&gt;=top;i--)&#123;</span><br><span class="line">                result.add(matrix[i][left]);</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">if</span>((left+right)==n)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>解法2</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">spiralOrder</span><span class="params">(<span class="keyword">int</span>[][] matrix)</span> </span>&#123;</span><br><span class="line">        List ans = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        <span class="keyword">if</span> (matrix.length == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">int</span> R = matrix.length, C = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">boolean</span>[][] seen = <span class="keyword">new</span> <span class="keyword">boolean</span>[R][C];</span><br><span class="line">        <span class="keyword">int</span>[] dr = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] dc = &#123;<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, c = <span class="number">0</span>, di = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; R * C; i++) &#123;</span><br><span class="line">            ans.add(matrix[r][c]);</span><br><span class="line">            seen[r][c] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> cr = r + dr[di];</span><br><span class="line">            <span class="keyword">int</span> cc = c + dc[di];</span><br><span class="line">            <span class="keyword">if</span> (<span class="number">0</span> &lt;= cr &amp;&amp; cr &lt; R &amp;&amp; <span class="number">0</span> &lt;= cc &amp;&amp; cc &lt; C &amp;&amp; !seen[cr][cc])&#123;</span><br><span class="line">                r = cr;</span><br><span class="line">                c = cc;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                di = (di + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">                r += dr[di];</span><br><span class="line">                c += dc[di];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="62-Unique-Paths"><a href="#62-Unique-Paths" class="headerlink" title="62.Unique Paths"></a>62.Unique Paths</h2><h3 id="题目解析-6"><a href="#题目解析-6" class="headerlink" title="题目解析"></a>题目解析</h3><p>给定一个$m*n$的二维数组，以左上角为起点，只能right或者down移动，最终结束点在二维数组的右下角位置，返回所有路线的总和。</p><h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>解法1</strong><br>在二维数组矩阵的内部某一元素，到达这一元素位置的路线总和必然是它左边元素位置的路线总和与它上边的元素位置路线总和相加得到，而矩阵边上的元素(第一行和第一列的元素)位置的路线只能是一种。遍历二维数组，将每个元素位置上对应的路线总和赋给对应位置的新矩阵中，最后得到一个对应原矩阵的路线新矩阵，返回新矩阵的右下角的元素值。<br><strong>解法2</strong><br>使用排列组合的方法。从起点走到终点，它只能right或者down，那么不管它怎么走，必然向右走了$n-1$步，向下走了$m-1$步，则一共走了$n-1+m-1$步，而不同的走法本质上是向右或者向下构成的$m-1+n-1$长度的序列不同，因此题目可以转换成在总步数中选出$n-1$代表向右走的走法个数或者选出$m-1$代表向下走的走法个数，即$C_{n-1+m-1}^{n-1}=C_{n-1+m-1}^{m-1}=\dfrac{(n-1+m-1)\cdot…\cdot(n)}{(m-1)\cdot…\cdot2\cdot1}$</p><h3 id="leetcode代码-6"><a href="#leetcode代码-6" class="headerlink" title="leetcode代码"></a>leetcode代码</h3><p><strong>解法1</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span> || n==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">1</span> || n==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] result=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> || j==<span class="number">0</span>)&#123;</span><br><span class="line">                    result[i][j]=<span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    result[i][j]=result[i-<span class="number">1</span>][j]+result[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>解法2</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = m &gt; n ? m - <span class="number">1</span> : n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = m &gt; n ? n - <span class="number">1</span> : m - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">long</span> result = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b; i++) &#123;</span><br><span class="line">            result *= a + b - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= b; i++) &#123;</span><br><span class="line">            result /= i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>) result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="63-Unique-Paths-II"><a href="#63-Unique-Paths-II" class="headerlink" title="63.Unique Paths II"></a>63.Unique Paths II</h2><h3 id="题目解析-7"><a href="#题目解析-7" class="headerlink" title="题目解析"></a>题目解析</h3><p>在<strong>Unique Paths</strong>的基础上，增加障碍物导致一些路线无法通过。给定一个元素值为0和1的二维数组矩阵，其中1代表障碍物，无法通过，返回到达终点的所有可能路线总和。</p><h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><p><strong>解法1</strong><br>考虑两种情况：</p><ul><li>矩阵边上存在障碍物。一旦矩阵边上某一位置存在障碍物，那么该位置后面的边上位置都无法通过。</li><li>矩阵内部存在障碍物。只能表示该位置无法通过。</li></ul><p>而对于矩阵非边上的某一位置，根据动态规划，该位置的路线总和是其左边位置和上边位置的路线之和，只有毗邻的这两个位置都无法通过，这位置才会无法通过。<br>空间复杂度是$O(n*m)$<br><strong>解法2</strong><br>这个方法主要是降低了空间复杂度，为$O(n)$。对于空间可以看出我们每次只需要用到上一行当前列以及前一列当前行的信息，因此我们只需要用一个一维数组存上一行的信息即可，因为前一列当前行的信息在进行遍历的时候可以直接获取，然后在遍历下一行的时候使用一维数组信息并更新信息，所以空间复杂度为$O(n)$。(也可以选择行列较小那个，将其放置内层循环，则空间复杂度为$O(min(m,n))$)。</p><h3 id="leetcode代码-7"><a href="#leetcode代码-7" class="headerlink" title="leetcode代码"></a>leetcode代码</h3><p><strong>解法1</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid.length==<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][<span class="number">0</span>]==<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m=obstacleGrid.length;</span><br><span class="line">        <span class="keyword">int</span> n=obstacleGrid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">int</span>[][] result=<span class="keyword">new</span> <span class="keyword">int</span>[m][n];</span><br><span class="line">        <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[<span class="number">0</span>][i]==<span class="number">1</span> || key==<span class="number">1</span>)&#123;</span><br><span class="line">                result[<span class="number">0</span>][i]=<span class="number">0</span>;</span><br><span class="line">                key=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[<span class="number">0</span>][i]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        key=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][<span class="number">0</span>]==<span class="number">1</span> || key==<span class="number">1</span>)&#123;</span><br><span class="line">                result[i][<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">                key=<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result[i][<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)&#123;</span><br><span class="line">                    result[i][j]=<span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        result[i][j]=result[i-<span class="number">1</span>][j]+result[i][j-<span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>解法2</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePathsWithObstacles</span><span class="params">(<span class="keyword">int</span>[][] obstacleGrid)</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(obstacleGrid == <span class="keyword">null</span> || obstacleGrid.length==<span class="number">0</span> || obstacleGrid[<span class="number">0</span>].length==<span class="number">0</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">    <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[obstacleGrid[<span class="number">0</span>].length];  </span><br><span class="line">    res[<span class="number">0</span>] = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;obstacleGrid.length;i++)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;obstacleGrid[<span class="number">0</span>].length;j++)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(obstacleGrid[i][j]==<span class="number">1</span>)  </span><br><span class="line">            &#123;  </span><br><span class="line">                res[j]=<span class="number">0</span>;  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">else</span>  </span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="keyword">if</span>(j&gt;<span class="number">0</span>)  </span><br><span class="line">                    res[j] += res[j-<span class="number">1</span>];  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> res[obstacleGrid[<span class="number">0</span>].length-<span class="number">1</span>];  </span><br><span class="line">&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;11-Container-With-Most-Water&quot;&gt;&lt;a href=&quot;#11-Container-With-Most-Water&quot; class=&quot;headerlink&quot; title=&quot;11.Container With Most Water&quot;&gt;&lt;/a&gt;11
      
    
    </summary>
    
      <category term="leetcode整理总结" scheme="http://yoursite.com/categories/leetcode%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="array" scheme="http://yoursite.com/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>企业软件开发_缓存设计</title>
    <link href="http://yoursite.com/2018/04/16/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1/"/>
    <id>http://yoursite.com/2018/04/16/企业软件开发-缓存设计/</id>
    <published>2018-04-16T11:45:31.000Z</published>
    <updated>2018-09-22T07:36:53.388Z</updated>
    
    <content type="html"><![CDATA[<h2 id="缓存的基本知识"><a href="#缓存的基本知识" class="headerlink" title="缓存的基本知识"></a>缓存的基本知识</h2><h3 id="由来"><a href="#由来" class="headerlink" title="由来"></a>由来</h3><ul><li>两种介质的速度不匹配(差距较大)的问题导致：高速方在和低速方交互的时候因等待速度趋近于低速方，并且闲置得不到有效利用</li><li>存在第三方介质，速度介于两者之间，价格介于两者之间。通过引入这种介质，把低速方部分内容保存在这个介质中，高速方大多情况下无须和低速方直接交互来提高整体性能</li><li>典型的例子：CPU缓存(高速方CPU低速方内存)，内存(高速方CPU低速方磁盘)</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>硬件领域中缓存(某种介质)，软件领域中的缓存(不限于某种介质，只是一种手段)，这里我们讲的缓存都是软件缓存。</li><li>读取缓存(解决读取速度慢)，写入缓存(解决写入速度慢)，读写缓存</li><li>狭义上解决介质读写速度不匹配问题，广义上包括任何利用中间媒介提高速度的方法，包括空间换时间，动态操作变成静态操作</li></ul><h2 id="网站架构中缓存的分类"><a href="#网站架构中缓存的分类" class="headerlink" title="网站架构中缓存的分类"></a>网站架构中缓存的分类</h2><ul><li>按照存储介质来分<ul><li>内存(网站进程内、同服务器独立进程、独立服务器、分布式服务器组)</li><li>磁盘(本地文件和数据库、独立服务器、分布式服务器组)</li><li>缓存可以使用磁盘而不仅仅是内存</li></ul></li><li>按照存储的数据来分<ul><li>直接用于输出的整页(HTML、脚本样式、图片)</li><li>片段页(可供多个客户端使用的HTML、脚本样式等)</li><li>索引和聚合数据(空间换时间)</li><li>耗时查询的结果数据</li><li>和业务相关的大块数据(列表数据、引用数据)</li><li>和业务相关的小块数据(行级数据、资源数据)</li><li>和上下文(用户)相关的数据(活动数据)</li></ul></li><li>按照实现方式来分<ul><li>框架或引擎内置的缓存(比如ORM缓存和SQL Server缓存)</li><li>安装特定的组件根据规则自动实现缓存(比如反向代理和输出缓存)</li><li>需要由开发以编程方式实现的缓存(比如业务数据缓存)</li></ul></li><li>按照作用来分<ul><li>用于数据的读取</li><li>用于(允许丢失)数据的写入-写到缓存的队列中，再由工作线程提交处理(写入存储)</li></ul></li></ul><h3 id="缓存技术分类"><a href="#缓存技术分类" class="headerlink" title="缓存技术分类"></a>缓存技术分类</h3><ul><li>http缓存—&gt;减少对网站的访问</li><li>数据库缓存—&gt;减少文件系统I/O</li><li>操作系统磁盘缓存—&gt;减少磁盘机械操作</li><li>应用程序缓存—&gt;减少对数据库的查询</li><li>web服务器缓存—&gt;减少应用服务器请求</li></ul><h4 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h4><p><strong>缓存策略</strong></p><ul><li>Query Cache<ul><li>以SQL作为key值缓存查询结果集</li><li>记录被修改，缓存就会自动删除</li><li>设置合适的Query Cache会极大提高数据库性能，过大会浪费内存</li><li>Mysql:query_cache_size=128M</li></ul></li><li>Data Buffer<ul><li>数据库数据在内存中的容器，其命中率直接决定数据库的性能</li><li>越大越好，多多益善</li><li>Mysql:innodb_buffer_pool_size=2G</li></ul></li></ul><h4 id="应用程序缓存"><a href="#应用程序缓存" class="headerlink" title="应用程序缓存"></a>应用程序缓存</h4><ul><li>对象缓存</li><li>查询缓存</li><li>页面缓存<ul><li>动态页面静态化</li><li>Servlet缓存</li><li>页面内部缓存</li></ul></li></ul><h2 id="影响缓存命中率的因素"><a href="#影响缓存命中率的因素" class="headerlink" title="影响缓存命中率的因素"></a>影响缓存命中率的因素</h2><h3 id="测试实例"><a href="#测试实例" class="headerlink" title="测试实例"></a>测试实例</h3><p><img src="/2018/04/16/企业软件开发-缓存设计/pic1.png" alt=""><br>假设数据库的访问操作需要5毫秒。<br>第一个测试固定key的范围(即第一幅图)，第二个测试固定缓存时间(即第二幅图)</p><ul><li>对于相同的请求数，随着缓存时间的上升(实时性下降)，缓存命中率明显上升(第一幅图)。</li><li>对于相同的缓存时间，随着请求数的上升(时间的推移)，缓存命中率保持稳定。(第一二幅图)</li><li>在相同的缓存时间下(2秒)，缓存key的跨度越大命中率越低，往往key的范围很大预示着缓存的粒度太粗，key所容纳的条件太多。</li></ul><h3 id="影响命中率的因素"><a href="#影响命中率的因素" class="headerlink" title="影响命中率的因素"></a>影响命中率的因素</h3><ul><li>业务需求决定的时效性(体现在缓存的过期时间)</li><li>硬件基础结构决定的容量(即使未过期都可能会删除LRU)</li><li>软件架构设计决定的缓存的粒度<ul><li>key=帖子ID;value=所有跟帖数据</li><li>key=帖子ID;value=一条帖子的数据</li><li>key=帖子ID;value=跟帖ID列表</li></ul></li><li>缓存的设计(包括替换策略等</li></ul><h3 id="提高缓存命中率的方法"><a href="#提高缓存命中率的方法" class="headerlink" title="提高缓存命中率的方法"></a>提高缓存命中率的方法</h3><ul><li>权衡业务、基础结构和架构设计</li><li>预热、增加过期时间、增加存储容量、调整缓存项的键值算法、对热点问题的捕捉</li></ul><h2 id="缓存常见的模式和实现"><a href="#缓存常见的模式和实现" class="headerlink" title="缓存常见的模式和实现"></a>缓存常见的模式和实现</h2><p><img src="/2018/04/16/企业软件开发-缓存设计/pic2.png" alt=""></p><h3 id="延迟加载的缓存"><a href="#延迟加载的缓存" class="headerlink" title="延迟加载的缓存"></a>延迟加载的缓存</h3><ul><li>主要用于缓存计算后的小块数据</li><li>依靠用户的请求加载数据</li><li>一开始命中率低(可以通过预热提高命中率)</li><li>随着用户访问的增多命中率逐渐提高</li><li>随着缓存的过期命中率保持稳定</li><li>“冷门”的数据可能始终从数据库获取</li><li>适合分布式缓存</li></ul><h3 id="预加载的缓存"><a href="#预加载的缓存" class="headerlink" title="预加载的缓存"></a>预加载的缓存</h3><ul><li>主要用于缓存计算前的原始大块数据</li><li>一般缓存的(元)数据不太需要更新</li><li>大多采用主动更新</li><li>一般信任缓存的数据</li><li>考虑初始化的时候多台服务器对数据库的冲击</li><li>不适合分布式缓存</li></ul><h2 id="缓存的更新过期和清除策略"><a href="#缓存的更新过期和清除策略" class="headerlink" title="缓存的更新过期和清除策略"></a>缓存的更新过期和清除策略</h2><h2 id="包裹着缓存纱布的数据库"><a href="#包裹着缓存纱布的数据库" class="headerlink" title="包裹着缓存纱布的数据库"></a>包裹着缓存纱布的数据库</h2><h2 id="缓存存储方式的选择"><a href="#缓存存储方式的选择" class="headerlink" title="缓存存储方式的选择"></a>缓存存储方式的选择</h2><h2 id="缓存的同步问题"><a href="#缓存的同步问题" class="headerlink" title="缓存的同步问题"></a>缓存的同步问题</h2><h2 id="缓存的颠簸问题"><a href="#缓存的颠簸问题" class="headerlink" title="缓存的颠簸问题"></a>缓存的颠簸问题</h2><h2 id="分布式缓存系统的需求"><a href="#分布式缓存系统的需求" class="headerlink" title="分布式缓存系统的需求"></a>分布式缓存系统的需求</h2><h2 id="Memcache的基本介绍"><a href="#Memcache的基本介绍" class="headerlink" title="Memcache的基本介绍"></a>Memcache的基本介绍</h2><h2 id="Memcache的使用误区和实践"><a href="#Memcache的使用误区和实践" class="headerlink" title="Memcache的使用误区和实践"></a>Memcache的使用误区和实践</h2><h2 id="Windows-Server-AppFabric-Caching"><a href="#Windows-Server-AppFabric-Caching" class="headerlink" title="Windows Server AppFabric Caching"></a>Windows Server AppFabric Caching</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;缓存的基本知识&quot;&gt;&lt;a href=&quot;#缓存的基本知识&quot; class=&quot;headerlink&quot; title=&quot;缓存的基本知识&quot;&gt;&lt;/a&gt;缓存的基本知识&lt;/h2&gt;&lt;h3 id=&quot;由来&quot;&gt;&lt;a href=&quot;#由来&quot; class=&quot;headerlink&quot; title=&quot;由
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="企业软件开发" scheme="http://yoursite.com/tags/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客的设置笔记</title>
    <link href="http://yoursite.com/2018/04/11/hexo%E5%8D%9A%E5%AE%A2%E7%9A%84%E8%AE%BE%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/04/11/hexo博客的设置笔记/</id>
    <published>2018-04-11T13:21:40.000Z</published>
    <updated>2018-09-22T07:36:53.021Z</updated>
    
    <content type="html"><![CDATA[<h2 id="github-pages设置多分支master和hexo"><a href="#github-pages设置多分支master和hexo" class="headerlink" title="github pages设置多分支master和hexo"></a>github pages设置多分支master和hexo</h2><p>在github上创建两个分支master和hexo，其中master分支存放生成的静态网页，hexo分支用来存放网站的原始文件，也就是平时写文章的文件所在地。</p><ul><li>先在github上创建分支<br><img src="/2018/04/11/hexo博客的设置笔记/pic1.png" alt=""></li><li><p>安装使用最新版的<code>hexo-deployer-git</code>插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install git+git<span class="meta">@github</span>.com:hexojs/hexo-deployer-git.git --save</span><br></pre></td></tr></table></figure></li><li><p>在文件<code>_config.yml</code>中设置  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: http:<span class="comment">//github.com/JackeyZz/JackeyZz.github.io.git</span></span><br><span class="line">    branch: master</span><br><span class="line">  - type: git</span><br><span class="line">    repo: http:<span class="comment">//github.com/JackeyZz/JackeyZz.github.io.git</span></span><br><span class="line">    branch: hexo</span><br><span class="line">    extend_dirs: /</span><br><span class="line">    ignore_hidden: <span class="keyword">false</span></span><br><span class="line">    ignore_pattern:</span><br><span class="line">        <span class="keyword">public</span>: .</span><br></pre></td></tr></table></figure></li></ul><p>这里是为了<code>hexo deploy</code>时将静态文件和原始文件上传到master分支和hexo分支上。即为<br><img src="/2018/04/11/hexo博客的设置笔记/pic2.png" alt=""><br><img src="/2018/04/11/hexo博客的设置笔记/pic3.png" alt="">  </p><ul><li>更换电脑时通过git重新下载整个项目，然后在本地切换到远端的hexo分支  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout origin/hexo</span><br></pre></td></tr></table></figure></li></ul><p>就能重新获得所有的源文件，重新进行修改发布。(注意对于从git下载下来的项目，最好将<code>.git</code>文件删除后重新生成，否则会出现错误)<br>这时需要在新电脑上down下来的文件夹上通过<code>git bash</code>依次执行下列指令：  </p><pre><code class="java">npm install hexonpm installnpm install hexo-deployer-git(不需要hexo init这条指令)</code></pre><h2 id="设置pdf链接"><a href="#设置pdf链接" class="headerlink" title="设置pdf链接"></a>设置pdf链接</h2><p>其实这个问题只是本地<code>url</code>的小问题，浏览器自身是支持pdf显示的，跟<code>github pages</code>和<code>hexo</code>没什么关系。<br>在执行<code>hexo g</code>后，会生成<code>public</code>的文件夹，其中都是静态网页，而<code>github pages</code>的网页<code>url</code>就是对应这个文件夹产生的。因此只要使用<code>[名称](相对路径)</code>就可以在博客中嵌入pdf文章。例如当阅读需要嵌入pdf的博客文章时<br><img src="/2018/04/11/hexo博客的设置笔记/pic5.png" alt=""><br>显然它的<code>url</code>是文件夹<code>public</code>里对应的博客文章所生成的静态网页的文件夹里面，如<code>2018/04/11/论文阅读笔记1/#more</code>，故使用相对路径就可完成嵌入<code>pdf</code>文件。<br><img src="/2018/04/11/hexo博客的设置笔记/pic4.png" alt=""><br><img src="/2018/04/11/hexo博客的设置笔记/pic6.png" alt=""></p><h2 id="设置sidebar"><a href="#设置sidebar" class="headerlink" title="设置sidebar"></a>设置sidebar</h2><p><code>sidebar</code>的前端网页在文件夹<code>themes/next/layout/_macro/sidebar.swig</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;github-pages设置多分支master和hexo&quot;&gt;&lt;a href=&quot;#github-pages设置多分支master和hexo&quot; class=&quot;headerlink&quot; title=&quot;github pages设置多分支master和hexo&quot;&gt;&lt;/a&gt;gi
      
    
    </summary>
    
      <category term="学习工具整理总结" scheme="http://yoursite.com/categories/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="hexo" scheme="http://yoursite.com/tags/hexo/"/>
    
  </entry>
  
</feed>
