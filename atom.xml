<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JackeyZz的博客主页</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-03-14T09:40:11.248Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>JackeyZz</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java成神之路进阶篇-设计模式</title>
    <link href="http://yoursite.com/2019/03/14/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E8%BF%9B%E9%98%B6%E7%AF%87-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/03/14/java成神之路进阶篇-设计模式/</id>
    <published>2019-03-14T09:09:34.000Z</published>
    <updated>2019-03-14T09:40:11.248Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p>java成神之路进阶篇之设计模式。<br>不积跬步无以至千里，不积小流无以成江海。<br><a id="more"></a></p></blockquote><hr><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="单例模式（转发）"><a href="#单例模式（转发）" class="headerlink" title="单例模式（转发）"></a>单例模式（转发）</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><code>单例模式（Singleton Pattern）</code>是Java中最简单的设计模式之一。这种类型的设计模式属于创建型模式。书中给出的定义为：<code>保证一个类仅有一个实例，并提供一个访问它的全局访问点</code>。</p><p>单例模式一般体现在类声明中，单例的类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p><blockquote><p>注意：<br>1、单例类只能有一个实例。<br>2、单例类必须自己创建自己的唯一实例。<br>3、单例类必须给所有其他对象提供这一实例。</p></blockquote><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><code>优点：</code></p><ul><li>在内存里只有一个实例，减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。</li><li>避免对资源的多重占用（比如写文件操作）。</li></ul><p><code>缺点：</code><br>没有接口，不能继承，与单一职责原则冲突，一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。</p><h4 id="单例模式的六种写法"><a href="#单例模式的六种写法" class="headerlink" title="单例模式的六种写法"></a>单例模式的六种写法</h4><blockquote><p>单例模式的代码要素：<br>1、将构造函数私有化<br>2、在类的内部创建实例<br>3、提供获取唯一实例的方法</p></blockquote><ul><li>1、饿汉式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code 1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在类内部实例化一个实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="comment">//私有的构造函数,外部无法访问</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>所谓<code>饿汉</code>，这是个比较形象的比喻。对于一个饿汉来说，他希望他想要用到这个实例的时候就能够立即拿到，而不需要任何等待时间。所以，<code>通过static的静态初始化方式，在该类第一次被加载的时候，就有一个SimpleSingleton的实例被创建出来了</code>。这样就保证在第一次想要使用该对象时，他已经被初始化好了。</p><p>同时，由于该实例在类被加载的时候就创建出来了，所以也避免了<code>线程安全问题。（原因可见：Java的ClassLoader机制（源码级别）、Java类的加载、链接和初始化）</code></p><p><code>饿汉模式的变种:</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code 3</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton2</span> </span>&#123;</span><br><span class="line">    <span class="comment">//在类内部定义</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton2 instance;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="comment">//实例化该实例</span></span><br><span class="line">        instance = <span class="keyword">new</span> Singleton2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有的构造函数,外部无法访问</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton2 <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>code 3和code 1其实是一样的，都是在类被加载的时候实例化一个对象。</p><p><code>饿汉式单例的缺点与解决办法：</code><br>饿汉式单例，在类被加载的时候对象就会实例化。这也许会造成不必要的消耗，因为有可能这个实例根本就不会被用到。而且，如果这个类被多次加载的话也会造成多次实例化。其实解决这个问题的方式有很多，下面提供两种解决方式，第一种是使用静态内部类的形式。第二种是使用懒汉式。</p><ul><li>2、懒汉式，线程不安全<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code 5</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在对象被使用的时候才实例化</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这段代码简单明了，而且使用了<code>懒加载模式(即对象被需要使用时才创建对象实例)</code>，但是却存在致命的问题。<code>当有多个线程并行调用 getInstance()的时候，就会创建多个实例。也就是说在多线程下不能正常工作</code>。</p><ul><li>3、线程安全的懒汉式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code 6</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SynchronizedSingleton instance;</span><br><span class="line">    <span class="comment">//私有构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SynchronizedSingleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">//对外提供获取实例的静态方法,对该方法加锁</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SynchronizedSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//在对象被使用的时候才实例化</span></span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> SynchronizedSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>针对线程不安全的懒汉式的单例，其实解决方式很简单，就是给创建对象的步骤加锁</code>。</p><p>这种写法能够在多线程中很好的工作，而且看起来它也具备很好的延迟加载，但是，遗憾的是，他<code>效率很低</code>，因为99%情况下不需要同步。（因为上面的synchronized的加锁范围是整个方法，该方法的所有操作都是同步进行的，但是对于非第一次创建对象的情况，也就是没有进入if语句中的情况，根本不需要同步操作，可以直接返回instance。）这就引出了双重检验锁。</p><ul><li>4、双重检测机制(DCL)懒汉式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code 7</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>针对上面code 6存在的问题，相信对并发编程了解的同学都知道如何解决。其实上面的代码存在的问题主要是锁的范围太大了。只要缩小锁的范围就可以了。那么如何缩小锁的范围呢？<code>相比于同步方法，同步代码块的加锁范围更小</code>。code 6可以改造成上面的样子。</p><p><code>双重检验锁模式（Double Checked Locking Pattern）</code>，是一种使用同步块加锁的方法。<code>称其为双重检查锁，因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内</code>。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的if，如果在同步块内不进行二次检验的话就会生成多个实例了。</p><p>但是，事情这的有这么容易吗？上面的代码看上去好像是没有任何问题。<code>实现了惰性初始化，解决了同步问题，还减小了锁的范围，提高了效率</code>。但是，该代码还存在隐患。隐患的原因主要和Java内存模型（JMM）有关。</p><p>主要在于<code>singleton = new Singleton()</code>这句，这并非是一个原子操作，事实上在JVM 中这句话大概做了下面3件事情:</p><ul><li>给singleton分配内存</li><li>调用Singleton的构造函数来初始化成员变量</li><li>将singleton对象指向分配的内存空间（执行完这步singleton就为非 null 了）</li></ul><p>但是在 JVM 的即时编译器中存在<code>指令重排序的优化</code>。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是1-2-3也可能是1-3-2。如果是后者，则在3 执行完毕、2 未执行之前，被线程二抢占了，这时instance已经是非null 了（但却没有初始化），所以线程二会直接返回instance，然后使用，然后顺理成章地报错。</p><p>在J2SE 1.4或更早的版本中使用双重检查锁有潜在的危险，有时会正常工作（区分正确实现和有小问题的实现是很困难的。取决于编译器，线程的调度和其他并发系统活动，不正确的实现双重检查锁导致的异常结果可能会间歇性出现。重现异常是十分困难的。） 在J2SE 5.0中，这一问题被修正了。<code>volatile关键字保证多个线程可以正确处理单件实例</code>。</p><p>所以，针对code 7 ，可以有code 8 和code 9两种替代方案：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code 8</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> VolatileSingleton singleton;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">VolatileSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> VolatileSingleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (VolatileSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> VolatileSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>有些人认为使用 volatile 的原因是可见性，也就是可以保证线程在本地不会存有 singleton 的副本，每次都是去主内存中读取。但其实是不对的。使用 volatile 的主要原因是其另一个特性：禁止指令重排序优化。也就是说，在 volatile 变量的赋值操作后面会有一个内存屏障（生成的汇编代码上），读操作不会被重排序到内存屏障之前。比如上面的例子，取操作必须在执行完 1-2-3 之后或者 1-3-2 之后，不存在执行到 1-3 然后取到值的情况。从「先行发生原则」的角度理解的话，就是对于一个 volatile 变量的写操作都先行发生于后面对这个变量的读操作（这里的“后面”是时间上的先后顺序）。</p><p>但是特别注意在 Java 5 以前的版本使用了 volatile 的双检锁还是有问题的。其原因是 Java 5 以前的 JMM （Java 内存模型）是存在缺陷的，即时将变量声明成 volatile 也不能完全避免重排序，主要是 volatile 变量前后的代码仍然存在重排序问题。这个 volatile 屏蔽重排序的问题在 Java 5 中才得以修复，所以在这之后才可以放心使用 volatile。</p><p>上面这种双重校验锁的方式用的比较广泛，他解决了前面提到的所有问题。但是，即使是这种看上去完美无缺的方式也可能存在问题，那就是遇到序列化的时候。</p><p><code>使用final:</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code 9</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FinalWrapper</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalWrapper</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FinalWrapper&lt;FinalSingleton&gt; helperWrapper = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> FinalSingleton <span class="title">getHelper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        FinalWrapper&lt;FinalSingleton&gt; wrapper = helperWrapper;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (wrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (helperWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    helperWrapper = <span class="keyword">new</span> FinalWrapper&lt;FinalSingleton&gt;(<span class="keyword">new</span> FinalSingleton());</span><br><span class="line">                &#125;</span><br><span class="line">                wrapper = helperWrapper;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> wrapper.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>5、静态内部类<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.INSTANCE;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。<br>这种方式同样利用了 classloder 机制来保证初始化 instance 时只有一个线程，它跟第 1 种方式不同的是：第 1 种方式只要 Singleton 类被装载了，那么 instance 就会被实例化（没有达到 lazy loading 效果），而这种方式是 Singleton 类被装载了，instance 不一定被初始化。因为 SingletonHolder 类没有被主动使用，只有通过显式调用 getInstance 方法时，才会显式装载 SingletonHolder 类，从而实例化 instance。想象一下，如果实例化 instance 很消耗资源，所以想让它延迟加载，另外一方面，又不希望在 Singleton 类加载时就实例化，因为不能确保 Singleton 类还可能在其他的地方被主动使用从而被加载，那么这个时候实例化 instance 显然是不合适的。这个时候，这种方式相比第 1 种方式就显得很合理。</p><p>这种写法仍然使用JVM本身机制保证了线程安全问题；由于 SingletonHolder 是私有的，除了 getInstance() 之外没有办法访问它，因此它是懒加载的；同时读取实例的时候不会进行同步，没有性能缺陷；也不依赖 JDK 版本。</p><ul><li>6、枚举式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// code 10</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span>  Singleton &#123;</span><br><span class="line"></span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    Singleton() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>在Java 1.5之前，实现单例一般只有以上几种办法，在Java 1.5之后，还有另外一种实现单例的方式，那就是使用枚举。可以通过Singleton.INSTANCE来访问实例。</p><p>这种方式是<code>Effective Java</code>作者<code>Josh Bloch</code> 提倡的方式(Effective Java 第3条)，它不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象（下面会介绍），可谓是很坚强的壁垒啊，在深度分析Java的枚举类型—-枚举的线程安全性及序列化问题中有详细介绍枚举的线程安全问题和序列化问题。</p><p>那这种有啥好处？枚举的方式实现：</p><ul><li>简洁</li><li>无尝提供了序列化机制</li><li>绝对防止多次实例化，即使是在面对复杂的序列化或者反射攻击的时候(安全)！</li></ul><h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h4><p>有两个问题需要注意：<br>1、如果单例由不同的类装载器装入，那便有可能存在多个单例类的实例。假定不是远端存取，例如一些servlet容器对每个servlet使用完全不同的类装载器，这样的话如果有两个servlet访问一个单例类，它们就都会有各自的实例。<br>该问题可以通过如下方式修复：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Class <span class="title">getClass</span><span class="params">(String classname)</span>  </span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> ClassNotFoundException </span>&#123;  </span><br><span class="line">    ClassLoader classLoader = Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">if</span>(classLoader == <span class="keyword">null</span>)     </span><br><span class="line">          classLoader = Singleton.class.getClassLoader();     </span><br><span class="line">          <span class="keyword">return</span> (classLoader.loadClass(classname));     </span><br><span class="line">       &#125;     </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>2、如果Singleton实现了java.io.Serializable接口，那么这个类的实例就可能被序列化和复原。不管怎样，如果你序列化一个单例类的对象，接下来复原多个那个对象，那你就会有多个单例类的实例。序列化问题参考下面的分析。</p><p>单例与序列化<br>在单例与序列化的那些事儿一文中，分析过单例和序列化之前的关系——序列化可以破坏单例。要想防止序列化对单例的破坏，只要在Singleton类中定义readResolve就可以解决该问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//code 11</span></span><br><span class="line"><span class="keyword">package</span> com.hollis;</span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by hollis on 16/2/5.</span></span><br><span class="line"><span class="comment"> * 使用双重校验锁方式实现单例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singleton = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一般来说，单例模式有五种写法：懒汉、饿汉、双重检验锁、静态内部类、枚举。上述所说都是线程安全的实现，文章给出的第2种方法不算正确的写法。<br>一般情况下直接使用饿汉式就好了，如果明确要求要懒加载（lazy initialization）会倾向于使用静态内部类，如果涉及到反序列化创建对象时，可以使用枚举的方式来实现单例。如果有其他特殊的需求，可以考虑使用双检锁方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java成神之路进阶篇之设计模式。&lt;br&gt;不积跬步无以至千里，不积小流无以成江海。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java成神之路基础篇-基础知识</title>
    <link href="http://yoursite.com/2019/03/07/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E5%9F%BA%E7%A1%80%E7%AF%87-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/03/07/java成神之路基础篇-基础知识/</id>
    <published>2019-03-07T05:58:26.000Z</published>
    <updated>2019-03-14T13:08:40.055Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p>java成神之路基础篇之基础知识。<br>不积跬步无以至千里，不积小流无以成江海。<br><a id="more"></a></p></blockquote><hr><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="8种基本数据类型：整型、浮点型、布尔型、字符型"><a href="#8种基本数据类型：整型、浮点型、布尔型、字符型" class="headerlink" title="8种基本数据类型：整型、浮点型、布尔型、字符型"></a>8种基本数据类型：整型、浮点型、布尔型、字符型</h3><ul><li>整型(4种)<ul><li>byte：8位</li><li>short: 16位</li><li>int: 32位</li><li>long: 64位</li></ul></li><li>浮点型(2种)<ul><li>float: 32位。直接赋值时必须在数字后加上f或F</li><li>double：64位。赋值时可以加d或D也可以不加</li></ul></li><li>布尔型(1种)<ul><li>boolean：true,false</li></ul></li><li>字符型(1种)<ul><li>char：16位。==本质是数，故是整数类型，可以用<code>+</code>连接，内部是先转换成数字相加，再转回char==</li></ul></li></ul><h3 id="什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？"><a href="#什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？" class="headerlink" title="什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？"></a>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？</h3><ul><li>浮点类型，即带小数部分的数据。有两种常用数据类型：float类型，double类型。<ul><li>表示形式有十进制数形式、科学计数法形式（例如，5.12e2（5.12<em>10^2）,5.12E2（5.12</em>10^2）,e或E代表指数为10）。</li><li>三种特殊的浮点数值：正无穷大（正数除以0，POSITIVE_INFINITY表示）、负无穷大（负数除以0，NEGATIVE_INFINITY表示）、非数（0.0除以0.0，或一个负数开方得到一个非数，NaN表示，NaN不与任何数值相等，包括NaN）。</li></ul></li><li>单精度和双精度<ul><li>单精度(float)：1位符号，8位指数，23位小数。<br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic1.png" alt=""><br>精度主要取决于尾数部分的位数，float为23位，除去全部为0的情况以外，最小为2的-23次方，约等于1.19乘以10的-7次方，==所以float小数部分只能精确到后面6位==，加上小数点前的一位，即有效数字为7位</li><li>双精度(double)：1位符号，11位指数，52位小数<br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic2.png" alt=""><br>double 尾数部分52位，最小为2的-52次方，约为2.22乘以10的-16次方，==所以精确到小数点后15位==，有效位数为16位</li></ul></li><li>不能用浮点型表示金额-<code>精度丢失</code><br><code>在程序里写的10进制小数，计算机内部无法用二进制的小数来精确的表达。原因在于：</code><br>由于浮点数在计算机内部的表达方式如上图：符号位+阶码+尾数，因此对于二进制小数，小数点右边能表达的值是 1/2, 1/4, 1/8, 1/16, 1/32, 1/64, 1/128 … 1/(2^n），因此并不能够正确表示10进制的小数值。<br><code>实例：</code><br>可以这样查看一下一个float的内部表示（以0.09f为例）：<br><code>Float.floatToRawIntBits(0.09f)</code><br>你将会得到：1035489772， 这是10进制的， 转化成二进制， 在前面加几个0补足 32位就是：<br><code>0 01111011 01110000101000111101100</code><br>你可以看到它分成了3段：第一段代表了符号(s) : 0 正数；第二段是阶码(e)：01111011，对应的10进制是123；第三段是尾数(M)。<br>你看到了尾数和阶码，就会明白这其实是所谓的科学计数法: (-1)^s <em> M </em> 2^e<br>对于阶码e，一共有8位，这是个有符号数， 特别是按照IEEE754规范， 如果不是0或者255， 那就需要减去一个叫偏置量的值，对于float 是127。所以 E = e - 127 = 123-127 = -4<br>对于尾数M ，如果阶码不是0或者255， 他其实隐藏了一个小数点左边的一个1（节省空间，充分压榨每一个bit啊）。即 M = 1.01110000101000111101100<br>现在写出来就是:<br>1.01110000101000111101100 * 2^-4<br>=0.000101110000101000111101100<br>= 1/16 + 1/64 + 1/128+ 1/256 + ….<br>= 0.0900000035762786865234375<br><code>结论：</code>这就是0.09的内部表示， 很明显他比0.09更大一些， 是不精确的！</li></ul><h2 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h2><h3 id="什么是包装类型、什么是基本类型、什么是自动拆装箱"><a href="#什么是包装类型、什么是基本类型、什么是自动拆装箱" class="headerlink" title="什么是包装类型、什么是基本类型、什么是自动拆装箱"></a>什么是包装类型、什么是基本类型、什么是自动拆装箱</h3><blockquote><p>在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等。那么，想实现字符串与基本数据之间转换怎么办呢？</p></blockquote><p>Java中提供了相应的对象来解决该问题，<code>基本数据类型对象包装类</code>：java将基本数据类型值封装成了对象。封装成对象有什么好处？可以提供更多的操作基本数值的功能。<br>8种基本类型对应的包装类如下：<br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic3.png" alt=""><br>其中需要注意int对应的是Integer，char对应的Character，其他6个都是基本类型首字母大写即可。<br><code>基本数据类型对象包装类特点：用于在基本数据和字符串之间进行转换:</code></p><ul><li><p>将字符串转成基本类型：<br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic4.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(Integer.parseInt(<span class="string">"123"</span>) + <span class="number">2</span>);</span><br><span class="line"><span class="comment">//打印结果为 125</span></span><br></pre></td></tr></table></figure><ul><li>将基本数值转成字符串有3种方式：<ul><li>基本类型直接与<code>&quot;&quot;</code>相连接即可；<code>34+&quot;&quot;</code></li><li>调用String的valueOf方法；String.valueOf(34)；<br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic5.png" alt=""></li><li>调用包装类中的toString方法；Integer.toString(34)；<br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic6.png" alt=""></li></ul></li></ul></li><li>基本类型和对象转换<br>使用int类型与Integer对象转换进行演示，其他基本类型转换方式相同。<ul><li>基本数值—-&gt;包装对象<br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic7.png" alt=""><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">4</span>);<span class="comment">//使用构造函数函数</span></span><br><span class="line">Integer ii = <span class="keyword">new</span> Integer(<span class="string">"4"</span>);<span class="comment">//构造函数中可以传递一个数字字符串</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p><img src="/2019/03/07/java成神之路基础篇-基础知识/pic8.png" alt=""><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer iii = Integer.valueOf(<span class="number">4</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br><span class="line">Integer iiii = Integer.valueOf(<span class="string">"4"</span>);<span class="comment">//使用包装类中的valueOf方法</span></span><br></pre></td></tr></table></figure></p><ul><li>包装对象—-&gt;基本数值<br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic9.png" alt=""><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = i.intValue();</span><br></pre></td></tr></table></figure></li></ul><ul><li>自动装箱拆箱<br>在需要的情况下，基本类型与包装类型可以通用。有些时候我们必须使用引用数据类型时，可以传入基本数据类型。<blockquote><p>比如：基本类型可以使用运算符直接进行计算，但是引用类型不可以。而基本类型包装类作为引用类型的一种却可以计算，原因在于，Java”偷偷地”自动地进行了对象向基本数据类型的转换。</p></blockquote></li></ul><p>相对应的，引用数据类型变量的值必须是new出来的内存空间地址值，而我们可以将一个基本类型的值赋值给一个基本类型包装类的引用。原因同样在于Java又”偷偷地”自动地进行了基本数据类型向对象的转换。</p><blockquote><ol><li>自动拆箱：对象转成基本数值</li><li>自动装箱：基本数值转成对象</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">4</span>;<span class="comment">//自动装箱。相当于Integer i = Integer.valueOf(4);</span></span><br><span class="line">i = i + <span class="number">5</span>;<span class="comment">//等号右边：将i对象转成基本数值(自动拆箱) i.intValue() + 5; 加法运算完成后，再次装箱，把基本数值转成对象。</span></span><br></pre></td></tr></table></figure><blockquote><ol><li>自动装箱(byte常量池)细节的演示:<br>当数值在byte范围之内时，进行自动装箱，不会新创建对象空间而是使用原来已有的空间。</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Integer b = <span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">System.out.println(a==b);<span class="comment">//false</span></span><br><span class="line">System.out.println(a.equals(b));<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"---------------------"</span>);</span><br><span class="line">Integer x = <span class="number">127</span>;</span><br><span class="line">Integer y = <span class="number">127</span>;</span><br><span class="line"><span class="comment">//在jdk1.5自动装箱时，如果数值在byte范围之内，不会新创建对象空间而是使用原来已有的空间。</span></span><br><span class="line">System.out.println(x==y); <span class="comment">//true</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><h3 id="Integer-的缓存机制"><a href="#Integer-的缓存机制" class="headerlink" title="Integer 的缓存机制"></a>Integer 的缓存机制</h3><p><code>实例：</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaIntegerCache</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String... strings)</span> </span>&#123;</span><br><span class="line">        Integer integer1 = <span class="number">3</span>;</span><br><span class="line">        Integer integer2 = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (integer1 == integer2)</span><br><span class="line">            System.out.println(<span class="string">"integer1 == integer2"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"integer1 != integer2"</span>);</span><br><span class="line">        Integer integer3 = <span class="number">300</span>;</span><br><span class="line">        Integer integer4 = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">if</span> (integer3 == integer4)</span><br><span class="line">            System.out.println(<span class="string">"integer3 == integer4"</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"integer3 != integer4"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//output</span></span><br><span class="line">integer1 == integer2</span><br><span class="line">integer3 != integer4</span><br></pre></td></tr></table></figure></p><p>在Java中，== 比较的是对象引用，而equals比较的是值。但是由于Integer的缓存机制，通过使用相同的对象引用实现了缓存和重用。这种Integer缓存策略仅在自动装箱(autoboxing)(相当于调用valueOf方法)的时候有用，使用构造器创建的 Integer 对象不能被缓存。上面的规则适用于整数区间 -128 到 +127。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (i &amp;amp;gt;= IntegerCache.low &amp;amp;amp;&amp;amp;amp; i &amp;amp;lt;= IntegerCache.high)</span><br><span class="line">           <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>在创建新的Integer对象之前会先在 IntegerCache.cache 中查找。有一个专门的 Java 类来负责 Integer 的缓存。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &amp;amp;lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &amp;amp;gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>Javadoc 详细的说明这个类是用来实现缓存支持，并支持 -128 到 127 之间的自动装箱过程。最大值 127 可以通过 JVM 的启动参数 -XX:AutoBoxCacheMax=size 修改。 缓存通过一个 for 循环实现。从小到大的创建尽可能多的整数并存储在一个名为 cache 的整数数组中。这个缓存会在 Integer 类第一次被使用的时候被初始化出来。以后，就可以使用缓存中包含的实例对象，而不是创建一个新的实例(在自动装箱的情况下)。</p><ul><li>其他缓存对象<br>有 ByteCache 用于缓存 Byte 对象；有 ShortCache 用于缓存 Short 对象；有 LongCache 用于缓存 Long 对象；有 CharacterCache 用于缓存 Character 对象。<br>Byte，Short，Long 有固定范围: -128 到 127。对于 Character, 范围是 0 到 127。除了 Integer 可以通过参数改变范围外，其它的都不行。</li></ul><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="字符串的不可变性"><a href="#字符串的不可变性" class="headerlink" title="字符串的不可变性"></a>字符串的不可变性</h3><p><code>实例：</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String c1=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String c2=<span class="keyword">new</span> String(<span class="string">"abc"</span>);</span><br><span class="line">String c3=c1;</span><br><span class="line">c1 = <span class="string">"han"</span></span><br></pre></td></tr></table></figure></p><p><img src="/2019/03/07/java成神之路基础篇-基础知识/pic10.png" alt=""><br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic11.png" alt=""><br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic12.png" alt=""><br>一旦一个String对象在内存中创建，它将是不可改变的，所有的String类中方法并不是改变String对象自己，而是重新创建一个新的String对象。这就是<code>字符串的不可变性</code>。<br><code>使用StringBuffer 或者 StringBuilder可以修改字符串</code>。</p><h3 id="JDK-6-和-JDK-7-中-substring-的原理及区别"><a href="#JDK-6-和-JDK-7-中-substring-的原理及区别" class="headerlink" title="JDK 6 和 JDK 7 中 substring 的原理及区别"></a>JDK 6 和 JDK 7 中 substring 的原理及区别</h3><p><code>substring(start, end)</code>截取字符串的某一段子字符串。</p><h4 id="JDK-6"><a href="#JDK-6" class="headerlink" title="JDK 6"></a>JDK 6</h4><p><img src="/2019/03/07/java成神之路基础篇-基础知识/pic13.png" alt=""><br>String是通过字符数组实现的。在jdk 6 中，String类包含三个成员变量：char value[]， int offset，int count。他们分别用来存储真正的字符数组，数组的第一个位置索引以及字符串中包含的字符个数。<br>当调用substring方法的时候，会创建一个新的string对象，但是这个string的值仍然指向堆中的同一个字符数组。这两个对象中只有count和offset 的值是不同的。<br><code>导致的问题：</code>如果你有一个很长很长的字符串，但是当你使用substring进行切割的时候你只需要很短的一段。这可能导致性能问题，因为你需要的只是一小段字符序列，但是你却引用了整个字符串（因为这个非常长的字符数组一直在被引用，所以无法被回收，就可能导致内存泄露）。在JDK 6中，一般用以下方式来解决该问题，原理其实就是生成一个新的字符串并引用他。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = x.substring(x, y) + <span class="string">""</span></span><br></pre></td></tr></table></figure></p><h4 id="JDK-7"><a href="#JDK-7" class="headerlink" title="JDK 7"></a>JDK 7</h4><p><img src="/2019/03/07/java成神之路基础篇-基础知识/pic14.png" alt=""><br>在jdk 7 中，substring方法会在堆内存中创建一个新的数组。</p><h3 id="replaceFirst、replaceAll、replace-区别"><a href="#replaceFirst、replaceAll、replace-区别" class="headerlink" title="replaceFirst、replaceAll、replace 区别"></a>replaceFirst、replaceAll、replace 区别</h3><blockquote><p>replaceFirst与replaceAll中的匹配字符串用到了正则表达式，而replace则没有。</p></blockquote><p><code>实例：</code><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"my.test.txt"</span>;</span><br><span class="line">System.out.println(s.replace(<span class="string">"."</span>, <span class="string">"#"</span>));</span><br><span class="line">System.out.println(s.replaceAll(<span class="string">"."</span>, <span class="string">"#"</span>));</span><br><span class="line">System.out.println(s.replaceFirst(<span class="string">"."</span>, <span class="string">"#"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">my#test#txt</span><br><span class="line">###########</span><br><span class="line">#y.test.txt</span><br><span class="line"></span><br><span class="line">s.replaceFirst(<span class="string">"\\."</span>, <span class="string">"#"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//Output</span></span><br><span class="line">my#test.txt</span><br></pre></td></tr></table></figure></p><p>部分被正则表达式识别的字符列表：</p><ul><li><code>.</code>匹配除换行符以外的任意字符</li><li><code>^</code>匹配字符串的开始</li><li><code>$</code>匹配字符串的结束</li><li><code>*</code>重复零次或更多次</li><li><code>+</code>重复一次或更多次</li><li><code>?</code>重复零次或一次</li></ul><h3 id="String-对“-”的重载"><a href="#String-对“-”的重载" class="headerlink" title="String 对“+”的重载"></a>String 对“+”的重载</h3><p>在Java中是不支持重载运算符的，String的+是java中唯一的一个重载运算符，那么java使如何实现这个加号的呢？我们先看一段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">"yves"</span>;</span><br><span class="line">    String s2 = s1 + <span class="string">"he"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>反编译结果如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String s1 = <span class="string">"yves"</span>;</span><br><span class="line">    String s2 = (<span class="keyword">new</span> StringBuilder(String.valueOf(s1))).append(<span class="string">"he"</span>).toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>结论：</code>其实String对+的支持其实就是使用了StringBuilder以及他的append、toString两个方法。</p><h3 id="字符串拼接的几种方式和区别"><a href="#字符串拼接的几种方式和区别" class="headerlink" title="字符串拼接的几种方式和区别"></a>字符串拼接的几种方式和区别</h3><ul><li>直接用“+”号：jvm底层还是调用StringBuilder的append方法，每拼接一个字符串会创建对象，损耗性能。</li><li>使用String的方法concat：申请一个char类型的buf数组，将需要拼接的字符串都放在这个数组里，最后再转换成String对象。</li><li>使用StringBuilder的append：</li><li>使用StringBuffer的append：append方法加了sychronized关键字，因此是线程安全的。</li></ul><p><code>结论：</code></p><ul><li>无论如何直接用“+”号连接字符串都是最慢的</li><li>在拼接少数字符串（不超过4个）的时候，concat效率是最高的</li><li>多个字符串拼接的时候，StringBuilder/StringBuffer的效率是碾压的</li><li>在不需要考虑线程安全问题的时候，使用StringBuilder的效率比StringBuffer更高</li></ul><h3 id="String-valueOf-和-Integer-toString-的区别"><a href="#String-valueOf-和-Integer-toString-的区别" class="headerlink" title="String.valueOf 和 Integer.toString 的区别"></a>String.valueOf 和 Integer.toString 的区别</h3><p>二者都是将int转换成String类型的。<br>其中String.valueOf有大量的重载方法，其重载方法核心代码是将JAVA基本类型(int,double,boolean等)和对象(Object)通过不同的处理方式转换成String型，而String.valueOf(int)中调用了Integer.toString的方法。</p><h3 id="switch对String的支持"><a href="#switch对String的支持" class="headerlink" title="switch对String的支持"></a>switch对String的支持</h3><p>自java 1.7以后, java switch开始支持String类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (args[<span class="number">0</span>]) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">"A"</span> : <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"B"</span> : <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span> :</span><br><span class="line">&#125;<span class="comment">//switch</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>反编译得到：</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwitchString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SwitchString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] var0)</span> </span>&#123;</span><br><span class="line">        String var1 = var0[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">byte</span> var2 = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span>(var1.hashCode()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">65</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"A"</span>)) &#123;</span><br><span class="line">                var2 = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">66</span>:</span><br><span class="line">            <span class="keyword">if</span> (var1.equals(<span class="string">"B"</span>)) &#123;</span><br><span class="line">                var2 = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(var2) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>结论：</code>java中switch支持String，是利用String的hash值，本质上是switch-int结构。由于String的Hash可能会冲突，即两个不同的String可能计算出相同的hash值，因此利用到了equals方法来防止hash冲突的问题。最后利用switch-byte结构，精确匹配。</p><h3 id="字符串池、常量池（运行时常量池、Class-常量池）、intern"><a href="#字符串池、常量池（运行时常量池、Class-常量池）、intern" class="headerlink" title="字符串池、常量池（运行时常量池、Class 常量池）、intern"></a>字符串池、常量池（运行时常量池、Class 常量池）、intern</h3><h4 id="字符串池"><a href="#字符串池" class="headerlink" title="字符串池"></a>字符串池</h4><p>String类是我们使用频率非常高的一种对象类型。JVM为了提升性能和减少内存开销，避免字符串的重复创建，其维护了一块特殊的内存空间，即字符串池（String Pool）。字符串池由String类私有的维护。<br><code>创建字符串的两种方式：</code></p><ul><li>采用字面值的方式赋值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">'aaa'</span>;</span><br><span class="line">String str1 = <span class="string">'aaa'</span>;</span><br><span class="line">System.out.println(str == str1); <span class="comment">//output: True</span></span><br></pre></td></tr></table></figure></li></ul><p>采用字面值的方式创建一个字符串时，JVM首先会去字符串池中查找是否存在”aaa”这个对象，如果不存在，则在字符串池中创建”aaa”这个对象，然后将池中”aaa”这个对象的引用地址返回给字符串常量str，这样str会指向池中”aaa”这个字符串对象；如果存在，则不创建任何对象，直接将池中”aaa”这个对象的地址返回，赋给字符串常量。因此str与str1指向同一个对象的引用地址，这类似于<code>Integer的缓存机制，采用字面值方式赋值也类似于自动装箱</code>。</p><ul><li><code>new</code>关键字新建一个字符串对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String str3 = <span class="keyword">new</span> String(<span class="string">'aaa'</span>);</span><br><span class="line">String str4 = <span class="keyword">new</span> String(<span class="string">'aaa'</span>);</span><br><span class="line">System.out.println(str3 == str4); <span class="comment">//output: false</span></span><br></pre></td></tr></table></figure></li></ul><p>采用new关键字新建一个字符串对象时，JVM首先在字符串池中查找有没有”aaa”这个字符串对象，如果有，则不在池中再去创建”aaa”这个对象了，直接在堆中创建一个”aaa”字符串对象，然后将堆中的这个”aaa”对象的地址返回赋给引用str3，这样，str3就指向了堆中创建的这个”aaa”字符串对象；如果没有，则首先在字符串池中创建一个”aaa”字符串对象，然后再在堆中创建一个”aaa”字符串对象，然后将堆中这个”aaa”字符串对象的地址返回赋给str3引用，这样，str3指向了堆中创建的这个”aaa”字符串对象。<br><code>字符串池的实现有一个前提条件：</code>String对象是不可变的。因为这样可以保证多个引用可以同事指向字符串池中的同一个对象。如果字符串是可变的，那么一个引用操作改变了对象的值，对其他引用会有影响，这样显然是不合理的。<br><code>字符串池的优缺点：</code>字符串池的优点就是避免了相同内容的字符串的创建，节省了内存，省去了创建相同字符串的时间，同时提升了性能；另一方面，字符串池的缺点就是牺牲了JVM在常量池中遍历对象所需要的时间，不过其时间成本相比而言比较低。<br><code>总结：</code></p><ul><li>每一个字符串常量都指向字符串池中或者堆内存中的一个字符串实例；</li><li>字符串对象值是固定的，一旦创建就不能再修改；</li><li>字符串常量或者常量表达式中的字符串都被使用方法String.intern()在字符串池中保留了唯一的实例</li></ul><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"Hello"</span>;</span><br><span class="line">String s2 = <span class="string">"Hello"</span>;</span><br><span class="line">String s3 = <span class="string">"Hel"</span> + <span class="string">"lo"</span>;</span><br><span class="line">String s4 = <span class="string">"Hel"</span> + <span class="keyword">new</span> String(<span class="string">"lo"</span>);</span><br><span class="line">String s5 = <span class="keyword">new</span> String(<span class="string">"Hello"</span>);</span><br><span class="line">String s6 = s5.intern();</span><br><span class="line">String s7 = <span class="string">"H"</span>;</span><br><span class="line">String s8 = <span class="string">"ello"</span>;</span><br><span class="line">String s9 = s7 + s8;</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s3);  <span class="comment">// true</span></span><br><span class="line">System.out.println(s1 == s4);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s9);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s4 == s5);  <span class="comment">// false</span></span><br><span class="line">System.out.println(s1 == s6);  <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>平时所说的内存就是运行时数据区（Runtime Data Area），其中与字符串的创建有关的是方法区（Method Area）、堆区（Heap Area）和栈区（Stack Area）。</p><ul><li>方法区：存储类信息、常量、静态变量。全局共享。</li><li>堆区：存放对象和数组。全局共享。</li><li>栈区：基本数据类型、对象的引用都存放在这。线程私有</li></ul><p><code>关于常量池的JVM运行机制：</code></p><ul><li>.java文件编译后得到.class文件，里面包含了类的信息，其中有一块叫做常量池（Constant Pool）的区域，<code>.class常量池和内存中的常量池并不是一个东西</code></li><li>.class文件常量池主要存储的就包括字面量，字面量包括类中定义的常量，由于String是不可变的，所以字符串“Hello”就存放在这</li><li>当.class文件，即一个类被加载之后，类信息就存储在非堆的方法区中。在方法区中，有一块叫做<code>运行时常量池（Runtime Constant Pool）</code>,它是每个类私有的，每个class文件中的“常量池”被加载器加载之后就映射存放在这,但String不是。</li><li>String会在堆区中创建一个对象，同时会在字符串池（String Pool）存放一个它的引用。此时只是class类刚刚被加载，方法内部中的str并没有被创建，而String对象已经创建在于堆中。字符串池的位置在方法区上面的驻留字符串（Interned Strings）的位置，与运行时常量池是两个完全不同的存储区域，字符串常量池是全局共享的。字符串调用String.intern()方法后，其引用就存放在String Pool中。</li><li>当主线程开始创建str变量的，虚拟机会去字符串池中找是否有equals(“…”)的String，如果相等就把在字符串池中“…”的引用复制给str。如果找不到相等的字符串，就会在堆中新建一个对象，同时把引用驻留在字符串池，再把引用赋给str。</li><li>每当一个方法被执行时就会在栈区中创建一个栈帧（Stack Frame），基本数据类型和对象引用就存在栈帧中局部变量表（Local Variables）。</li></ul><h4 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h4><p><code>intern()</code>:常量池中存在当前字符串，就会直接返回当前字符串；如果常量池中没有此字符串，会将此字符串放入常量池中后，再返回。<br><code>版本的不同:</code><br>在JDK1.6中，调用str.intern()方法，则先在常量池中寻找是否有等于str的对象，若没有，然后会在堆中创建一个str的对象，并在常量池中存储它的引用并返回。然而在1.7中调用intern()，如果这个字符串在常量池中是第一次出现，则不会重新创建对象，直接返回它在堆中的引用。</p><h2 id="熟悉Java中各种关键字"><a href="#熟悉Java中各种关键字" class="headerlink" title="熟悉Java中各种关键字"></a>熟悉Java中各种关键字</h2><ul><li>Volatile：修饰的成员变量在每次被线程访问时，都强迫从主内存中重读该成员变量的值。而且，当成员变量发生变化时，强迫线程将变化值回写到主内存。这样在任何时刻，两个不同的线程总是看到某个成员变量的同一个值。</li><li>transient：需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。(这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化)</li><li>instanceof：一个二元操作符，和==、&gt;、&lt;是同一类的。测试它左边的对象是否是它右边的类的实例，返回boolean类型的数据</li><li>final(最终的不可被改变)：方法和类都可用final来修饰；final修饰的类是不能被继承的；final修饰的方法是不能被子类重写。常量的定义：final修饰的属性就是常量</li><li>static(静态的)：属性和方法都可以用static修饰，直接使用类名、属性和方法名。只有内部类可以使用static关键字修饰，调用直接使用类名、内部类类名进行调用。static可以独立存在</li><li>synchronized(线程，同步)：一个时间内只能有一个线程得到执行。另一个线程必须等待当前线程执行完这个代码块以后才能执行该代码块</li><li>const：常量，常数(用于修改字段或局部变量的声明)</li></ul><h2 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h2><p>collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set<br>Map<br>├Hashtable<br>├HashMap<br>└WeakHashMap</p><h3 id="ArrayList-和-LinkedList-和-Vector-的区别"><a href="#ArrayList-和-LinkedList-和-Vector-的区别" class="headerlink" title="ArrayList 和 LinkedList 和 Vector 的区别"></a>ArrayList 和 LinkedList 和 Vector 的区别</h3><ul><li>Arraylist和Vector是采用数组方式存储数据，此数组元素数大于实际存储的数据以便增加插入元素，都允许直接序号索引元素，但是插入数据要涉及到数组元素移动等内存操作，所以插入数据慢，查找有下标，所以查询数据快，Vector由于使用了synchronized方法-线程安全，所以性能上比ArrayList要差。<ul><li>ArrayList实现了可变大小的数组。它允许所有元素，包括null。ArrayList没有同步。size，isEmpty，get，set方法运行时间为常数。但是add方法开销为分摊的常数，添加n个元素需要O(n)的时间。其他的方法运行时间为线性。每个ArrayList实例都有一个容量（Capacity），即用于存储元素的数组的大小。这个容量可随着不断添加新元素而自动增加，但是增长算法并没有定义。当需要插入大量元素时，在插入前可以调用ensureCapacity方法来增加ArrayList的容量以提高插入效率。</li><li>Vector非常类似ArrayList，但是Vector是同步的。由Vector创建的Iterator，虽然和ArrayList创建的Iterator是同一接口，但是，因为Vector是同步的，当一个Iterator被创建而且正在被使用，另一个线程改变了Vector的状态（例如，添加或删除了一些元素），这时调用Iterator的方法时将抛出ConcurrentModificationException，因此必须捕获该异常。</li></ul></li><li>LinkedList使用双向链表实现存储，按序号索引数据需要进行向前或向后遍历，但是插入数据时只需要记录本项前后项即可，插入数据较快。<br>LinkedList的内部实现中，并不是用普通的数组来存放数据的，而是使用结点<node>来存放数据的，有一个指向链表头的结点first和一个指向链表尾的结点last。不同于ArrayList只能在数组末尾添加数据，LinkList可以很方便在链表头或者链表尾插入数据，或者在指定结点前后插入数据，还提供了取走链表头或链表尾的结点，或取走中间某个结点，还可以查询某个结点是否存在。add()方法默认在链表尾部插入数据。总之，LinkedList提供了大量方便的操作方法，并且它的插入或增加等方法的效率明显高于ArrayList类型，但是查询的效率要低一点，因为它是一个双向链表</node></li></ul><h3 id="SynchronizedList-和-Vector-的区别"><a href="#SynchronizedList-和-Vector-的区别" class="headerlink" title="SynchronizedList 和 Vector 的区别"></a>SynchronizedList 和 Vector 的区别</h3><ul><li>SynchronizedList中的add(),remove()等方法是使用同步代码块包裹ArrayList的方法实现的；Vector则是使用同步方法实现的。但是一方面ArrayList和Vector的底层实现基本一样</li><li>如果使用add方法，那么他们的扩容机制不一样(ArrayList和Vector的区别)</li><li>SynchronizedList可以指定锁定的对象</li><li>SynchronizedList有很好的扩展和兼容功能。他可以将所有的List的子类转成线程安全的类。</li><li>使用SynchronizedList的时候，进行遍历时要手动进行同步处理。</li></ul><h3 id="HashMap、HashTable、ConcurrentHashMap-区别"><a href="#HashMap、HashTable、ConcurrentHashMap-区别" class="headerlink" title="HashMap、HashTable、ConcurrentHashMap 区别"></a>HashMap、HashTable、ConcurrentHashMap 区别</h3><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><ul><li>底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化</li><li>初始size为11，扩容：newsize = oldsize*2+1</li><li>计算index的方法：index = (hash &amp; 0x7FFFFFFF) % tab.length</li></ul><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul><li>底层数组+链表实现，可以存储null键和null值，线程不安全</li><li>初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂</li><li>扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入</li><li>插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）</li><li>当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀</li><li>计算index方法：index = hash &amp; (tab.length – 1)</li></ul><p>HashMap的初始值还要考虑加载因子:</p><ul><li>哈希冲突：若干Key的哈希值按数组大小取模后，如果落在同一个数组下标上，将组成一条Entry链，对Key的查找需要遍历Entry链上的每个元素执行equals()比较。</li><li>加载因子：为了降低哈希冲突的概率，默认当HashMap中的键值对达到数组大小的75%时，即会触发扩容。因此，如果预估容量是100，即需要设定100/0.75＝134的数组大小。</li><li>空间换时间：如果希望加快Key查找的时间，还可以进一步降低加载因子，加大初始大小，以降低哈希冲突的概率。</li></ul><p>HashMap和Hashtable都是用hash算法来决定其元素的存储，因此HashMap和Hashtable的hash表包含如下属性：</p><ul><li>容量（capacity）：hash表中桶的数量</li><li>初始化容量（initial capacity）：创建hash表时桶的数量，HashMap允许在构造器中指定初始化容量</li><li>尺寸（size）：当前hash表中记录的数量</li><li>负载因子（load factor）：负载因子等于“size/capacity”。负载因子为0，表示空的hash表，0.5表示半满的散列表，依此类推。轻负载的散列表具有冲突少、适宜插入与查询的特点（但是使用Iterator迭代元素时比较慢）</li></ul><p>除此之外，hash表里还有一个“负载极限”，“负载极限”是一个0～1的数值，“负载极限”决定了hash表的最大填满程度。当hash表中的负载因子达到指定的“负载极限”时，hash表会自动成倍地增加容量（桶的数量），并将原有的对象重新分配，放入新的桶内，这称为rehashing。<br>HashMap和Hashtable的构造器允许指定一个负载极限，HashMap和Hashtable默认的“负载极限”为0.75，这表明当该hash表的3/4已经被填满时，hash表会发生rehashing。<br>“负载极限”的默认值（0.75）是时间和空间成本上的一种折中：</p><ul><li>较高的“负载极限”可以降低hash表所占用的内存空间，但会增加查询数据的时间开销，而查询是最频繁的操作（HashMap的get()与put()方法都要用到查询）</li><li>较低的“负载极限”会提高查询数据的性能，但会增加hash表所占用的内存开销<br>程序猿可以根据实际情况来调整“负载极限”值。</li></ul><h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><ul><li>层采用分段的数组+链表实现，线程安全</li><li>通过把整个Map分为N个Segment，可以提供相同的线程安全，但是效率提升N倍，默认提升16倍。(读操作不加锁，由于HashEntry的value变量是 volatile的，也能保证读取到最新的值。)</li><li>Hashtable的synchronized是针对整张Hash表的，即每次锁住整张表让线程独占，ConcurrentHashMap允许多个修改操作并发进行，其关键在于使用了锁分离技术</li><li>有些方法需要跨段，比如size()和containsValue()，它们可能需要锁定整个表而而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁</li><li>扩容：段内扩容（段内元素超过该段对应Entry数组长度的75%触发扩容，不会对整个Map进行扩容），插入前检测需不需要扩容，有效避免无效扩容</li></ul><p>Hashtable和HashMap都实现了Map接口，但是Hashtable的实现是基于Dictionary抽象类的。Java5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。</p><p>HashMap基于哈希思想，实现对数据的读写。当我们将键值对传递给put()方法时，它调用键对象的hashCode()方法来计算hashcode，然后找到bucket位置来存储值对象。当获取对象时，通过键对象的equals()方法找到正确的键值对，然后返回值对象。HashMap使用链表来解决碰撞问题，当发生碰撞时，对象将会储存在链表的下一个节点中。HashMap在每个链表节点中储存键值对对象。当两个不同的键对象的hashcode相同时，它们会储存在同一个bucket位置的链表中，可通过键对象的equals()方法来找到键值对。如果链表大小超过阈值（TREEIFY_THRESHOLD,8），链表就会被改造为树形结构。</p><p>在HashMap中，null可以作为键，这样的键只有一个，但可以有一个或多个键所对应的值为null。当get()方法返回null值时，即可以表示HashMap中没有该key，也可以表示该key所对应的value为null。因此，在HashMap中不能由get()方法来判断HashMap中是否存在某个key，应该用containsKey()方法来判断。而在Hashtable中，无论是key还是value都不能为null。</p><p>Hashtable是线程安全的，它的方法是同步的，可以直接用在多线程环境中。而HashMap则不是线程安全的，在多线程环境中，需要手动实现同步机制。</p><p>Hashtable与HashMap另一个区别是HashMap的迭代器（Iterator）是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。</p><p>先看一下简单的类图：<br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic15.png" alt=""><br>从类图中可以看出来在存储结构中ConcurrentHashMap比HashMap多出了一个类Segment，而Segment是一个可重入锁。</p><p>ConcurrentHashMap是使用了锁分段技术来保证线程安全的。</p><p>锁分段技术：首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p><p>ConcurrentHashMap提供了与Hashtable和SynchronizedMap不同的锁机制。Hashtable中采用的锁机制是一次锁住整个hash表，从而在同一时刻只能由一个线程对其进行操作；而ConcurrentHashMap中则是一次锁住一个桶。</p><p>ConcurrentHashMap默认将hash表分为16个桶，诸如get、put、remove等常用操作只锁住当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。</p><h3 id="Set-和-List-区别？Set-如何保证元素不重复？"><a href="#Set-和-List-区别？Set-如何保证元素不重复？" class="headerlink" title="Set 和 List 区别？Set 如何保证元素不重复？"></a>Set 和 List 区别？Set 如何保证元素不重复？</h3><ul><li>List继承了Collection，是有序的列表。<ul><li>数据取出方式：for、迭代器（Iterator）、增强for.</li><li>实现类有ArrayList、LinkedList、Vector、Stack等。<ul><li>①ArrayList是基于数组实现的，是一个数组队列。可以动态的增加容量.</li><li>②LinkedList是基于链表实现的，是一个双向循环列表。可以被当做堆栈使用.</li><li>③Vector是基于数组实现的，是一个矢量队列，是线程安全的.</li><li>④Stack是基于数组实现的，是栈，它继承与Vector，特性是FILO（先进后出）.</li></ul></li><li>List使用场景：<ul><li>在实际的应用中如果使用到队列，栈，链表，首先可以想到使用List。</li><li>不同的场景下面使用不同的工具类，效率才能更高。 <ul><li>①当集合中对插入元素数据的速度要求不高，但是要求快速访问元素数据，则使用ArrayList.</li><li>②当集合中对访问元素数据速度要求不高，但是对插入和删除元素数据速度要求高的情况，则使用LinkedList.</li><li>③当集合中有多线程对集合元素进行操作时候，则使用Vector.但是现在Vector现在一般不再使用，如需在多线程下使用，可以用CopyOnWriteArrayList，在java.util.concurrent包下。<br>④当集合中有需求是希望后保存的数据先读取出来，则使用Stack.</li></ul></li></ul></li></ul></li><li>set集合可以存储多个对象，但并不会记住元素的存储顺序，也不允许集合中有重复元素(不同的set集合有不同的判断方法)。<ul><li>数据取出方式有：迭代器（Iterator）、增强for循环.</li><li>实现类有HashSet、LinkedHashSet、TreeSet等。<ul><li>①HashSet采用哈希表结构存储数据，保证元素唯一性的方式依赖于：hashCode()与equals()方法.元素的存与取的顺序不能保证一致.允许放null值，只能一个null.</li><li>②LinkedHashSet元素唯一不能重复，底层结构是 哈希表结构 + 链表结构，元素的存与取的顺序一致.</li><li>③TreeSet的本质是一个”有序的，并且没有重复元素”的集合，它是二叉树实现的。TreeSet中的元素支持2种排序方式：自然排序或者根据创建TreeSet时提供的Comparator进行排序。不允许放入null值。</li></ul></li><li>Set使用场景：<ul><li>HashSet是基于Hash算法实现的，其性能通常都优于TreeSet。为快速查找而设计的</li><li>Set，通常都应该使用HashSet，在我们需要排序的功能时，才使用TreeSet。</li></ul></li></ul></li></ul><p><code>set保证元素不重复：</code><br>set中插入数据时，先比较hashCode：</p><ul><li>如果hashCode相同才会比较equals，equals相同，则两个对象相同，不能插入，equals不同，可以插入；</li><li>如果hashCode不同，就直接插入了，两个对象hashCode不相等，他们equals一定是false。</li></ul><h3 id="Java-8-中-stream-相关用法"><a href="#Java-8-中-stream-相关用法" class="headerlink" title="Java 8 中 stream 相关用法"></a>Java 8 中 stream 相关用法</h3><h3 id="apache-集合处理工具类的使用、不同版本的JDK中HashMap的实现的区别以及原因"><a href="#apache-集合处理工具类的使用、不同版本的JDK中HashMap的实现的区别以及原因" class="headerlink" title="apache 集合处理工具类的使用、不同版本的JDK中HashMap的实现的区别以及原因"></a>apache 集合处理工具类的使用、不同版本的JDK中HashMap的实现的区别以及原因</h3><h3 id="Collection-和-Collections-区别"><a href="#Collection-和-Collections-区别" class="headerlink" title="Collection 和 Collections 区别"></a>Collection 和 Collections 区别</h3><p><code>java.util.Collection</code> 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。<br> Collection<br>├List<br>│├LinkedList<br>│├ArrayList<br>│└Vector<br>│　└Stack<br>└Set<br><code>Collections</code>则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p><ul><li>排序(sort)</li><li>混排（Shuffling）</li><li>反转(Reverse)</li><li>替换所以的元素(Fill)</li><li>拷贝(Copy)</li><li>返回Collections中最小元素(min)</li><li>返回Collections中最大元素(max)</li><li>lastIndexOfSubList 返回指定源列表中最后一次出现指定目标列表的起始位置</li><li>IndexOfSubList 返回指定源列表中第一次出现指定目标列表的起始位置</li><li>Rotate 根据指定的距离循环移动指定列表中的元素</li></ul><h3 id="Arrays-asList-获得的-List-使用时需要注意什么"><a href="#Arrays-asList-获得的-List-使用时需要注意什么" class="headerlink" title="Arrays.asList 获得的 List 使用时需要注意什么"></a>Arrays.asList 获得的 List 使用时需要注意什么</h3><p>使用工具类Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的add/remove/clear方法会抛出UnsupportOperationException异常<br>说明：asList的返回对象是一个Arrays内部类,并没有实现集合的修改方法。Arrays.asList体现的是适配器模式，只是转换接口，后台的数据仍是数组。<br>Arrays.asList():</p><ul><li>该方法不适用于基本数据类型（byte,short,int,long,float,double,boolean）</li><li>该方法将数组与列表链接起来，当更新其中之一时，另一个自动更新</li><li>不支持add和remove方法</li></ul><p>asList返回的ArrayList并不是我们熟悉的java.util.ArrayList，而是另一个类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span> <span class="keyword">extends</span> <span class="title">AbstractList</span> </span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">RandomAccess</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br></pre></td></tr></table></figure></p><p>将其转化为等修改操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer[] datas = <span class="keyword">new</span> Integer[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">ArrayList arrayList = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(datas));</span><br></pre></td></tr></table></figure></p><h3 id="Enumeration-和-Iterator-区别"><a href="#Enumeration-和-Iterator-区别" class="headerlink" title="Enumeration 和 Iterator 区别"></a>Enumeration 和 Iterator 区别</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Iterator iter = table.entrySet().iterator();</span><br><span class="line"> <span class="keyword">while</span>(iter.hasNext()) &#123;</span><br><span class="line">     <span class="comment">//System.out.println("iter:"+iter.next());</span></span><br><span class="line">     iter.next();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> Enumeration enu = table.elements();</span><br><span class="line">   <span class="keyword">while</span>(enu.hasMoreElements()) &#123;</span><br><span class="line">       <span class="comment">//System.out.println("enu:"+enu.nextElement());</span></span><br><span class="line">       enu.nextElement();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><ul><li>函数接口不同<ul><li>Enumeration只有2个函数接口。通过Enumeration，我们只能读取集合的数据，而不能对数据进行修改。</li><li>Iterator只有3个函数接口。Iterator除了能读取集合的数据之外，也能数据进行删除操作。</li></ul></li><li>Iterator支持fail-fast机制，而Enumeration不支持。<ul><li>Enumeration 是JDK 1.0添加的接口。使用到它的函数包括Vector、Hashtable等类，这些类都是JDK 1.0中加入的，Enumeration存在的目的就是为它们提供遍历接口。Enumeration本身并没有支持同步，而在Vector、Hashtable实现Enumeration时，添加了同步。</li><li>而Iterator 是JDK 1.2才添加的接口，它也是为了HashMap、ArrayList等集合提供遍历接口。Iterator是支持fail-fast机制的：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。</li></ul></li></ul><h3 id="fail-fast-和-fail-safe"><a href="#fail-fast-和-fail-safe" class="headerlink" title="fail-fast 和 fail-safe"></a>fail-fast 和 fail-safe</h3><h4 id="快速失败（fail—fast）"><a href="#快速失败（fail—fast）" class="headerlink" title="快速失败（fail—fast）"></a>快速失败（fail—fast）</h4><p>在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修改），则会抛出Concurrent Modification Exception。</p><blockquote><p>原理：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p></blockquote><p>注意：这里异常的抛出条件是检测到 modCount！=expectedmodCount 这个条件。如果集合发生变化时修改modCount值刚好又设置为了expectedmodCount值，则异常不会抛出。因此，不能依赖于这个异常是否抛出而进行并发操作的编程，这个异常只建议用于检测并发修改的bug。</p><p>场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修改）。</p><h4 id="安全失败（fail—safe）"><a href="#安全失败（fail—safe）" class="headerlink" title="安全失败（fail—safe）"></a>安全失败（fail—safe）</h4><p>采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内容，在拷贝的集合上进行遍历。</p><blockquote><p>原理：由于迭代时是对原集合的拷贝进行遍历，所以在遍历过程中对原集合所作的修改并不能被迭代器检测到，所以不会触发Concurrent Modification Exception。</p></blockquote><p>缺点：基于拷贝内容的优点是避免了Concurrent Modification Exception，但同样地，迭代器并不能访问到修改后的内容，即：迭代器遍历的是开始遍历那一刻拿到的集合拷贝，在遍历期间原集合发生的修改迭代器是不知道的。</p><p>场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改。</p><table><thead><tr><th></th><th>Fail Fast Iterator</th><th>Fail Safe Iterator</th></tr></thead><tbody><tr><td>Throw ConcurrentModification Exception</td><td>Yes</td><td>No</td></tr><tr><td>Clone object</td><td>No</td><td>Yes</td></tr><tr><td>Memory Overhead</td><td>No</td><td>Yes</td></tr><tr><td>Examples</td><td>HashMap,Vector,ArrayList,HashSet</td><td>CopyOnWriteArrayList,ConcurrentHashMap</td></tr></tbody></table><h3 id="CopyOnWriteArrayList、ConcurrentSkipListMap"><a href="#CopyOnWriteArrayList、ConcurrentSkipListMap" class="headerlink" title="CopyOnWriteArrayList、ConcurrentSkipListMap"></a>CopyOnWriteArrayList、ConcurrentSkipListMap</h3><p>Java世界里存在两种实现key-value的数据结构：Hash、TreeMap，这两种数据结构各自都有着优缺点。</p><ul><li>Hash表：插入、查找最快，为O(1)；如使用链表实现则可实现无锁；数据有序化需要显式的排序操作。</li><li>红黑树：插入、查找为O(logn)，但常数项较小；无锁实现的复杂性很高，一般需要加锁；数据天然有序。</li></ul><p>然而，还有第三种实现key-value的数据结构：SkipList。SkipList有着不低于红黑树的效率，但是其原理和实现的复杂度要比红黑树简单多了。</p><h4 id="SkipList"><a href="#SkipList" class="headerlink" title="SkipList"></a>SkipList</h4><p>Skip List称之为跳表，它是一种可以替代平衡树的数据结构，其数据元素默认按照key值升序，天然有序。Skip list让已排序的数据分布在多层链表中，以0-1随机数决定一个数据的向上攀升与否，通过“空间来换取时间”的一个算法，在每个节点中增加了向前的指针，在插入、删除、查找时可以忽略一些不可能涉及到的结点，从而提高了效率。<br><code>特性：</code></p><ul><li>由很多层结构组成，level是通过一定的概率随机产生的</li><li>每一层都是一个有序的链表，默认是升序，也可以根据创建映射时所提供的Comparator进行排序，具体取决于使用的构造方法</li><li>最底层(Level 1)的链表包含所有元素</li><li>如果一个元素出现在Level i 的链表中，则它在Level i 之下的链表也都会出现</li><li>每个节点包含两个指针，一个指向同一链表中的下一个元素，一个指向下面一层的元素<br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic16.png" alt=""></li></ul><p><code>SkipList的查找：</code> (查找元素21)</p><ul><li>比较3，大于，往后找（9），</li><li>比9大，继续往后找（25），但是比25小，则从9的下一层开始找（16）</li><li>16的后面节点依然为25，则继续从16的下一层找</li><li>找到21</li></ul><p><code>SkipList的插入：</code></p><ul><li>查找合适的位置。这里需要明确一点就是在确认新节点要占据的层次K时，采用丢硬币的方式，完全随机。如果占据的层次K大于链表的层次，则重新申请新的层，否则插入指定层次</li><li>申请新的节点</li><li>调整指针<br><img src="/2019/03/07/java成神之路基础篇-基础知识/pic17.png" alt=""></li></ul><h4 id="ConcurrentSkipListMap"><a href="#ConcurrentSkipListMap" class="headerlink" title="ConcurrentSkipListMap"></a>ConcurrentSkipListMap</h4><p>ConcurrentSkipListMap其内部采用SkipLis数据结构实现。为了实现SkipList，ConcurrentSkipListMap提供了三个内部类来构建这样的链表结构：Node、Index、HeadIndex。其中Node表示最底层的单链表有序节点、Index表示为基于Node的索引层，HeadIndex用来维护索引层次。ConcurrentSkipListMap是通过HeadIndex维护索引层次，通过Index从最上层开始往下层查找，一步一步缩小查询范围，最后到达最底层Node时，就只需要比较很小一部分数据了。<br>具体见<code>API</code></p><h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>Copy-On-Write简称COW，是一种用于程序设计中的优化策略。其基本思路是，从一开始大家都在共享同一个内容，当某个人想要修改这个内容的时候，才会真正把内容Copy出去形成一个新的内容然后再改，这是一种延时懒惰策略。从JDK1.5开始Java并发包里提供了两个使用CopyOnWrite机制实现的并发容器,它们是CopyOnWriteArrayList和CopyOnWriteArraySet。CopyOnWrite容器非常有用，可以在非常多的并发场景中使用到。<br><code>CopyOnWrite容器:</code><br>CopyOnWrite容器即写时复制的容器。通俗的理解是当我们往一个容器添加元素的时候，不直接往当前容器添加，而是先将当前容器进行Copy，复制出一个新的容器，然后新的容器里添加元素，添加完元素之后，再将原容器的引用指向新的容器。这样做的好处是我们可以对CopyOnWrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以CopyOnWrite容器也是一种读写分离的思想，读和写不同的容器。</p><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h3 id="枚举的用法"><a href="#枚举的用法" class="headerlink" title="枚举的用法"></a>枚举的用法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="comment">//直接引用</span></span><br><span class="line">        Day day =Day.MONDAY;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定义枚举类型</span></span><br><span class="line"><span class="keyword">enum</span> Day &#123;</span><br><span class="line">    MONDAY, TUESDAY, WEDNESDAY,</span><br><span class="line">    THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义枚举类型时我们使用的关键字是enum,枚举类型Day中分别定义了从周一到周日的值，这里要注意，值一般是大写的字母，多个值之间以逗号分隔。同时我们应该知道的是枚举类型可以像类(class)类型一样，定义为一个单独的文件，当然也可以定义在其他类内部，更重要的是枚举常量在类型安全性和便捷性都很有保证，如果出现类型问题编译器也会提示我们改进，但务必记住枚举表示的类型其取值是必须有限的，也就是说每个值都是可以枚举出来的</p><h3 id="枚举的实现"><a href="#枚举的实现" class="headerlink" title="枚举的实现"></a>枚举的实现</h3><p>在使用关键字enum创建枚举类型并编译后，编译器会为我们生成一个相关的类，这个类继承了Java API中的java.lang.Enum类，也就是说通过关键字enum创建枚举类型在编译后事实上也是一个类类型而且该类继承自java.lang.Enum类。<br><code>反编译如下：</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//反编译Day.class</span></span><br><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Day</span> <span class="keyword">extends</span> <span class="title">Enum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的values()方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Day[] values()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (Day[])$VALUES.clone();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//编译器为我们添加的静态的valueOf()方法，注意间接调用了Enum也类的valueOf方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Day <span class="title">valueOf</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (Day)Enum.valueOf(com/zejian/enumdemo/Day, s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//私有构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Day</span><span class="params">(String s, <span class="keyword">int</span> i)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(s, i);</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">//前面定义的7种枚举实例</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day MONDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day TUESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day WEDNESDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day THURSDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day FRIDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SATURDAY;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Day SUNDAY;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Day $VALUES[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;    </span><br><span class="line">        <span class="comment">//实例化枚举实例</span></span><br><span class="line">        MONDAY = <span class="keyword">new</span> Day(<span class="string">"MONDAY"</span>, <span class="number">0</span>);</span><br><span class="line">        TUESDAY = <span class="keyword">new</span> Day(<span class="string">"TUESDAY"</span>, <span class="number">1</span>);</span><br><span class="line">        WEDNESDAY = <span class="keyword">new</span> Day(<span class="string">"WEDNESDAY"</span>, <span class="number">2</span>);</span><br><span class="line">        THURSDAY = <span class="keyword">new</span> Day(<span class="string">"THURSDAY"</span>, <span class="number">3</span>);</span><br><span class="line">        FRIDAY = <span class="keyword">new</span> Day(<span class="string">"FRIDAY"</span>, <span class="number">4</span>);</span><br><span class="line">        SATURDAY = <span class="keyword">new</span> Day(<span class="string">"SATURDAY"</span>, <span class="number">5</span>);</span><br><span class="line">        SUNDAY = <span class="keyword">new</span> Day(<span class="string">"SUNDAY"</span>, <span class="number">6</span>);</span><br><span class="line">        $VALUES = (<span class="keyword">new</span> Day[] &#123;</span><br><span class="line">            MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从反编译的代码可以看出编译器确实帮助我们生成了一个Day类(注意该类是final类型的，将无法被继承)而且该类继承自java.lang.Enum类，该类是一个抽象类(稍后我们会分析该类中的主要方法)，除此之外，编译器还帮助我们生成了7个Day类型的实例对象分别对应枚举中定义的7个日期，这也充分说明了我们前面使用关键字enum定义的Day类型中的每种日期枚举常量也是实实在在的Day实例对象，只不过代表的内容不一样而已。注意编译器还为我们生成了两个静态方法，分别是values()和 valueOf()，稍后会分析它们的用法，到此我们也就明白了，使用关键字enum定义的枚举类型，在编译期后，也将转换成为一个实实在在的类，而在该类中，会存在每个在枚举类型中定义好变量的对应实例对象，如上述的MONDAY枚举类型对应public static final Day MONDAY;，同时编译器会为该类创建两个方法，分别是values()和valueOf()</p><p><code>枚举是线程安全的：</code><br>由反编译代码可知，枚举属性都是static类型的，因为static类型的属性会在类被加载之后被初始化，由Java的ClassLoader机制（源码级别）和Java类的加载、链接和初始化中可知，当一个Java类第一次被真正使用到的时候，静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，创建一个enum类型是线程安全的。</p><h3 id="Enum-类"><a href="#Enum-类" class="headerlink" title="Enum 类"></a>Enum 类</h3><p>Enum类是抽象类。ordinal()方法，该方法获取的是枚举变量在枚举类中声明的顺序，下标从0开始，如日期中的MONDAY在第一个位置，那么MONDAY的ordinal值就是0，如果MONDAY的声明位置发生变化，那么ordinal方法获取到的值也随之变化，注意在大多数情况下我们都不应该首先使用该方法，毕竟它总是变幻莫测的。compareTo(E o)方法则是比较枚举的大小，注意其内部实现是根据每个枚举的ordinal值大小进行比较的。name()方法与toString()几乎是等同的，都是输出变量的字符串形式。至于valueOf(Class<t> enumType, String name)方法则是根据枚举类的Class对象和枚举名称获取枚举常量，注意该方法是静态的。<code>具体看API</code><br><code>Attension:Enum类内部会有一个构造函数，该构造函数只能有编译器调用，我们是无法手动操作的</code></t></p><h3 id="枚举与单例"><a href="#枚举与单例" class="headerlink" title="枚举与单例"></a>枚举与单例</h3><p><code>用枚举实现的单例是最好的方式</code></p><ul><li>枚举写法简单<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EasySingleton&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>你可以通过<code>EasySingleton.INSTANCE</code>来访问。</p><ul><li>枚举自己处理序列化</li></ul><p>我们知道，以前的所有的单例模式都有一个比较大的问题，就是一旦实现了Serializable接口之后，就不再是单例得了，因为，每次调用 readObject()方法返回的都是一个新创建出来的对象，有一种解决办法就是使用readResolve()方法来避免此事发生。但是，为了保证枚举类型像Java规范中所说的那样，每一个枚举类型极其定义的枚举变量在JVM中都是唯一的，在枚举类型的序列化和反序列化上，Java做了<code>特殊的规定</code>：==在序列化的时候Java仅仅是将枚举对象的name属性输出到结果中，反序列化的时候则是通过java.lang.Enum的valueOf方法来根据名字查找枚举对象==。同时，编译器是不允许任何对这种序列化机制的定制的，因此禁用了writeObject、readObject、readObjectNoData、writeReplace和readResolve等方法。 我们看一下这个valueOf方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T extends Enum&lt;T&gt;&gt; <span class="function">T <span class="title">valueOf</span><span class="params">(Class&lt;T&gt; enumType,String name)</span> </span>&#123;  </span><br><span class="line">            T result = enumType.enumConstantDirectory().get(name);  </span><br><span class="line">            <span class="keyword">if</span> (result != <span class="keyword">null</span>)  </span><br><span class="line">                <span class="keyword">return</span> result;  </span><br><span class="line">            <span class="keyword">if</span> (name == <span class="keyword">null</span>)  </span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Name is null"</span>);  </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(  </span><br><span class="line">                <span class="string">"No enum const "</span> + enumType +<span class="string">"."</span> + name);  </span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>从代码中可以看到，代码会尝试从调用enumType这个Class对象的enumConstantDirectory()方法返回的map中获取名字为name的枚举对象，如果不存在就会抛出异常。再进一步跟到enumConstantDirectory()方法，就会发现到最后会以反射的方式调用enumType这个类型的values()静态方法，也就是上面我们看到的编译器为我们创建的那个方法，然后用返回结果填充enumType这个Class对象中的enumConstantDirectory属性。<br>所以，JVM对序列化有保证。</p><ul><li>枚举实例创建是thread-safe(线程安全的)<br>在Java的ClassLoader机制（源码级别）和Java类的加载、链接和初始化中，当一个Java类第一次被真正使用到的时候静态资源被初始化、Java类的加载和初始化过程都是线程安全的。所以，创建一个enum类型是线程安全的。</li></ul><h3 id="Java-枚举如何比较"><a href="#Java-枚举如何比较" class="headerlink" title="Java 枚举如何比较"></a>Java 枚举如何比较</h3><p>在枚举中使用<code>==</code>和equals比较效果是一样的，查看源码可以知道枚举的equals方法还是通过<code>==</code>来比较的</p><h3 id="switch-对枚举的支持"><a href="#switch-对枚举的支持" class="headerlink" title="switch 对枚举的支持"></a>switch 对枚举的支持</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;GREEN,RED,BLUE&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumDemo4</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printName</span><span class="params">(Color color)</span></span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (color)&#123;</span><br><span class="line">            <span class="keyword">case</span> BLUE: <span class="comment">//无需使用Color进行引用</span></span><br><span class="line">                System.out.println(<span class="string">"蓝色"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> RED:</span><br><span class="line">                System.out.println(<span class="string">"红色"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> GREEN:</span><br><span class="line">                System.out.println(<span class="string">"绿色"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        printName(Color.BLUE);</span><br><span class="line">        printName(Color.RED);</span><br><span class="line">        printName(Color.GREEN);</span><br><span class="line">        <span class="comment">//蓝色</span></span><br><span class="line">        <span class="comment">//红色</span></span><br><span class="line">        <span class="comment">//绿色</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="字符流、字节流、输入流、输出流、"><a href="#字符流、字节流、输入流、输出流、" class="headerlink" title="字符流、字节流、输入流、输出流、"></a>字符流、字节流、输入流、输出流、</h3><h3 id="同步、异步、阻塞、非阻塞、Linux-5种IO模型"><a href="#同步、异步、阻塞、非阻塞、Linux-5种IO模型" class="headerlink" title="同步、异步、阻塞、非阻塞、Linux 5种IO模型"></a>同步、异步、阻塞、非阻塞、Linux 5种IO模型</h3><h3 id="BIO、NIO-和-AIO-的区别、三种-IO-的用法与原理、netty"><a href="#BIO、NIO-和-AIO-的区别、三种-IO-的用法与原理、netty" class="headerlink" title="BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty"></a>BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty</h3><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="反射与工厂模式、反射有什么用"><a href="#反射与工厂模式、反射有什么用" class="headerlink" title="反射与工厂模式、反射有什么用"></a>反射与工厂模式、反射有什么用</h3><h3 id="Class-类、java-lang-reflect"><a href="#Class-类、java-lang-reflect" class="headerlink" title="Class 类、java.lang.reflect.*"></a>Class 类、java.lang.reflect.*</h3><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><h3 id="静态代理、动态代理"><a href="#静态代理、动态代理" class="headerlink" title="静态代理、动态代理"></a>静态代理、动态代理</h3><h3 id="动态代理和反射的关系"><a href="#动态代理和反射的关系" class="headerlink" title="动态代理和反射的关系"></a>动态代理和反射的关系</h3><h3 id="动态代理的几种实现方式"><a href="#动态代理的几种实现方式" class="headerlink" title="动态代理的几种实现方式"></a>动态代理的几种实现方式</h3><h3 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h3><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><h3 id="什么是序列化与反序列化"><a href="#什么是序列化与反序列化" class="headerlink" title="什么是序列化与反序列化"></a>什么是序列化与反序列化</h3><blockquote><p>把对象转换为字节序列的过程称为对象的序列化。<br>把字节序列恢复为对象的过程称为对象的反序列化。　　</p></blockquote><h3 id="为什么序列化"><a href="#为什么序列化" class="headerlink" title="为什么序列化"></a>为什么序列化</h3><p>对象的序列化主要有两种用途：</p><ul><li>把对象的字节序列永久地保存到硬盘上，通常存放在一个文件中；</li><li>在网络上传送对象的字节序列。</li></ul><p>在很多应用中，需要对某些对象进行序列化，让它们离开内存空间，入住物理硬盘，以便长期保存。比如最常见的是Web服务器中的Session对象，当有 10万用户并发访问，就有可能出现10万个Session对象，内存可能吃不消，于是Web容器就会把一些seesion先序列化到硬盘中，等要用了，再把保存在硬盘中的对象还原到内存中。</p><p>当两个进程在进行远程通信时，彼此可以发送各种类型的数据。无论是何种类型的数据，都会以二进制序列的形式在网络上传送。发送方需要把这个Java对象转换为字节序列，才能在网络上传送；接收方则需要把字节序列再恢复为Java对象。</p><p><code>序列化API：</code></p><ul><li>java.io.ObjectOutputStream代表对象输出流，它的writeObject(Object obj)方法可对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</li><li>java.io.ObjectInputStream代表对象输入流，它的readObject()方法从一个源输入流中读取字节序列，再把它们反序列化为一个对象，并将其返回。</li></ul><p><code>只有实现了Serializable和Externalizable接口的类的对象才能被序列化</code>。Externalizable接口继承自 Serializable接口，实现Externalizable接口的类完全由自身来控制序列化的行为，而仅实现Serializable接口的类可以 采用默认的序列化方式 。</p><p><code>对象序列化包括如下步骤：</code></p><ul><li>创建一个对象输出流，它可以包装一个其他类型的目标输出流，如文件输出流；</li><li>通过对象输出流的writeObject()方法写对象。</li></ul><p><code>对象反序列化的步骤如下：</code></p><ul><li>创建一个对象输入流，它可以包装一个其他类型的源输入流，如文件输入流；</li><li>通过对象输入流的readObject()方法读取对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line">ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(</span><br><span class="line">                          <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"E:/Person.txt"</span>)));</span><br><span class="line">oo.writeObject(person);</span><br><span class="line"><span class="comment">// 反序列化</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(</span><br><span class="line">                          <span class="keyword">new</span> File(<span class="string">"E:/Person.txt"</span>)));</span><br><span class="line">Person person = (Person) ois.readObject();</span><br></pre></td></tr></table></figure></li></ul><h3 id="序列化底层原理"><a href="#序列化底层原理" class="headerlink" title="序列化底层原理"></a>序列化底层原理</h3><p>具体可见(<a href="https://cloud.tencent.com/developer/article/1125165" target="_blank" rel="noopener">博客入口</a>)</p><h3 id="序列化与单例模式"><a href="#序列化与单例模式" class="headerlink" title="序列化与单例模式"></a>序列化与单例模式</h3><ul><li>单例：就是单例模式就是在整个全局中（无论是单线程还是多线程），该对象只存在一个实例，而且只应该存在一个实例，没有副本。</li><li>序列化对单例有破坏<ul><li>通过对某个对象的序列化与反序列化得到的对象是一个新的对象，这就破坏了单例模式的单例性。</li><li>我们知道readObject()的时候，底层运用了反射的技术，<br>序列化会通过反射调用无参数的构造方法创建一个新的对象。这破坏了对象的单例性。</li></ul></li><li>解决方案：<br>在需要的单例的对象类中添加<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> singleton;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>hasReadResolveMethod:如果实现了serializable 或者 externalizable接口的类中包含readResolve则返回true<br>invokeReadResolve:通过反射的方式调用要被反序列化的类的readResolve方法</p><h3 id="protobuf"><a href="#protobuf" class="headerlink" title="protobuf"></a>protobuf</h3><p><code>Protobuf是一个高性能、易扩展的序列化框架。</code></p><h3 id="为什么说序列化并不安全"><a href="#为什么说序列化并不安全" class="headerlink" title="为什么说序列化并不安全"></a>为什么说序列化并不安全</h3><p>因为序列化的对象数据转换为二进制，并且完全可逆。但是在RMI调用时所有private字段的数据都以明文二进制的形式出现在网络的套接字上，这显然是不安全的。<br><code>解决方案:</code></p><ul><li>序列化Hook化（移位和复位）</li><li>序列数据加密和签名</li><li>利用transient的特性解决</li><li>打包和解包代理</li></ul><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><h3 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h3><h3 id="Java-中常用注解使用"><a href="#Java-中常用注解使用" class="headerlink" title="Java 中常用注解使用"></a>Java 中常用注解使用</h3><h3 id="注解与反射的结合"><a href="#注解与反射的结合" class="headerlink" title="注解与反射的结合"></a>注解与反射的结合</h3><h3 id="Spring-常用注解"><a href="#Spring-常用注解" class="headerlink" title="Spring 常用注解"></a>Spring 常用注解</h3><h2 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h2><h3 id="什么是Java消息服务、JMS消息传送模型"><a href="#什么是Java消息服务、JMS消息传送模型" class="headerlink" title="什么是Java消息服务、JMS消息传送模型"></a>什么是Java消息服务、JMS消息传送模型</h3><h2 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h2><h3 id="java-lang-management"><a href="#java-lang-management" class="headerlink" title="java.lang.management.*"></a>java.lang.management.*</h3><h3 id="javax-management"><a href="#javax-management" class="headerlink" title="javax.management.*"></a>javax.management.*</h3><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="泛型与继承、类型擦除"><a href="#泛型与继承、类型擦除" class="headerlink" title="泛型与继承、类型擦除"></a>泛型与继承、类型擦除</h3><h3 id="泛型中-KTVE"><a href="#泛型中-KTVE" class="headerlink" title="泛型中 KTVE?"></a>泛型中 KTVE?</h3><h3 id="object-等的含义"><a href="#object-等的含义" class="headerlink" title="object 等的含义"></a>object 等的含义</h3><h3 id="泛型各种用法"><a href="#泛型各种用法" class="headerlink" title="泛型各种用法"></a>泛型各种用法</h3><h3 id="List-lt-object-gt-和原始类型List之间的区别"><a href="#List-lt-object-gt-和原始类型List之间的区别" class="headerlink" title="List&lt;object&gt;和原始类型List之间的区别"></a><code>List&lt;object&gt;</code>和原始类型List之间的区别</h3><h3 id="List-lt-gt-和List-lt-Object-gt-之间的区别是什么"><a href="#List-lt-gt-和List-lt-Object-gt-之间的区别是什么" class="headerlink" title="List&lt;?&gt;和List&lt;Object&gt;之间的区别是什么"></a><code>List&lt;?&gt;</code>和<code>List&lt;Object&gt;</code>之间的区别是什么</h3><h3 id="限定通配符和非限定通配符"><a href="#限定通配符和非限定通配符" class="headerlink" title="限定通配符和非限定通配符"></a>限定通配符和非限定通配符</h3><h3 id="上下界限定符-extends-和-super"><a href="#上下界限定符-extends-和-super" class="headerlink" title="上下界限定符 extends 和 super"></a>上下界限定符 extends 和 super</h3><h2 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h2><h3 id="junit"><a href="#junit" class="headerlink" title="junit"></a>junit</h3><h3 id="mock"><a href="#mock" class="headerlink" title="mock"></a>mock</h3><h3 id="mockito"><a href="#mockito" class="headerlink" title="mockito"></a>mockito</h3><h3 id="内存数据库（h2）"><a href="#内存数据库（h2）" class="headerlink" title="内存数据库（h2）"></a>内存数据库（h2）</h3><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="java-lang-util-regex"><a href="#java-lang-util-regex" class="headerlink" title="java.lang.util.regex.*"></a>java.lang.util.regex.*</h3><h2 id="常用的-Java-工具库"><a href="#常用的-Java-工具库" class="headerlink" title="常用的 Java 工具库"></a>常用的 Java 工具库</h2><h3 id="commons-lang"><a href="#commons-lang" class="headerlink" title="commons.lang"></a>commons.lang</h3><h3 id="commons"><a href="#commons" class="headerlink" title="commons.*..."></a><code>commons.*...</code></h3><h3 id="guava-libraries"><a href="#guava-libraries" class="headerlink" title="guava-libraries"></a>guava-libraries</h3><h3 id="netty"><a href="#netty" class="headerlink" title="netty"></a>netty</h3><h2 id="API-amp-SPI"><a href="#API-amp-SPI" class="headerlink" title="API &amp; SPI"></a>API &amp; SPI</h2><h3 id="API、API-和-SPI-的关系和区别"><a href="#API、API-和-SPI-的关系和区别" class="headerlink" title="API、API 和 SPI 的关系和区别"></a>API、API 和 SPI 的关系和区别</h3><h3 id="如何定义-SPI、SPI-的实现原理"><a href="#如何定义-SPI、SPI-的实现原理" class="headerlink" title="如何定义 SPI、SPI 的实现原理"></a>如何定义 SPI、SPI 的实现原理</h3><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常类型、正确处理异常、自定义异常"><a href="#异常类型、正确处理异常、自定义异常" class="headerlink" title="异常类型、正确处理异常、自定义异常"></a>异常类型、正确处理异常、自定义异常</h3><h3 id="Error-和-Exception"><a href="#Error-和-Exception" class="headerlink" title="Error 和 Exception"></a>Error 和 Exception</h3><h3 id="异常链、try-with-resources"><a href="#异常链、try-with-resources" class="headerlink" title="异常链、try-with-resources"></a>异常链、try-with-resources</h3><h3 id="finally-和-return-的执行顺序"><a href="#finally-和-return-的执行顺序" class="headerlink" title="finally 和 return 的执行顺序"></a>finally 和 return 的执行顺序</h3><h2 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h2><h3 id="时区、冬令时和夏令时、时间戳、Java-中时间-API"><a href="#时区、冬令时和夏令时、时间戳、Java-中时间-API" class="headerlink" title="时区、冬令时和夏令时、时间戳、Java 中时间 API"></a>时区、冬令时和夏令时、时间戳、Java 中时间 API</h3><h3 id="格林威治时间、CET-UTC-GMT-CST-几种常见时间的含义和关系"><a href="#格林威治时间、CET-UTC-GMT-CST-几种常见时间的含义和关系" class="headerlink" title="格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系"></a>格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系</h3><h3 id="SimpleDateFormat-的线程安全性问题"><a href="#SimpleDateFormat-的线程安全性问题" class="headerlink" title="SimpleDateFormat 的线程安全性问题"></a>SimpleDateFormat 的线程安全性问题</h3><h3 id="Java-8-中的时间处理"><a href="#Java-8-中的时间处理" class="headerlink" title="Java 8 中的时间处理"></a>Java 8 中的时间处理</h3><h3 id="如何在东八区的计算机上获取美国时间"><a href="#如何在东八区的计算机上获取美国时间" class="headerlink" title="如何在东八区的计算机上获取美国时间"></a>如何在东八区的计算机上获取美国时间</h3><h2 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h2><h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><h3 id="有了Unicode为啥还需要UTF-8"><a href="#有了Unicode为啥还需要UTF-8" class="headerlink" title="有了Unicode为啥还需要UTF-8"></a>有了Unicode为啥还需要UTF-8</h3><h3 id="GBK、GB2312、GB18030-之间的区别"><a href="#GBK、GB2312、GB18030-之间的区别" class="headerlink" title="GBK、GB2312、GB18030 之间的区别"></a>GBK、GB2312、GB18030 之间的区别</h3><h3 id="UTF8、UTF16、UTF32-区别"><a href="#UTF8、UTF16、UTF32-区别" class="headerlink" title="UTF8、UTF16、UTF32 区别"></a>UTF8、UTF16、UTF32 区别</h3><h3 id="URL编解码"><a href="#URL编解码" class="headerlink" title="URL编解码"></a>URL编解码</h3><h3 id="Big-Endian-和-Little-Endian"><a href="#Big-Endian-和-Little-Endian" class="headerlink" title="Big Endian 和 Little Endian"></a>Big Endian 和 Little Endian</h3><h3 id="如何解决乱码问题"><a href="#如何解决乱码问题" class="headerlink" title="如何解决乱码问题"></a>如何解决乱码问题</h3><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><h3 id="Java-中语法糖原理、解语法糖"><a href="#Java-中语法糖原理、解语法糖" class="headerlink" title="Java 中语法糖原理、解语法糖"></a>Java 中语法糖原理、解语法糖</h3><p>语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java成神之路基础篇之基础知识。&lt;br&gt;不积跬步无以至千里，不积小流无以成江海。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java成神之路基础篇-面向对象</title>
    <link href="http://yoursite.com/2019/03/01/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E5%9F%BA%E7%A1%80%E7%AF%87-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/03/01/java成神之路基础篇-面向对象/</id>
    <published>2019-03-01T08:02:01.000Z</published>
    <updated>2019-03-07T05:55:25.844Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p>java成神之路基础篇之面向对象，包括面向对象、平台无关性、值传递、封装、继承、多态<br>不积跬步无以至千里，不积小流无以成江海。<br><a id="more"></a></p></blockquote><hr><h2 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h2><h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><p>Object Oriented简称OO ：像C++，JAVA等语言。<br>面向对象是一种思想，是基于面向过程而言的。面向对象是将功能等封装至对象中，由对象实现解决问题的具体细节。因此不同于过程为主体的面向过程的思想，面向对象以对象，也就是数据为第一位，而方法或者是算法过程作为其次，这是对数据的一种优化，操作更加方便，简化了过程。<br>通俗实例：A、B、C一起打牌。<br>面向对象：<code>A.play_with(B, C)</code>或者<code>B.play_with(A, C)</code>或者<code>C.play_with(A, B)</code><br>解决问题：抽象出对象，由对象执行动作。  </p><h3 id="面向过程"><a href="#面向过程" class="headerlink" title="面向过程"></a>面向过程</h3><p>Procedure Oriented 简称PO ：像C语言。<br>面向过程在解决问题时，会将解决问题的过程拆分成一个个子过程，即为一个个方法函数。然后按照一定的顺序执行完这些方法，问题也就解决了。<br>通俗实例：A、B、C一起打牌。<br>面向过程：<code>play_with(A, B, C)</code><br>解决问题：拆分成动作，并将数据丢进去执行该动作。</p><h3 id="面向对象的三大基本特征和五大基本原则"><a href="#面向对象的三大基本特征和五大基本原则" class="headerlink" title="面向对象的三大基本特征和五大基本原则"></a>面向对象的三大基本特征和五大基本原则</h3><p>三大基本特征：</p><ul><li>封装：由面向对象思想将事物的属性以及解决问题的动作封装为对象，即抽象为类。封装性为一种基本特征，区别为对象的创建(可见<a href="http://jackeyzzhold.xyz/2018/11/02/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%AF%B9%E8%B1%A1/#more" target="_blank" rel="noopener">博客入口</a>)，是具体如何进行将事物抽象封装为对象的。</li><li>继承：</li><li>多态</li></ul><p>五大基本原则：</p><ul><li>单一职责原则(SRP)</li><li>开放封闭原则(OCP)</li><li>里氏替换原则(LSP)</li><li>依赖倒置原则(DIP)</li><li>接口分离原则(ISP)</li></ul><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装，就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承，指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过 “继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用 基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力。</p><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态，是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p><h4 id="单一职责原则SRP-Single-Responsibility-Principle"><a href="#单一职责原则SRP-Single-Responsibility-Principle" class="headerlink" title="单一职责原则SRP(Single Responsibility Principle)"></a>单一职责原则SRP(Single Responsibility Principle)</h4><p>是指一个类的功能要单一，不能包罗万象。如同一个人一样，分配的工作不能太多，否则一天到晚虽然忙忙碌碌的，但效率却高不起来。</p><h4 id="开放封闭原则OCP-Open－Close-Principle"><a href="#开放封闭原则OCP-Open－Close-Principle" class="headerlink" title="开放封闭原则OCP(Open－Close Principle)"></a>开放封闭原则OCP(Open－Close Principle)</h4><p>一个模块在扩展性方面应该是开放的而在更改性方面应该是封闭的。比如：一个网络模块，原来只服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将服务端和客户端分开，公共部分抽象出来。</p><h4 id="里式替换原则LSP-the-Liskov-Substitution-Principle-LSP"><a href="#里式替换原则LSP-the-Liskov-Substitution-Principle-LSP" class="headerlink" title="里式替换原则LSP(the Liskov Substitution Principle LSP)"></a>里式替换原则LSP(the Liskov Substitution Principle LSP)</h4><p>子类应当可以替换父类并出现在父类能够出现的任何地方。比如：公司搞年度晚会，所有员工可以参加抽奖，那么不管是老员工还是新员工，也不管是总部员工还是外派员工，都应当可以参加抽奖，否则这公司就不和谐了。</p><h4 id="依赖倒置原则DIP-the-Dependency-Inversion-Principle-DIP"><a href="#依赖倒置原则DIP-the-Dependency-Inversion-Principle-DIP" class="headerlink" title="依赖倒置原则DIP(the Dependency Inversion Principle DIP)"></a>依赖倒置原则DIP(the Dependency Inversion Principle DIP)</h4><p>具体依赖抽象，上层依赖下层。假设B是较A低的模块，但B需要使用到A的功能，这个时候，B不应当直接使用A中的具体类： 而应当由B定义一抽象接口，并由A来实现这个抽象接口，B只使用这个抽象接口：这样就达到了依赖倒置的目的，B也解除了对A的依赖，反过来是A依赖于B定义的抽象接口。通过上层模块难以避免依赖下层模块，假如B也直接依赖A的实现，那么就可能 造成循环依赖。一个常见的问题就是编译A模块时需要直接包含到B模块的cpp文件，而编译B时同样要直接包含到A的cpp文件。</p><h4 id="接口分离原则ISP-the-Interface-Segregation-Principle-ISP"><a href="#接口分离原则ISP-the-Interface-Segregation-Principle-ISP" class="headerlink" title="接口分离原则ISP(the Interface Segregation Principle ISP)"></a>接口分离原则ISP(the Interface Segregation Principle ISP)</h4><p>模块间要通过抽象接口隔离开，而不是通过具体的类强耦合起来</p><h4 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h4><p>简单地说，软件工程中对象之间的耦合度就是对象之间的依赖性。指导使用和维护对象的主要问题是对象之间的多重依赖性。对象之间的耦合越高，维护成本越高。因此对象的设计应使类和构件之间的耦合最小。</p><p>有软硬件之间的耦合，还有软件各模块之间的耦合。<br>耦合性是程序结构中各个模块之间相互关联的度量。它取决于各个模块之间的接口的复杂程度、调用模块的方式以及哪些信息通过接口。</p><p>耦合可以分为以下几种，它们之间的耦合度由高到低排列如下：</p><ul><li>内容耦合。<br>当一个模块直接修改或操作另一个模块的数据时，或一个模块不通过正常入口而转入另一个模块时，这样的耦合被称为内容耦合。内容耦合是最高程度的耦合，应该避免使用之。</li><li>公共耦合。<br>两个或两个以上的模块共同引用一个全局数据项，这种耦合被称为公共耦合。在具有大量公共耦合的结构中，确定究竟是哪个模块给全局变量赋了一个特定的值是十分困难的。</li><li>外部耦合。<br>一组模块都访问同一全局简单变量而不是同一全局数据结构，而且不是通过参数表传递该全局变量的信息，则称之为外部耦合。</li><li>控制耦合。<br>一个模块通过接口向另一个模块传递一个控制信号，接受信号的模块根据信号值而进行适当的动作，这种耦合被称为控制耦合。</li><li>标记耦合。<br>若一个模块A通过接口向两个模块B和C传递一个公共参数，那么称模块B和C之间存在一个标记耦合。<br>数据耦合。模块之间通过参数来传递数据，那么被称为数据耦合。数据耦合是最低的一种耦合形式，系统中一般都存在这种类型的耦合，因为为了完成一些有意义的功能，往往需要将某些模块的输出数据作为另一些模块的输入数据。</li><li>非直接耦合。<br>两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用来实现的。</li></ul><p><code>总结</code>:<br>耦合是影响软件复杂程度和设计质量的一个重要因素，在设计上我们应采用以下原则：如果模块间必须存在耦合，就尽量使用数据耦合，少用控制耦合，限制公共耦合的范围，尽量避免使用内容耦合。</p><h4 id="内聚与耦合"><a href="#内聚与耦合" class="headerlink" title="内聚与耦合"></a>内聚与耦合</h4><p>内聚标志一个模块内各个元素彼此结合的紧密程度，它是信息隐蔽和局部化概念的自然扩展。内聚是从功能角度来度量模块内的联系，一个好的内聚模块应当恰好做一件事。它描述的是模块内的功能联系。<br>耦合是软件结构中各模块之间相互连接的一种度量，耦合强弱取决于模块间接口的复杂程度、进入或访问一个模块的点以及通过接口的数据。 程序讲究的是低耦合，高内聚。就是同一个模块内的各个元素之间要高度紧密，但是各个模块之间的相互依存度却要不那么紧密。<br>内聚和耦合是密切相关的，同其他模块存在高耦合的模块意味着低内聚，而高内聚的模块意味着该模块同其他模块之间是低耦合。在进行软件设计时，应力争做到高内聚，低耦合。</p><h2 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h2><p>java的虚拟机机制：</p><ul><li>先编写<code>.java</code>后缀的源程序文件</li><li>然后编译成<code>.class</code>结尾的字节码文件</li><li>然后不同的平台有对应的java虚拟机(比如windows有windows的java虚拟机,linux有linux的java虚拟机),不同的虚拟机都可以将<code>.class</code>文件解释成对应机器的机器码,这样就实现了一份源码,可以在不同的平台运行的目的,这就是java的平台无关性。此处平台就是指不同的操作系统</li></ul><h3 id="Java如何实现的平台无关性"><a href="#Java如何实现的平台无关性" class="headerlink" title="Java如何实现的平台无关性"></a>Java如何实现的平台无关性</h3><p>java是一门高级语言，它通过其他的低级语言来实现一个虚拟机，虽然平台不同，但是也可以使用不同的技术来实现一个功能相近的虚拟机，然后java程序在虚拟机上运行，就“与平台无关”了。 而c和c++也可以跨平台，但是需要在不同平台下编译。<br>java所宣扬的跨平台性实际上是所谓的“一次编译，到处执行”，即只需在一个地方编译，在其他各个平台下都可以执行。之所以会这样，是因为他们编译出来的东西是不同的，而且编译出来的东西运行在的地方也不同。<br>java编译出来的是一种“java字节码”，由虚拟机去解释执行。而c和c++则编译成了二进制，直接交由操作系统执行。<br>正是因为有了虚拟机，java才有了这样的一个特性。</p><h4 id="Java从四个方面支持平台无关"><a href="#Java从四个方面支持平台无关" class="headerlink" title="Java从四个方面支持平台无关"></a>Java从四个方面支持平台无关</h4><ul><li>最主要的是Java平台本身。Java平台扮演Java程序和所在的硬件与操作系统之间的缓冲角色。这样Java程序只需要与Java平台打交道，而不用管具体的操作系统。</li><li>Java语言保证了基本数据类型的值域和行为都是由语言自己定义的。而C/C++中，基本数据类是由它的占位宽度决定的，占位宽度由所在平台决定的。不同平台编译同一个C++程序会出现不同的行为。通过保证基本数据类型在所有平台的一致性，Java语言为平台无关性提供强有力的支持。</li><li>Java class文件。Java程序最终会被编译成二进制class文件。class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载运行。它的格式有着严格的定义，是平台无关的。</li><li>可伸缩性。Sun通过改变API的方式得到三个基础API集合，表现为Java平台不同的伸缩性：J2EE,J2SE,J2ME</li></ul><h4 id="实现平台无关的7大步骤"><a href="#实现平台无关的7大步骤" class="headerlink" title="实现平台无关的7大步骤"></a>实现平台无关的7大步骤</h4><ul><li>选择程序运行的主机和设备集合（目标宿主机）</li><li>在目标宿主机中选择Java平台版本。</li><li>对于每个目标宿主机，选择程序将要运行的Java平台实现（目标运行时环境） 。</li><li>编写程序，调用Java API标准运行库（不调用本地方法，或者专门开发商专门调用本地方法的库）</li><li>编写程序，不依赖于垃圾收集器收集垃圾时间，不依赖线程的优先级</li><li>努力设计用户界面，在所有的目标宿主机都能正常工作</li><li>在所有目标运行时环境和所有目标宿主机进行测试</li></ul><h3 id="JVM-还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）"><a href="#JVM-还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）" class="headerlink" title="JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）"></a>JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）</h3><h2 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h2><blockquote><p>形参：方法被调用时需要传递进来的参数，如：func(int a)中的a，它只有在func被调用期间a才有意义，也就是会被分配内存空间，在方法func执行完成后，a就会被销毁释放空间，也就是不存在了</p></blockquote><blockquote><p>实参：方法被调用时是传入的实际值，它在方法被调用前就已经被初始化并且在方法被调用时传入。</p></blockquote><h3 id="值传递-1"><a href="#值传递-1" class="headerlink" title="值传递"></a>值传递</h3><p>在方法被调用时，实参通过形参把它的内容副本传入方法内部，此时形参接收到的内容是实参值的一个拷贝，因此在方法内对形参的任何操作，都仅仅是对这个副本的操作，不影响原始值的内容。<br><code>实例如下：</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">valueCrossTest</span><span class="params">(<span class="keyword">int</span> age,<span class="keyword">float</span> weight)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"传入的age："</span>+age);</span><br><span class="line">    System.out.println(<span class="string">"传入的weight："</span>+weight);</span><br><span class="line">    age=<span class="number">33</span>;</span><br><span class="line">    weight=<span class="number">89.5f</span>;</span><br><span class="line">    System.out.println(<span class="string">"方法内重新赋值后的age："</span>+age);</span><br><span class="line">    System.out.println(<span class="string">"方法内重新赋值后的weight："</span>+weight);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">25</span>;</span><br><span class="line">        <span class="keyword">float</span> w=<span class="number">77.5f</span>;</span><br><span class="line">        valueCrossTest(a,w);</span><br><span class="line">        System.out.println(<span class="string">"方法执行后的age："</span>+a);</span><br><span class="line">        System.out.println(<span class="string">"方法执行后的weight："</span>+w);</span><br><span class="line">      &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传入的age：25</span></span><br><span class="line"><span class="comment">传入的weight：77.5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法内重新赋值后的age：33</span></span><br><span class="line"><span class="comment">方法内重新赋值后的weight：89.5</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">方法执行后的age：25</span></span><br><span class="line"><span class="comment">方法执行后的weight：77.5</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p><code>具体过程如下：</code><br>首先程序运行时，调用main()方法，此时JVM为main()方法往虚拟机栈中压入一个栈帧，即为当前栈帧，用来存放main()中的局部变量表(包括参数)、操作栈、方法出口等信息，如a和w都是main()方法中的局部变量，因此可以断定，a和w是躺着main方法所在的栈帧中。<br><img src="/2019/03/01/java成神之路基础篇-面向对象/pic1.png" alt=""><br>而当执行到valueCrossTest()方法时，JVM也为其往虚拟机栈中压入一个栈，即为当前栈帧，用来存放valueCrossTest()中的局部变量等信息，因此age和weight是躺着valueCrossTest方法所在的栈帧中，而他们的值是从a和w的值copy了一份副本而得。<br><img src="/2019/03/01/java成神之路基础篇-面向对象/pic2.png" alt=""><br>因而可以a和age、w和weight对应的内容是不一致的，所以当在方法内重新赋值时，实际流程如图：<br><img src="/2019/03/01/java成神之路基础篇-面向对象/pic3.png" alt=""><br>也就是说，<code>age和weight的改动，只是改变了当前栈帧（valueCrossTest方法所在栈帧）里的内容，当方法执行结束之后，这些局部变量都会被销毁，main方法所在栈帧重新回到栈顶，成为当前栈帧，再次输出a和w时，依然是初始化时的内容。</code><br><code>因此：</code></p><blockquote><p>值传递传递的是真实内容的一个副本，对副本的操作不影响原内容，也就是形参怎么变化，不会影响实参对应的内容。</p></blockquote><h3 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h3><blockquote><p>”引用”也就是指向真实内容的地址值，在方法调用时，实参的地址通过方法调用被传递给相应的形参，在方法体内，形参和实参指向通愉快内存地址，对形参的操作会影响的真实内容。</p></blockquote><p><code>实例1如下：</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> age;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age = age;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PersonCrossTest</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">         System.out.println(<span class="string">"传入的person的name："</span>+person.getName());</span><br><span class="line">         person.setName(<span class="string">"我是张小龙"</span>);</span><br><span class="line">         System.out.println(<span class="string">"方法内重新赋值后的name："</span>+person.getName());</span><br><span class="line">     &#125;</span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p=<span class="keyword">new</span> Person();</span><br><span class="line">        p.setName(<span class="string">"我是马化腾"</span>);</span><br><span class="line">        p.setAge(<span class="number">45</span>);</span><br><span class="line">        PersonCrossTest(p);</span><br><span class="line">        System.out.println(<span class="string">"方法执行后的name："</span>+p.getName());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传入的person的name：我是马化腾</span></span><br><span class="line"><span class="comment">方法内重新赋值后的name：我是张小龙</span></span><br><span class="line"><span class="comment">方法执行后的name：我是张小龙</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>可以看出，person经过personCrossTest()方法的执行之后，内容发生了改变，这印证了上面所说的“引用传递”，对形参的操作，<code>改变了实际对象的内容</code>。<br><code>实例2如下：增加一行代码</code><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">PersonCrossTest</span><span class="params">(Person person)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"传入的person的name："</span>+person.getName());</span><br><span class="line">        person=<span class="keyword">new</span> Person();<span class="comment">//加多此行代码</span></span><br><span class="line">        person.setName(<span class="string">"我是张小龙"</span>);</span><br><span class="line">        System.out.println(<span class="string">"方法内重新赋值后的name："</span>+person.getName());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">传入的person的name：我是马化腾</span></span><br><span class="line"><span class="comment">方法内重新赋值后的name：我是张小龙</span></span><br><span class="line"><span class="comment">方法执行后的name：我是马化腾</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>按照JVM内存模型可以知道，(<code>具体可见:</code><a href="http://jackeyzzhold.xyz/2018/03/11/java-JVM/" target="_blank" rel="noopener">博客入口</a>)，对象和数组是存储在Java堆区的，而且堆区是共享的，因此程序执行到main（）方法中的下列代码时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p=<span class="keyword">new</span> Person();</span><br><span class="line">p.setName(<span class="string">"我是马化腾"</span>);</span><br><span class="line">p.setAge(<span class="number">45</span>);</span><br><span class="line">PersonCrossTest(p);</span><br></pre></td></tr></table></figure></p><p>JVM会在堆内开辟一块内存，用来存储p对象的所有内容，同时在main（）方法所在线程的栈区中创建一个引用p存储堆区中p对象的真实地址，如图：<br><img src="/2019/03/01/java成神之路基础篇-面向对象/pic4.png" alt=""><br>当执行到PersonCrossTest()方法时，因为方法内有这么一行代码：<code>person = New Person()</code><br>JVM需要在堆内另外开辟一块内存来存储new Person()，假如地址为“xo3333”，那此时形参person指向了这个地址，假如真的是引用传递，那么由上面讲到：引用传递中形参实参指向同一个对象，形参的操作会改变实参对象的改变。</p><p>可以推出：实参也应该指向了新创建的person对象的地址，所以在执行PersonCrossTest()结束之后，最终输出的应该是后面创建的对象内容。</p><p>然而实际上，最终的输出结果却跟我们推测的不一样，最终输出的仍然是一开始创建的对象的内容。</p><p><code>由此可见：引用传递，在Java中并不存在。</code></p><p>但是有人会疑问：为什么第一个例子中，在方法内修改了形参的内容，会导致原始对象的内容发生改变呢？</p><p>这是因为：<code>无论是基本类型和是引用类型，在实参传入形参时，都是值传递，也就是说传递的都是一个副本，而不是内容本身。</code><br><img src="/2019/03/01/java成神之路基础篇-面向对象/pic5.png" alt=""><br>有图可以看出，方法内的形参person和实参p并无实质关联，它只是由p处copy了一份指向对象的地址，此时：</p><p>p和person都是指向同一个对象。</p><p>因此在第一个例子中，对形参p的操作，会影响到实参对应的对象内容。而在第二个例子中，当执行到<code>new Person()</code>之后，JVM在堆内开辟一块空间存储新对象，并且把person改成指向新对象的地址，此时：</p><p>p依旧是指向旧的对象，person指向新对象的地址。</p><p>所以此时对person的操作，实际上是对新对象的操作，于实参p中对应的对象毫无关系。</p><p><code>总结：</code></p><blockquote><p>因此可见：在Java中所有的参数传递，不管基本类型还是引用类型，都是值传递，或者说是副本传递。只是在传递过程中：如果是对基本数据类型的数据进行操作，由于原始内容和副本都是存储实际值，并且是在不同的栈区，因此形参的操作，不影响原始内容。如果是对引用类型的数据进行操作，分两种情况，一种是形参和实参保持指向同一个对象地址，则形参的操作，会影响实参指向的对象的内容。一种是形参被改动指向新的对象地址（如重新赋值引用），则形参的操作，不会影响实参指向的对象的内容。</p></blockquote><h2 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h2><h3 id="什么是多态、方法重写与重载"><a href="#什么是多态、方法重写与重载" class="headerlink" title="什么是多态、方法重写与重载"></a>什么是多态、方法重写与重载</h3><p><code>多态</code>就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量倒底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。因为在程序运行时才确定具体的类，这样，不用修改源程序代码，就可以让引用变量绑定到各种不同的类实现上，从而导致该引用调用的具体方法随之改变，即不修改程序代码就可以改变程序运行时所绑定的具体代码，让程序可以选择多个运行状态，这就是<code>多态性</code>。</p><h4 id="实现多态的三个条件：继承、重写、向上转型"><a href="#实现多态的三个条件：继承、重写、向上转型" class="headerlink" title="实现多态的三个条件：继承、重写、向上转型"></a>实现多态的三个条件：继承、重写、向上转型</h4><ul><li>继承：在多态中必须存在继承关系的父类与子类，才会有所谓的<code>向上转型</code></li><li>向上转型：在多态中将子类的引用赋给父类对象，此时该引用同时具备调用子类和父类的方法</li><li>重写：对父类的方法核心进行重新编写，参数与返回值不可改变。区别于重载，参数与返回值都可改变，是在一个类中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wine</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wine 的Fun....."</span>);</span><br><span class="line">        fun2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Wine 的Fun2..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JNC</span> <span class="keyword">extends</span> <span class="title">Wine</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@desc</span> 子类重载父类方法</span></span><br><span class="line"><span class="comment">     *        父类中不存在该方法，向上转型后，父类是不能引用该方法的</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> a</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> void</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun1</span><span class="params">(String a)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"JNC 的 Fun1..."</span>);</span><br><span class="line">        fun2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 子类重写父类方法</span></span><br><span class="line"><span class="comment">     * 指向子类的父类引用调用fun2时，必定是调用该方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"JNC 的Fun2..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Wine a = <span class="keyword">new</span> JNC();</span><br><span class="line">        a.fun1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------------------------</span><br><span class="line">Output:</span><br><span class="line">Wine 的Fun.....</span><br><span class="line">JNC 的Fun2...</span><br></pre></td></tr></table></figure><p><code>分析：</code>在这个程序中子类JNC重载了父类Wine的方法fun1()，重写fun2()，而且重载后的fun1(String a)与 fun1()不是同一个方法，由于父类中没有该方法，向上转型后会丢失该方法，所以执行JNC的Wine类型引用是不能引用fun1(String a)方法。而子类JNC重写了fun2() ，那么指向JNC的Wine引用会调用JNC中fun2()方法。<br>所以对于多态我们可以总结如下：</p><blockquote><p>指向子类的父类引用由于向上转型了，它只能访问父类中拥有的方法和属性，而对于子类中存在而父类中不存在的方法，该引用是不能使用的，尽管是重载该方法。若子类重写了父类中的某些方法，在调用该些方法的时候，必定是使用子类中定义的这些方法（动态连接、动态调用）。</p></blockquote><p>对于面向对象而言，多态分为编译时多态和运行时多态。其中编译时多态是静态的，主要是指方法的重载，它是根据参数列表的不同来区分不同的函数，通过编辑之后会变成两个不同的函数，在运行时谈不上多态。而运行时多态是动态的，它是通过动态绑定来实现的，也就是我们所说的多态性。<br><code>具体可见:</code><a href="https://www.cnblogs.com/chenssy/p/3372798.html" target="_blank" rel="noopener">博客入口</a></p><h3 id="构造函数与默认构造函数"><a href="#构造函数与默认构造函数" class="headerlink" title="构造函数与默认构造函数"></a>构造函数与默认构造函数</h3><p>构造函数也叫为构造器，是一个类用于初始化对象变量的，名称与类名相同。不接受任何参数的构造器叫做默认构造器，在类中若不存在构造器，则编译器会自动生成默认构造器，但是一旦类中已经存在默认构造器或者其他带参数形式的构造器，则编译器会忽视自动创建默认构造器这一过程。<br>虽然在初始化对象时<code>new Test()</code>中<code>new</code>表达式返回对对象的引用，但是构造器本身并没有返回值，是一种特殊类型的方法，与<code>void</code>返回也有所不同。</p><h3 id="类变量、成员变量与局部变量"><a href="#类变量、成员变量与局部变量" class="headerlink" title="类变量、成员变量与局部变量"></a>类变量、成员变量与局部变量</h3><ul><li><p>成员变量：定义在类中，方法体之外。变量在创建对象时实例化。成员变量可被类中的方法、构造方法以及特定类的语句块访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> printNumber（）&#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>类变量：定义在类中，方法体之外，但必须要有 static 来声明变量类型。静态成员属于整个类，可通过对象名或类名来调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> printNumber（）&#123;</span><br><span class="line">        <span class="comment">// 其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>局部变量：在方法、构造方法、语句块中定义的变量。其声明和初始化在方法中实现，在方法结束后自动销毁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span>  <span class="title">ClassName</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> printNumber（）&#123;</span><br><span class="line">        <span class="keyword">int</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><code>成员变量和类变量的区别：</code></p><ul><li>两个变量的生命周期不同<ul><li>成员变量随着对象的创建而存在，随着对象的回收而释放。</li><li>静态变量随着类的加载而存在，随着类的消失而消失。</li></ul></li><li>调用方式不同<ul><li>成员变量只能被对象调用。</li><li>静态变量可以被对象调用，还可以被类名调用。</li></ul></li><li>别名不同<ul><li>成员变量也称为实例变量。</li><li>静态变量也称为类变量。</li></ul></li><li>数据存储位置不同<ul><li>成员变量存储在堆内存的对象中，所以也叫对象的特有数据。</li><li>静态变量数据存储在方法区（共享数据区）的静态区，所以也叫对象的共享数据。</li></ul></li></ul><p><code>类变量特点：</code></p><ul><li>想要实现对象中的共性数据的对象共享。可以将这个数据进行静态修饰。</li><li>被静态修饰的成员，可以直接被类名所调用。也就是说，静态的成员多了一种调用方式。类名.静态方式。</li><li>静态随着类的加载而加载。而且优先于对象存在。</li></ul><p><code>类变量弊端：</code></p><ul><li>有些数据是对象特有的数据，是不可以被静态修饰的。因为那样的话，特有数据会变成对象的共享数据。这样对事物的描述就出了问题。所以，在定义静态时，必须要明确，这个数据是否是被对象所共享的。也就是可以理解为静态表现出来的就是数据的共享！！！</li><li>静态方法只能访问静态成员，不可以访问非静态成员。因为静态方法加载时，优先于对象存在，所以没有办法访问对象中的成员。</li><li>静态方法中不能使用this，super关键字。因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。</li></ul><h3 id="成员变量与方法作用域"><a href="#成员变量与方法作用域" class="headerlink" title="成员变量与方法作用域"></a>成员变量与方法作用域</h3><ul><li>public修饰符：对象本身、同一个包下、子类、其他包下对象都可以调用</li><li>protected修饰符：对象本身、同一个包下、子类对象可以调用</li><li>default修饰符：对象本身、同一个包下对象可以调用</li><li>private修饰符：对象本身可以调用，常用来修饰成员变量</li></ul><p><code>局部变量的作用域:</code><br>Java用一对大括号作为语句块的范围，称为作用域，作为在作用域里定义的一个变量，它只有在哪个作用域结束之前才可使用。离开作用域，变量所分配的内存空间将被JVM回收。<br><code>成员变量的作用域:</code><br>在同一作用域范围的包裹下成员变量名和局部变量名是可以变量名相同的，在同一个作用域范围的包裹下局部变量和局部变量不可以变量名相同（作用域内不能重复命名），在方法中使用变量的时候如果不指明使用成员变量还是局部变量，那么默认的就是使用局部的那个变量，但是如果局部变量超出了它本身的作用域范围则会失效，被JVM垃圾回收，那么则可以重复命名此变量，并使用最新定义的这个局部变量。<br><code>对象的作用域:</code><br>Java对象不具备与主类型一样的存在时间。用new关键字创建一个Java对象的时候，它会超出作用域的范围之外。所以假若使用下面这段代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">       String s = <span class="keyword">new</span> String(<span class="string">"a string"</span>);</span><br><span class="line">&#125; <span class="comment">/* 作用域的终点 */</span></span><br></pre></td></tr></table></figure></p><p>那么句柄s，也就是引用会在作用域的终点处消失。然而，s指向的String对象依然占据着内存空间。在上面这段代码里，我们没有办法继续使用这个对象，因为指向它的唯一一个句柄已经超出了作用域的边界。<br>这样造成的结果是：对于用new创建的对象，只要我们愿意，它们就会一直保留下去。这个编程问题在C和C++里特别突出。在C++里遇到的麻烦最大：由于不能从语言获得任何帮助，所以在需要对象的时候，根本无法确定它们是否可用。而且最麻烦的是，在C++里，一旦完成工作，必须保证将对象手动清除。<br>这样便带来了一个有趣的问题。假如 Java 让对象依然故我，怎样才能防止它们大量充斥内存，并最终造成程序的“凝固”呢。在 C++里，这个问题最令程序员头痛。但 Java 以后，情况却发生了改观。 Java 有一个特别的“垃圾收集器”，它会查找用 new 创建的所有对象，并辨别其中哪些不再被引用。随后，它会自动释放由那些闲置对象占据的内存，以便能由新对象使用。这意味着我们根本不必操心内存的回收问题。只需简单地创建对象，一旦不再需要它们，它们就会自动离去。这样做可防止在 C++里很常见的一个编程问题：由于程序员忘记释放内存造成的“内存溢出”。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;java成神之路基础篇之面向对象，包括面向对象、平台无关性、值传递、封装、继承、多态&lt;br&gt;不积跬步无以至千里，不积小流无以成江海。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java-成神之路</title>
    <link href="http://yoursite.com/2019/03/01/java-%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/03/01/java-成神之路/</id>
    <published>2019-03-01T02:20:03.000Z</published>
    <updated>2019-03-14T13:08:37.532Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p>借鉴前辈的java学习之路。<br>不积跬步无以至千里，不积小流无以成江海。<br><a id="more"></a></p></blockquote><hr><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="什么是面向对象"><a href="#什么是面向对象" class="headerlink" title="什么是面向对象"></a>什么是面向对象</h3><ul><li>面向对象</li><li>面向过程</li><li>面向对象的三大基本特征和五大基本原则</li></ul><h3 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h3><ul><li>Java 如何实现的平台无关</li><li>JVM 还支持哪些语言（Kotlin、Groovy、JRuby、Jython、Scala）</li></ul><h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><ul><li>值传递</li><li>引用传递</li><li>为什么说 Java 中只有值传递</li></ul><h3 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h3><ul><li>什么是多态、方法重写与重载</li><li>Java 的继承与实现</li><li>构造函数与默认构造函数</li><li>类变量、成员变量和局部变量</li><li>成员变量和方法作用域</li></ul><p><code>此part详情可见</code><a href="http://jackeyzzhold.xyz/2019/03/01/java%E6%88%90%E7%A5%9E%E4%B9%8B%E8%B7%AF%E5%9F%BA%E7%A1%80%E7%AF%87-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/#more" target="_blank" rel="noopener">博客入口</a></p><h2 id="Java-基础知识"><a href="#Java-基础知识" class="headerlink" title="Java 基础知识"></a>Java 基础知识</h2><h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul><li>8种基本数据类型：整型、浮点型、布尔型、字符型</li><li>整型中 byte、short、int、long 的取值范围</li><li>什么是浮点型？什么是单精度和双精度？为什么不能用浮点型表示金额？</li></ul><p>==一语概之==</p><blockquote><p>1、4种整型(byte、short、int、long)、2种浮点型(float、double)、boolean、char<br>2、byte：8bit、 short：16bit、 int：32bit、 long：64bit<br>3、数字型数据分为整型与浮点型，区别在于有无小数部分。浮点型即为存在小数的数字型数据。其中有效数字的不同(即为精度的不同)将浮点型分为单精度(float)与双精度(double)。浮点型数据在计算机内部的表示方法为符号位+阶码+尾数，其中尾数部分由于计算机内部只能识别二进制数，因此转换成十进制会导致精度丢失。因此不能用浮点数去表示金额这种精确要求极高的。</p></blockquote><h3 id="自动拆装箱"><a href="#自动拆装箱" class="headerlink" title="自动拆装箱"></a>自动拆装箱</h3><ul><li>什么是包装类型、什么是基本类型、什么是自动拆装箱</li><li>Integer 的缓存机制</li></ul><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><ul><li>字符串的不可变性</li><li>JDK 6 和 JDK 7 中 substring 的原理及区别、</li><li>replaceFirst、replaceAll、replace 区别、</li><li>String 对“+”的重载、字符串拼接的几种方式和区别</li><li>String.valueOf 和 Integer.toString 的区别、</li><li>switch 对 String 的支持</li><li>字符串池、常量池（运行时常量池、Class 常量池）、intern</li></ul><h3 id="熟悉-Java-中各种关键字"><a href="#熟悉-Java-中各种关键字" class="headerlink" title="熟悉 Java 中各种关键字"></a>熟悉 Java 中各种关键字</h3><ul><li>transient、instanceof、final、static、volatile、synchronized、const 原理及用法</li></ul><h3 id="集合类"><a href="#集合类" class="headerlink" title="集合类"></a>集合类</h3><ul><li>常用集合类的使用</li><li>ArrayList 和 LinkedList 和 Vector 的区别</li><li>SynchronizedList 和 Vector 的区别</li><li>HashMap、HashTable、ConcurrentHashMap 区别、</li><li>Set 和 List 区别？Set 如何保证元素不重复？</li><li>Java 8 中 stream 相关用法</li><li>apache 集合处理工具类的使用、不同版本的 JDK 中 HashMap 的实现的区别以及原因</li><li>Collection 和 Collections 区别</li><li>Arrays.asList 获得的 List 使用时需要注意什么</li><li>Enumeration 和 Iterator 区别</li><li>fail-fast 和 fail-safe</li><li>CopyOnWriteArrayList、ConcurrentSkipListMap</li></ul><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><ul><li>枚举的用法、枚举的实现、枚举与单例、Enum 类</li><li>Java 枚举如何比较</li><li>switch 对枚举的支持</li><li>枚举的序列化如何实现</li><li>枚举的线程安全性问题</li></ul><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><ul><li>字符流、字节流、输入流、输出流、</li><li>同步、异步、阻塞、非阻塞、Linux 5 种 IO 模型</li><li>BIO、NIO 和 AIO 的区别、三种 IO 的用法与原理、netty</li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ul><li>反射与工厂模式、反射有什么用</li><li>Class 类、java.lang.reflect.*</li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li>静态代理、动态代理</li><li>动态代理和反射的关系</li><li>动态代理的几种实现方式</li><li>AOP</li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul><li>什么是序列化与反序列化</li><li>为什么序列化</li><li>序列化底层原理</li><li>序列化与单例模式</li><li>protobuf</li><li>为什么说序列化并不安全</li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li>元注解</li><li>自定义注解</li><li>Java 中常用注解使用</li><li>注解与反射的结合</li><li>Spring 常用注解</li></ul><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>什么是Java消息服务、JMS消息传送模型</p><h3 id="JMX"><a href="#JMX" class="headerlink" title="JMX"></a>JMX</h3><ul><li>java.lang.management.*</li><li>javax.management.*</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><ul><li>泛型与继承、类型擦除</li><li>泛型中 KTVE?</li><li>object 等的含义</li><li>泛型各种用法</li><li><code>List&lt;object&gt;</code>和原始类型List之间的区别</li><li><code>List&lt;?&gt;</code>和<code>List&lt;Object&gt;</code>之间的区别是什么</li><li>限定通配符和非限定通配符</li><li>上下界限定符 extends 和 super</li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li>junit</li><li>mock</li><li>mockito</li><li>内存数据库（h2）</li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>java.lang.util.regex.*</p><h3 id="常用的-Java-工具库"><a href="#常用的-Java-工具库" class="headerlink" title="常用的 Java 工具库"></a>常用的 Java 工具库</h3><ul><li><code>commons.lang</code></li><li><code>commons.*...</code></li><li><code>guava-libraries</code></li><li><code>netty</code></li></ul><h3 id="API-amp-SPI"><a href="#API-amp-SPI" class="headerlink" title="API &amp; SPI"></a>API &amp; SPI</h3><ul><li>API、API 和 SPI 的关系和区别</li><li>如何定义 SPI、SPI 的实现原理</li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li>异常类型、正确处理异常、自定义异常</li><li>Error 和 Exception</li><li>异常链、try-with-resources</li><li>finally 和 return 的执行顺序</li></ul><h3 id="时间处理"><a href="#时间处理" class="headerlink" title="时间处理"></a>时间处理</h3><ul><li>时区、冬令时和夏令时、时间戳、Java 中时间 API</li><li>格林威治时间、CET,UTC,GMT,CST 几种常见时间的含义和关系</li><li>SimpleDateFormat 的线程安全性问题</li><li>Java 8 中的时间处理</li><li>如何在东八区的计算机上获取美国时间</li></ul><h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><ul><li>Unicode</li><li>有了Unicode为啥还需要UTF-8</li><li>GBK、GB2312、GB18030 之间的区别</li><li>UTF8、UTF16、UTF32 区别</li><li>URL编解码</li><li>Big Endian 和 Little Endian</li><li>如何解决乱码问题</li></ul><h3 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h3><ul><li>Java 中语法糖原理、解语法糖<br>语法糖：switch 支持 String 与枚举、泛型、自动装箱与拆箱、方法变长参数、枚举、内部类、条件编译、 断言、数值字面量、for-each、try-with-resource、Lambda 表达式</li></ul><h2 id="阅读源代码"><a href="#阅读源代码" class="headerlink" title="阅读源代码"></a>阅读源代码</h2><ul><li>String</li><li>Integer</li><li>Long</li><li>Enum</li><li>BigDecimal</li><li>ThreadLocal</li><li>ClassLoader &amp; URLClassLoader、</li><li>ArrayList &amp; LinkedList、</li><li>HashMap &amp; LinkedHashMap &amp; TreeMap &amp; CouncurrentHashMap</li><li>HashSet &amp; LinkedHashSet &amp; TreeSet</li></ul><h2 id="Java-并发编程"><a href="#Java-并发编程" class="headerlink" title="Java 并发编程"></a>Java 并发编程</h2><h3 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h3><ul><li>什么是并发、什么是并行</li><li>并发与并行的区别</li></ul><h3 id="什么是线程，与进程的区别"><a href="#什么是线程，与进程的区别" class="headerlink" title="什么是线程，与进程的区别"></a>什么是线程，与进程的区别</h3><ul><li>线程的实现</li><li>线程的状态、优先级</li><li>线程调度</li><li>创建线程的多种方式</li><li>守护线程</li><li>线程与进程的区别</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li>自己设计线程池</li><li>submit() 和 execute()</li><li>线程池原理</li><li>为什么不允许使用 Executors 创建线程池</li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li>死锁</li><li>死锁如何排查</li><li>线程安全和内存模型的关系</li></ul><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><ul><li>CAS</li><li>乐观锁与悲观锁</li><li>数据库相关锁机制</li><li>分布式锁</li><li>偏向锁</li><li>轻量级锁</li><li>重量级锁</li><li>monitor</li><li>锁优化</li><li>锁消除</li><li>锁粗化</li><li>自旋锁</li><li>可重入锁</li><li>阻塞锁</li><li>死锁</li></ul><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><ul><li>什么是死锁</li><li>死锁如何解决</li></ul><h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><ul><li>synchronized 是如何实现的？</li><li>synchronized 和 lock 之间关系</li><li>不使用 synchronized 如何实现一个线程安全的单例</li><li>synchronized 和原子性、可见性和有序性之间的关系</li></ul><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><ul><li>happens-before</li><li>内存屏障</li><li>编译器指令重排和 CPU 指令重</li><li>volatile 的实现原理</li><li>volatile 和原子性</li><li>可见性和有序性之间的关系</li><li>有了 symchronized 为什么还需要 volatile</li></ul><h3 id="sleep-和-wait"><a href="#sleep-和-wait" class="headerlink" title="sleep 和 wait"></a>sleep 和 wait</h3><h3 id="wait-和-notify"><a href="#wait-和-notify" class="headerlink" title="wait 和 notify"></a>wait 和 notify</h3><h3 id="notify-和-notifyAll"><a href="#notify-和-notifyAll" class="headerlink" title="notify 和 notifyAll"></a>notify 和 notifyAll</h3><h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><h3 id="写一个死锁的程序"><a href="#写一个死锁的程序" class="headerlink" title="写一个死锁的程序"></a>写一个死锁的程序</h3><h3 id="写代码来解决生产者消费者问题"><a href="#写代码来解决生产者消费者问题" class="headerlink" title="写代码来解决生产者消费者问题"></a>写代码来解决生产者消费者问题</h3><h3 id="并方包"><a href="#并方包" class="headerlink" title="并方包"></a>并方包</h3><ul><li>Thread</li><li>Runnable</li><li>Callable</li><li>ReentrantLock</li><li>ReentrantReadWriteLock</li><li>Atomic*</li><li>Semaphore</li><li>CountDownLatch</li><li>ConcurrentHashMap</li><li>Executors</li></ul><h1 id="底层篇"><a href="#底层篇" class="headerlink" title="底层篇"></a>底层篇</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="JVM-内存结构"><a href="#JVM-内存结构" class="headerlink" title="JVM 内存结构"></a>JVM 内存结构</h3><ul><li>class 文件格式</li><li>运行时数据区：堆、栈、方法区、直接内存、运行时常量池、</li><li>堆和栈区别</li><li>Java中的对象一定在堆上分配吗？</li></ul><h3 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h3><ul><li>计算机内存模型</li><li>缓存一致性</li><li>MESI 协议</li><li>可见性、原子性、顺序性</li><li>happens-before、</li><li>内存屏障</li><li>synchronized、volatile、final</li><li>锁</li></ul><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><ul><li>GC 算法：标记清除、引用计数、复制、标记压缩、分代回收、增量式回收</li><li>GC 参数、对象存活的判定、垃圾收集器（CMS、G1、ZGC、Epsilon）</li></ul><h3 id="JVM-参数及调优"><a href="#JVM-参数及调优" class="headerlink" title="JVM 参数及调优"></a>JVM 参数及调优</h3><p>-Xmx、-Xmn、-Xms、Xss、-XX:SurvivorRatio、<br>-XX:PermSize、-XX:MaxPermSize、-XX:MaxTenuringThreshold</p><h3 id="Java-对象模型"><a href="#Java-对象模型" class="headerlink" title="Java 对象模型"></a>Java 对象模型</h3><ul><li>oop-klass</li><li>对象头</li></ul><h3 id="HotSpot"><a href="#HotSpot" class="headerlink" title="HotSpot"></a>HotSpot</h3><ul><li>即时编译器</li><li>编译优化</li></ul><h3 id="虚拟机性能监控与故障处理工具"><a href="#虚拟机性能监控与故障处理工具" class="headerlink" title="虚拟机性能监控与故障处理工具"></a>虚拟机性能监控与故障处理工具</h3><p>jps, jstack, jmap, jstat, jconsole, jinfo, jhat, javap, btrace, TProfiler<br>Arthas</p><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><ul><li>classLoader</li><li>类加载过程</li><li>双亲委派（破坏双亲委派）</li><li>模块化（jboss modules、osgi、jigsaw）</li></ul><h2 id="编译与反编译"><a href="#编译与反编译" class="headerlink" title="编译与反编译"></a>编译与反编译</h2><ul><li>什么是编译（前端编译、后端编译）</li><li>什么是反编译</li><li>JIT、JIT 优化（逃逸分析、栈上分配、标量替换、锁优化）</li><li>编译工具：javac</li><li>反编译工具：javap 、jad 、CRF</li></ul><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="Java-底层知识"><a href="#Java-底层知识" class="headerlink" title="Java 底层知识"></a>Java 底层知识</h2><h3 id="字节码、class-文件格式"><a href="#字节码、class-文件格式" class="headerlink" title="字节码、class 文件格式"></a>字节码、class 文件格式</h3><h3 id="CPU-缓存，L1，L2，L3-和伪共享"><a href="#CPU-缓存，L1，L2，L3-和伪共享" class="headerlink" title="CPU 缓存，L1，L2，L3 和伪共享"></a>CPU 缓存，L1，L2，L3 和伪共享</h3><h3 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h3><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p>用位运算实现加、减、乘、除、取余</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式的六大原则：</p><ul><li>开闭原则（Open Close Principle）</li><li>里氏代换原则（Liskov Substitution Principle）</li><li>依赖倒转原则（Dependence Inversion Principle）</li><li>接口隔离原则（Interface Segregation Principle）</li><li>迪米特法则（最少知道原则）（Demeter Principle）</li><li>合成复用原则（Composite Reuse Principle）</li></ul><h3 id="了解-23-种设计模式"><a href="#了解-23-种设计模式" class="headerlink" title="了解 23 种设计模式"></a>了解 23 种设计模式</h3><ul><li>创建型模式：单例模式、抽象工厂模式、建造者模式、工厂模式、原型模式。</li><li>结构型模式：适配器模式、桥接模式、装饰模式、组合模式、外观模式、享元模式、代理模式。</li><li>行为型模式：模版方法模式、命令模式、迭代器模式、观察者模式、中介者模式、备忘录模式、解释器模式（Interpreter 模式）、状态模式、策略模式、职责链模式(责任链模式)、访问者模式。</li></ul><h3 id="会使用常用设计模式"><a href="#会使用常用设计模式" class="headerlink" title="会使用常用设计模式"></a>会使用常用设计模式</h3><ul><li>单例的七种写法：懒汉——线程不安全、懒汉——线程安全、饿汉、饿汉——变种、静态内部类、枚举、双重校验锁</li><li>工厂模式、适配器模式、策略模式、模板方法模式、观察者模式、外观模式、代理模式等必会</li></ul><h3 id="不用-synchronized-和-lock，实现线程安全的单例模式"><a href="#不用-synchronized-和-lock，实现线程安全的单例模式" class="headerlink" title="不用 synchronized 和 lock，实现线程安全的单例模式"></a>不用 synchronized 和 lock，实现线程安全的单例模式</h3><h3 id="实现-AOP"><a href="#实现-AOP" class="headerlink" title="实现 AOP"></a>实现 AOP</h3><h3 id="实现-IOC"><a href="#实现-IOC" class="headerlink" title="实现 IOC"></a>实现 IOC</h3><h3 id="nio-和-reactor-设计模式"><a href="#nio-和-reactor-设计模式" class="headerlink" title="nio 和 reactor 设计模式"></a>nio 和 reactor 设计模式</h3><h2 id="网络编程知识"><a href="#网络编程知识" class="headerlink" title="网络编程知识"></a>网络编程知识</h2><h3 id="tcp、udp、http、https-等常用协议"><a href="#tcp、udp、http、https-等常用协议" class="headerlink" title="tcp、udp、http、https 等常用协议"></a>tcp、udp、http、https 等常用协议</h3><ul><li>三次握手与四次关闭</li><li>流量控制和拥塞控制</li><li>OSI 七层模型</li><li>tcp 粘包与拆包</li></ul><h3 id="http-1-0-http-1-1-http-2-之前的区别"><a href="#http-1-0-http-1-1-http-2-之前的区别" class="headerlink" title="http/1.0 http/1.1 http/2 之前的区别"></a>http/1.0 http/1.1 http/2 之前的区别</h3><ul><li>http 中 get 和 post 区别</li><li>常见的 web 请求返回的状态码</li><li>404、302、301、500分别代表什么</li></ul><h3 id="http-3"><a href="#http-3" class="headerlink" title="http/3"></a>http/3</h3><h3 id="Java-RMI，Socket，HttpClient"><a href="#Java-RMI，Socket，HttpClient" class="headerlink" title="Java RMI，Socket，HttpClient"></a>Java RMI，Socket，HttpClient</h3><h3 id="cookie-与-session"><a href="#cookie-与-session" class="headerlink" title="cookie 与 session"></a>cookie 与 session</h3><p>cookie 被禁用，如何实现 session</p><h3 id="用-Java-写一个简单的静态文件的-HTTP-服务器"><a href="#用-Java-写一个简单的静态文件的-HTTP-服务器" class="headerlink" title="用 Java 写一个简单的静态文件的 HTTP 服务器"></a>用 Java 写一个简单的静态文件的 HTTP 服务器</h3><h3 id="了解-nginx-和-apache-服务器的特性并搭建一个对应的服务器"><a href="#了解-nginx-和-apache-服务器的特性并搭建一个对应的服务器" class="headerlink" title="了解 nginx 和 apache 服务器的特性并搭建一个对应的服务器"></a>了解 nginx 和 apache 服务器的特性并搭建一个对应的服务器</h3><h3 id="用-Java-实现-FTP、SMTP-协议"><a href="#用-Java-实现-FTP、SMTP-协议" class="headerlink" title="用 Java 实现 FTP、SMTP 协议"></a>用 Java 实现 FTP、SMTP 协议</h3><h3 id="进程间通讯的方式"><a href="#进程间通讯的方式" class="headerlink" title="进程间通讯的方式"></a>进程间通讯的方式</h3><h3 id="什么是-CDN？如果实现？"><a href="#什么是-CDN？如果实现？" class="headerlink" title="什么是 CDN？如果实现？"></a>什么是 CDN？如果实现？</h3><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><ul><li>什么是 DNS</li><li>记录类型: A 记录、CNAME 记录、AAAA 记录等</li><li>域名解析、根域名服务器</li><li>DNS 污染、DNS 劫持、公共 DNS：114 DNS、Google DNS、OpenDNS</li></ul><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><ul><li>正向代理</li><li>反向代理</li><li>反向代理服务器</li></ul><h2 id="框架知识"><a href="#框架知识" class="headerlink" title="框架知识"></a>框架知识</h2><h3 id="Servlet"><a href="#Servlet" class="headerlink" title="Servlet"></a>Servlet</h3><ul><li>生命周期</li><li>线程安全问题</li><li>filter 和 listener</li><li>web.xml 中常用配置及作用</li></ul><h3 id="Hibernate"><a href="#Hibernate" class="headerlink" title="Hibernate"></a>Hibernate</h3><ul><li>什么是 OR Mapping</li><li>Hibernate 的懒加载</li><li>Hibernate 的缓存机制</li><li>Hibernate / Ibatis / MyBatis 之间的区别</li></ul><h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><ul><li>Bean 的初始化</li><li>AOP 原理</li><li>实现 Spring 的IOC</li><li>Spring 四种依赖注入方式</li></ul><h3 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h3><ul><li>什么是 MVC</li><li>Spring mvc 与 Struts mvc 的区别</li></ul><h3 id="Spring-Boot"><a href="#Spring-Boot" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><ul><li>Spring Boot 2.0</li><li>起步依赖</li><li>自动配置</li><li>Spring Boot 的 starter 原理，自己实现一个 starter</li></ul><h3 id="Spring-Security"><a href="#Spring-Security" class="headerlink" title="Spring Security"></a>Spring Security</h3><h3 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><ul><li>服务发现与注册：Eureka、Zookeeper、Consul</li><li>负载均衡：Feign、Spring Cloud Loadbalance</li><li>服务配置：Spring Cloud Config</li><li>服务限流与熔断：Hystrix</li><li>服务链路追踪：Dapper</li><li>服务网关、安全、消息</li></ul><h2 id="应用服务器知识"><a href="#应用服务器知识" class="headerlink" title="应用服务器知识"></a>应用服务器知识</h2><h3 id="JBoss"><a href="#JBoss" class="headerlink" title="JBoss"></a>JBoss</h3><h3 id="tomcat"><a href="#tomcat" class="headerlink" title="tomcat"></a>tomcat</h3><h3 id="jetty"><a href="#jetty" class="headerlink" title="jetty"></a>jetty</h3><h3 id="Weblogic"><a href="#Weblogic" class="headerlink" title="Weblogic"></a>Weblogic</h3><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="git-amp-svn"><a href="#git-amp-svn" class="headerlink" title="git &amp; svn"></a>git &amp; svn</h3><h3 id="maven-amp-gradle"><a href="#maven-amp-gradle" class="headerlink" title="maven &amp; gradle"></a>maven &amp; gradle</h3><h3 id="Intellij-IDEA"><a href="#Intellij-IDEA" class="headerlink" title="Intellij IDEA"></a>Intellij IDEA</h3><p>常用插件：Maven Helper 、FindBugs-IDEA、阿里巴巴代码规约检测、GsonFormat<br>Lombok plugin、.ignore、Mybatis plugin</p><h1 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h1><h2 id="新技术"><a href="#新技术" class="headerlink" title="新技术"></a>新技术</h2><h3 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a>Java 8</h3><ul><li>lambda 表达式</li><li>Stream API</li><li>时间 API</li></ul><h3 id="Java-9"><a href="#Java-9" class="headerlink" title="Java 9"></a>Java 9</h3><p>Jigsaw、Jshell、Reactive Streams</p><h3 id="Java-10"><a href="#Java-10" class="headerlink" title="Java 10"></a>Java 10</h3><ul><li>局部变量类型推断</li><li>G1 的并行 Full GC</li><li>ThreadLocal 握手机制</li></ul><h3 id="Java-11"><a href="#Java-11" class="headerlink" title="Java 11"></a>Java 11</h3><p>ZGC、Epsilon、增强 var</p><h3 id="Spring-5"><a href="#Spring-5" class="headerlink" title="Spring 5"></a>Spring 5</h3><p>响应式编程</p><h3 id="Spring-Boot-2-0"><a href="#Spring-Boot-2-0" class="headerlink" title="Spring Boot 2.0"></a>Spring Boot 2.0</h3><h3 id="HTTP-2"><a href="#HTTP-2" class="headerlink" title="HTTP/2"></a>HTTP/2</h3><h3 id="HTTP-3"><a href="#HTTP-3" class="headerlink" title="HTTP/3"></a>HTTP/3</h3><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><ul><li>使用单例</li><li>使用 Future 模式</li><li>使用线程池</li><li>选择就绪</li><li>减少上下文切换</li><li>减少锁粒度</li><li>数据压缩</li><li>结果缓存</li></ul><h2 id="线上问题分析"><a href="#线上问题分析" class="headerlink" title="线上问题分析"></a>线上问题分析</h2><h3 id="dump-获取"><a href="#dump-获取" class="headerlink" title="dump 获取"></a>dump 获取</h3><ul><li>线程 Dump</li><li>内存 Dump</li><li>gc 情况</li></ul><h3 id="dump-分析"><a href="#dump-分析" class="headerlink" title="dump 分析"></a>dump 分析</h3><p>分析死锁、分析内存泄露</p><h3 id="dump-分析及获取工具"><a href="#dump-分析及获取工具" class="headerlink" title="dump 分析及获取工具"></a>dump 分析及获取工具</h3><p>jstack、jstat、jmap、jhat、Arthas</p><h3 id="自己编写各种-outofmemory，stackoverflow-程序"><a href="#自己编写各种-outofmemory，stackoverflow-程序" class="headerlink" title="自己编写各种 outofmemory，stackoverflow 程序"></a>自己编写各种 outofmemory，stackoverflow 程序</h3><ul><li>HeapOutOfMemory</li><li>Young OutOfMemory</li><li>MethodArea OutOfMemory</li><li>ConstantPool OutOfMemory</li><li>DirectMemory OutOfMemory</li><li>Stack OutOfMemory Stack OverFlow</li></ul><h3 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h3><ul><li>jvm 相关</li><li>class/classloader 相关</li><li>monitor/watch/trace 相关</li><li>options</li><li>管道</li><li>后台异步任务<br>文档：<a href="https://alibaba.github.io/arthas/advanced-use.html" target="_blank" rel="noopener">https://alibaba.github.io/arthas/advanced-use.html</a></li></ul><h3 id="常见问题解决思路"><a href="#常见问题解决思路" class="headerlink" title="常见问题解决思路"></a>常见问题解决思路</h3><ul><li>内存溢出</li><li>线程死锁</li><li>类加载冲突</li></ul><h3 id="使用工具尝试解决以下问题，并写下总结"><a href="#使用工具尝试解决以下问题，并写下总结" class="headerlink" title="使用工具尝试解决以下问题，并写下总结"></a>使用工具尝试解决以下问题，并写下总结</h3><ul><li>当一个 Java 程序响应很慢时如何查找问题</li><li>当一个 Java 程序频繁 FullGC 时如何解决问题</li><li>如何查看垃圾回收日志</li><li>当一个 Java 应用发生 OutOfMemory 时该如何解决</li><li>如何判断是否出现死锁</li><li>如何判断是否存在内存泄露</li><li>使用 Arthas 快速排查 Spring Boot 应用404/401问题</li><li>使用 Arthas 排查线上应用日志打满问题</li><li>利用 Arthas 排查 Spring Boot 应用 NoSuchMethodError</li></ul><h2 id="编译原理知识"><a href="#编译原理知识" class="headerlink" title="编译原理知识"></a>编译原理知识</h2><h3 id="编译与反编译-1"><a href="#编译与反编译-1" class="headerlink" title="编译与反编译"></a>编译与反编译</h3><h3 id="Java-代码的编译与反编译"><a href="#Java-代码的编译与反编译" class="headerlink" title="Java 代码的编译与反编译"></a>Java 代码的编译与反编译</h3><h3 id="Java-的反编译工具"><a href="#Java-的反编译工具" class="headerlink" title="Java 的反编译工具"></a>Java 的反编译工具</h3><p>javap 、jad 、CRF</p><h3 id="即时编译器"><a href="#即时编译器" class="headerlink" title="即时编译器"></a>即时编译器</h3><h3 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h3><ul><li>词法分析，语法分析（LL 算法，递归下降算法，LR 算法）</li><li>语义分析，运行时环境，中间代码，代码生成，代码优化</li></ul><h2 id="操作系统知识"><a href="#操作系统知识" class="headerlink" title="操作系统知识"></a>操作系统知识</h2><h3 id="Linux-的常用命令"><a href="#Linux-的常用命令" class="headerlink" title="Linux 的常用命令"></a>Linux 的常用命令</h3><h3 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h3><h3 id="进程同步"><a href="#进程同步" class="headerlink" title="进程同步"></a>进程同步</h3><p>生产者消费者问题、哲学家就餐问题、读者写者问题</p><h3 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h3><h3 id="分段和分页"><a href="#分段和分页" class="headerlink" title="分段和分页"></a>分段和分页</h3><h3 id="虚拟内存与主存"><a href="#虚拟内存与主存" class="headerlink" title="虚拟内存与主存"></a>虚拟内存与主存</h3><h3 id="虚拟内存管理"><a href="#虚拟内存管理" class="headerlink" title="虚拟内存管理"></a>虚拟内存管理</h3><h3 id="换页算法"><a href="#换页算法" class="headerlink" title="换页算法"></a>换页算法</h3><h2 id="数据库知识"><a href="#数据库知识" class="headerlink" title="数据库知识"></a>数据库知识</h2><h3 id="MySQL-执行引擎"><a href="#MySQL-执行引擎" class="headerlink" title="MySQL 执行引擎"></a>MySQL 执行引擎</h3><h3 id="MySQL-执行计划"><a href="#MySQL-执行计划" class="headerlink" title="MySQL 执行计划"></a>MySQL 执行计划</h3><p>如何查看执行计划，如何根据执行计划进行 SQL 优化</p><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>Hash 索引</li><li>B 树索引（B+树、和B树、R树）</li><li>普通索引</li><li>唯一索引</li><li>覆盖索引</li><li>最左前缀原则</li><li>索引下推</li></ul><h3 id="SQL-优化"><a href="#SQL-优化" class="headerlink" title="SQL 优化"></a>SQL 优化</h3><h3 id="数据库事务和隔离级别"><a href="#数据库事务和隔离级别" class="headerlink" title="数据库事务和隔离级别"></a>数据库事务和隔离级别</h3><p>事务的隔离级别、事务能不能实现锁的功能</p><h3 id="数据库锁"><a href="#数据库锁" class="headerlink" title="数据库锁"></a>数据库锁</h3><p>行锁、表锁、使用数据库锁实现乐观锁、</p><h3 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h3><p>内连接，左连接，右连接</p><h3 id="数据库主备搭建"><a href="#数据库主备搭建" class="headerlink" title="数据库主备搭建"></a>数据库主备搭建</h3><h3 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h3><h3 id="redolog"><a href="#redolog" class="headerlink" title="redolog"></a>redolog</h3><h3 id="内存数据库"><a href="#内存数据库" class="headerlink" title="内存数据库"></a>内存数据库</h3><p>h2</p><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><h3 id="常用的-NoSql-数据库"><a href="#常用的-NoSql-数据库" class="headerlink" title="常用的 NoSql 数据库"></a>常用的 NoSql 数据库</h3><p>redis、memcached</p><h3 id="分别使用数据库锁、NoSql-实现分布式锁"><a href="#分别使用数据库锁、NoSql-实现分布式锁" class="headerlink" title="分别使用数据库锁、NoSql 实现分布式锁"></a>分别使用数据库锁、NoSql 实现分布式锁</h3><h3 id="性能调优"><a href="#性能调优" class="headerlink" title="性能调优"></a>性能调优</h3><h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><h2 id="数据结构与算法知识"><a href="#数据结构与算法知识" class="headerlink" title="数据结构与算法知识"></a>数据结构与算法知识</h2><h3 id="简单的数据结构"><a href="#简单的数据结构" class="headerlink" title="简单的数据结构"></a>简单的数据结构</h3><ul><li>栈、队列、链表、数组、哈希表、</li><li>栈和队列的相同和不同之处</li><li>栈通常采用的两种存储结构</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>二叉树、字典树、平衡树、排序树、<br>B 树、B+ 树、R 树、多路树、红黑树</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>大根堆、小根堆</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p>有向图、无向图、拓扑</p><h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><ul><li>稳定的排序：冒泡排序、插入排序、鸡尾酒排序、桶排序、计数排序、归并排序、原地归并排序、二叉排序树排序、鸽巢排序、基数排序、侏儒排序、图书馆排序、块排序</li><li>不稳定的排序：选择排序、希尔排序、Clover 排序算法、梳排序、堆排序、平滑排序、快速排序、内省排序、耐心排序</li><li>各种排序算法和时间复杂度</li></ul><h3 id="两个栈实现队列，和两个队列实现栈"><a href="#两个栈实现队列，和两个队列实现栈" class="headerlink" title="两个栈实现队列，和两个队列实现栈"></a>两个栈实现队列，和两个队列实现栈</h3><h3 id="深度优先和广度优先搜索"><a href="#深度优先和广度优先搜索" class="headerlink" title="深度优先和广度优先搜索"></a>深度优先和广度优先搜索</h3><h3 id="全排列、贪心算法、KMP-算法、hash-算法"><a href="#全排列、贪心算法、KMP-算法、hash-算法" class="headerlink" title="全排列、贪心算法、KMP 算法、hash 算法"></a>全排列、贪心算法、KMP 算法、hash 算法</h3><h3 id="海量数据处理"><a href="#海量数据处理" class="headerlink" title="海量数据处理"></a>海量数据处理</h3><p>分治，hash 映射，堆排序，双层桶划分，Bloom Filter，bitmap，数据库索引，mapreduce 等。</p><h2 id="大数据知识"><a href="#大数据知识" class="headerlink" title="大数据知识"></a>大数据知识</h2><h3 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h3><p>基本概念、常见用法</p><h3 id="Solr，Lucene，ElasticSearch"><a href="#Solr，Lucene，ElasticSearch" class="headerlink" title="Solr，Lucene，ElasticSearch"></a>Solr，Lucene，ElasticSearch</h3><p>在 linux 上部署 solr，solrcloud，新增、删除、查询索引</p><h3 id="Storm，流式计算，了解-Spark，S4"><a href="#Storm，流式计算，了解-Spark，S4" class="headerlink" title="Storm，流式计算，了解 Spark，S4"></a>Storm，流式计算，了解 Spark，S4</h3><p>在 linux 上部署 storm，用 zookeeper 做协调，运行 storm hello world，local 和 remote 模式运行调试 storm topology。</p><h3 id="Hadoop，离线计算"><a href="#Hadoop，离线计算" class="headerlink" title="Hadoop，离线计算"></a>Hadoop，离线计算</h3><p>HDFS、MapReduce</p><h3 id="分布式日志收集-flume，kafka，logstash"><a href="#分布式日志收集-flume，kafka，logstash" class="headerlink" title="分布式日志收集 flume，kafka，logstash"></a>分布式日志收集 flume，kafka，logstash</h3><h3 id="数据挖掘，mahout"><a href="#数据挖掘，mahout" class="headerlink" title="数据挖掘，mahout"></a>数据挖掘，mahout</h3><h2 id="网络安全知识"><a href="#网络安全知识" class="headerlink" title="网络安全知识"></a>网络安全知识</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS 的防御</p><h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><h3 id="注入攻击"><a href="#注入攻击" class="headerlink" title="注入攻击"></a>注入攻击</h3><p>SQL 注入、XML 注入、CRLF 注入</p><h3 id="文件上传漏洞"><a href="#文件上传漏洞" class="headerlink" title="文件上传漏洞"></a>文件上传漏洞</h3><h3 id="加密与解密"><a href="#加密与解密" class="headerlink" title="加密与解密"></a>加密与解密</h3><p>对称加密、非对称加密、哈希算法、加盐哈希算法<br>MD5，SHA1、DES、AES、RSA、DSA<br>彩虹表</p><h3 id="DDOS攻击"><a href="#DDOS攻击" class="headerlink" title="DDOS攻击"></a>DDOS攻击</h3><p>DOS 攻击、DDOS 攻击<br>memcached 为什么可以导致 DDos 攻击、什么是反射型 DDoS<br>如何通过 Hash 碰撞进行 DOS 攻击</p><h3 id="SSL、TLS，HTTPS"><a href="#SSL、TLS，HTTPS" class="headerlink" title="SSL、TLS，HTTPS"></a>SSL、TLS，HTTPS</h3><h3 id="用-openssl-签一个证书部署到-apache-或-nginx"><a href="#用-openssl-签一个证书部署到-apache-或-nginx" class="headerlink" title="用 openssl 签一个证书部署到 apache 或 nginx"></a>用 openssl 签一个证书部署到 apache 或 nginx</h3><h1 id="架构篇"><a href="#架构篇" class="headerlink" title="架构篇"></a>架构篇</h1><h2 id="分布式"><a href="#分布式" class="headerlink" title="分布式"></a>分布式</h2><p>数据一致性、服务治理、服务降级</p><h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>2PC、3PC、CAP、BASE、 可靠消息最终一致性、最大努力通知、TCC</p><h3 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h3><p>服务注册、服务发现，服务治理<br><a href="http://dubbo.apache.org/zh-cn/" target="_blank" rel="noopener">http://dubbo.apache.org/zh-cn/</a></p><h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3><p>怎样打造一个分布式数据库、什么时候需要分布式数据库、<br>mycat、otter、HBase</p><h3 id="分布式文件系统"><a href="#分布式文件系统" class="headerlink" title="分布式文件系统"></a>分布式文件系统</h3><p>mfs、fastdfs</p><h3 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h3><p>缓存一致性、缓存命中率、缓存冗余</p><h3 id="限流降级"><a href="#限流降级" class="headerlink" title="限流降级"></a>限流降级</h3><p>Hystrix、Sentinal</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><p>共识算法、Raft 协议、Paxos 算法与 Raft 算法、<br>拜占庭问题与算法、2PC、3PC</p><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><p>SOA、康威定律</p><h3 id="ServiceMesh"><a href="#ServiceMesh" class="headerlink" title="ServiceMesh"></a>ServiceMesh</h3><p>sidecar</p><h3 id="Docker-amp-Kubernets"><a href="#Docker-amp-Kubernets" class="headerlink" title="Docker &amp; Kubernets"></a>Docker &amp; Kubernets</h3><h3 id="Spring-Boot-1"><a href="#Spring-Boot-1" class="headerlink" title="Spring Boot"></a>Spring Boot</h3><h3 id="Spring-Cloud-1"><a href="#Spring-Cloud-1" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h3><h2 id="高并发"><a href="#高并发" class="headerlink" title="高并发"></a>高并发</h2><h3 id="分库分表-1"><a href="#分库分表-1" class="headerlink" title="分库分表"></a>分库分表</h3><h3 id="CDN-技术"><a href="#CDN-技术" class="headerlink" title="CDN 技术"></a>CDN 技术</h3><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>ActiveMQ</p><h2 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h2><h3 id="监控什么"><a href="#监控什么" class="headerlink" title="监控什么"></a>监控什么</h3><p>CPU、内存、磁盘 I/O、网络 I/O 等</p><h3 id="监控手段"><a href="#监控手段" class="headerlink" title="监控手段"></a>监控手段</h3><p>进程监控、语义监控、机器资源监控、数据波动</p><h3 id="监控数据采集"><a href="#监控数据采集" class="headerlink" title="监控数据采集"></a>监控数据采集</h3><p>日志、埋点</p><h3 id="Dapper"><a href="#Dapper" class="headerlink" title="Dapper"></a>Dapper</h3><h2 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h2><p>tomcat 负载均衡、Nginx 负载均衡<br>四层负载均衡、七层负载均衡</p><h2 id="DNS-1"><a href="#DNS-1" class="headerlink" title="DNS"></a>DNS</h2><p>DNS 原理、DNS 的设计</p><h2 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h2><p>数据一致性</p><h1 id="扩展篇"><a href="#扩展篇" class="headerlink" title="扩展篇"></a>扩展篇</h1><h2 id="云计算"><a href="#云计算" class="headerlink" title="云计算"></a>云计算</h2><p>IaaS、SaaS、PaaS、虚拟化技术、openstack、Serverlsess</p><h2 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h2><p>Solr、Lucene、Nutch、Elasticsearch</p><h2 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h2><p>Shiro</p><h2 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h2><p>哈希算法、Merkle 树、公钥密码算法、共识算法、<br>Raft 协议、Paxos 算法与 Raft 算法、拜占庭问题与算法、消息认证码与数字签名</p><h3 id="比特币"><a href="#比特币" class="headerlink" title="比特币"></a>比特币</h3><p>挖矿、共识机制、闪电网络、侧链、热点问题、分叉</p><h3 id="以太坊"><a href="#以太坊" class="headerlink" title="以太坊"></a>以太坊</h3><h3 id="超级账本"><a href="#超级账本" class="headerlink" title="超级账本"></a>超级账本</h3><h2 id="人工智能"><a href="#人工智能" class="headerlink" title="人工智能"></a>人工智能</h2><p>数学基础、机器学习、人工神经网络、深度学习、应用场景。</p><h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><p>TensorFlow、DeepLearning4J</p><h2 id="loT"><a href="#loT" class="headerlink" title="loT"></a>loT</h2><h2 id="量子计算"><a href="#量子计算" class="headerlink" title="量子计算"></a>量子计算</h2><h2 id="AR-amp-VR"><a href="#AR-amp-VR" class="headerlink" title="AR &amp; VR"></a>AR &amp; VR</h2><h2 id="其他语言"><a href="#其他语言" class="headerlink" title="其他语言"></a>其他语言</h2><p>Groovy、Python、Go、NodeJs、Swift、Rust</p><h1 id="推荐书籍"><a href="#推荐书籍" class="headerlink" title="推荐书籍"></a>推荐书籍</h1><p>《深入理解 Java 虚拟机》<br>《Effective Java》<br>《深入分析 Java Web 技术内幕》<br>《大型网站技术架构》<br>《代码整洁之道》<br>《架构整洁之道》<br>《Head First 设计模式》<br>《maven 实战》<br>《区块链原理、设计与应用》<br>《Java 并发编程实战》<br>《鸟哥的 Linux 私房菜》<br>《从Paxos 到 Zookeeper》<br>《架构即未来》</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;借鉴前辈的java学习之路。&lt;br&gt;不积跬步无以至千里，不积小流无以成江海。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想-复用类</title>
    <link href="http://yoursite.com/2018/12/24/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%A4%8D%E7%94%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2018/12/24/java编程思想-复用类/</id>
    <published>2018-12-24T05:09:50.000Z</published>
    <updated>2019-03-01T02:16:40.880Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想-初始化与清理and访问权限控制</title>
    <link href="http://yoursite.com/2018/12/17/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86and%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6/"/>
    <id>http://yoursite.com/2018/12/17/java编程思想-初始化与清理and访问权限控制/</id>
    <published>2018-12-17T08:26:52.000Z</published>
    <updated>2019-03-01T04:08:42.015Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p>这部分内容包括java的初始化、垃圾清理以及访问权限控制。其中包括静态成员、非静态成员以及特殊结构的初始化过程；垃圾回收机制与垃圾回收机制无法处理的特殊清理方法；最后是访问权限控制的部分内容。<br><a id="more"></a></p></blockquote><hr><p><img src="/2018/12/17/java编程思想-初始化与清理and访问权限控制/pic1.png" alt="">   </p><h2 id="基本类型的方法重载"><a href="#基本类型的方法重载" class="headerlink" title="基本类型的方法重载"></a>基本类型的方法重载</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">char</span> x)</span></span>&#123; System.out.print(<span class="string">"f1(char)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">byte</span> x)</span></span>&#123; System.out.print(<span class="string">"f1(byte)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">short</span> x)</span></span>&#123; System.out.print(<span class="string">"f1(short)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; System.out.print(<span class="string">"f1(int)"</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">byte</span> x)</span></span>&#123; System.out.print(<span class="string">"f2(byte)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">short</span> x)</span></span>&#123; System.out.print(<span class="string">"f2(short)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; System.out.print(<span class="string">"f2(int)"</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">short</span> x)</span></span>&#123; System.out.print(<span class="string">"f3(short)"</span>);&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; System.out.print(<span class="string">"f3(int)"</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f4</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; System.out.print(<span class="string">"f4(int)"</span>);&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 小类型传入大类型的参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testChar</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> x = <span class="string">'x'</span>;</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);  <span class="comment">// output: f1(char);f2(int);f3(int);f4(int)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testByte</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">byte</span> x = <span class="number">0</span>;</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);  <span class="comment">// output: f1(byte);f2(byte);f3(short);f(int)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testShort</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> x = <span class="number">0</span>;</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);  <span class="comment">// output: f1(short);f2(short);f3(short);f4(int)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">testInt</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">    f1(x);f2(x);f3(x);f4(x);  <span class="comment">// output: f1(int);f2(int);f3(int);f4(int)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 大类型传入小类型的参数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    f4((<span class="keyword">int</span>)x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>涉及基本类型的重载有两种情况<code>byte &gt; short &gt; int &gt; long &gt; float &gt; double</code>：</p><ul><li>实际值的数据类型比方法形参的数据类型要小时，实际数据类型会被提升。<code>char</code>若没有对应类型的形参，直接提升至<code>int</code></li><li>实际值的数据类型比方法形参的数据类型要大时，需要通过类型转换来执行窄化转换，否则编译器会报错</li></ul><h2 id="this关键字的使用"><a href="#this关键字的使用" class="headerlink" title="this关键字的使用"></a>this关键字的使用</h2><h3 id="在方法内部获得对当前对象的引用"><a href="#在方法内部获得对当前对象的引用" class="headerlink" title="在方法内部获得对当前对象的引用"></a>在方法内部获得对当前对象的引用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="function">Leaf <span class="title">increment</span><span class="params">()</span></span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"i = "</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Leaf x = <span class="keyword">new</span> Leaf();</span><br><span class="line">    x.increment().increment().increment().print();  <span class="comment">// output: i = 3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在<code>increment()</code>方法内部通过<code>this</code>关键字返回对当前对象的引用。</p><h3 id="将当前对象传递给其他方法"><a href="#将当前对象传递给其他方法" class="headerlink" title="将当前对象传递给其他方法"></a>将当前对象传递给其他方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">    Apple peeled = apple.getPeeled();</span><br><span class="line">    System.out.println(<span class="string">"JackeyZz"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Peeler</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Apple <span class="title">peel</span><span class="params">(Apple apple)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> apple;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Apple</span></span>&#123;</span><br><span class="line">  <span class="function">Apple <span class="title">getPeeled</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Peeler.peel(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PassingThis</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">new</span> Person.eat(<span class="keyword">new</span> Apple());         <span class="comment">// output: JackeyZz</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Apple</code>类需要调用<code>Peeler.peel()</code>方法，它是一个外部工具方法，将执行由于某种原因而必须放在<code>Apple</code>外部的操作(也许是因为该外部方法要应用到其他不同的类，避免重复代码),为了将其自身传递给外部方法，使用<code>this</code>关键字。</p><h3 id="在构造器中调用构造器"><a href="#在构造器中调用构造器" class="headerlink" title="在构造器中调用构造器"></a>在构造器中调用构造器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flower</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> petalCount = <span class="number">0</span>;</span><br><span class="line">  String s = <span class="string">"JackeyZz"</span>;</span><br><span class="line">  Flower(<span class="keyword">int</span> petals)&#123;</span><br><span class="line">    <span class="keyword">this</span>.petalCount = petals;</span><br><span class="line">  &#125;</span><br><span class="line">  Flower(String s)&#123;</span><br><span class="line">    <span class="keyword">this</span>.s = s;</span><br><span class="line">  &#125;</span><br><span class="line">  Flower(String s, <span class="keyword">int</span> petals)&#123;</span><br><span class="line">    <span class="keyword">this</span>(petals);</span><br><span class="line">    <span class="keyword">this</span>.s = s;</span><br><span class="line">  &#125;</span><br><span class="line">  Flower()&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="string">"JackeyZz"</span>, <span class="number">47</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用构造器的几个特点：</p><ul><li>可用<code>this</code>调用一个构造器，但是不能同时调用两个构造器</li><li>必须将构造器调用置于最起始处，否则编译报错</li><li>除构造器外，编译器禁止在其他任何方法中调用构造器</li></ul><h2 id="构造器初始化"><a href="#构造器初始化" class="headerlink" title="构造器初始化"></a>构造器初始化</h2><h3 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h3><p>在类的内部，变量定义的先后顺序决定了初始化的顺序。即使变量定义散布在方法定义之间，它们仍旧会在任何方法(包括构造器)被调用之前得到初始化。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Window</span></span>&#123;</span><br><span class="line">  Window(<span class="keyword">int</span> marker)&#123;</span><br><span class="line">    System.out.print(<span class="string">"window("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">House</span></span>&#123;</span><br><span class="line">  Window w1 =<span class="keyword">new</span> Window(<span class="number">1</span>);</span><br><span class="line">  House()&#123;</span><br><span class="line">    System.out.print(<span class="string">"house"</span>);</span><br><span class="line">    w3 = <span class="keyword">new</span> Window(<span class="number">33</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Window w2 = <span class="keyword">new</span> Window(<span class="number">2</span>);</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.print(<span class="string">"f()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Window w3 = <span class="keyword">new</span> Window(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">House h = <span class="keyword">new</span> House();</span><br><span class="line">h.f();</span><br><span class="line"><span class="comment">// output: window(1) window(2) window(3) house window(33) f()</span></span><br></pre></td></tr></table></figure></p><h3 id="静态数据的初始化"><a href="#静态数据的初始化" class="headerlink" title="静态数据的初始化"></a>静态数据的初始化</h3><p>无论创建多少个对象，静态数据都只占用一份存储区域。<code>static</code>关键字不能应用于局部变量，只能作用于域。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bowl</span></span>&#123;</span><br><span class="line">  Bowl(<span class="keyword">int</span> marker)&#123;</span><br><span class="line">    print(<span class="string">"Bowl("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</span><br><span class="line">    print(<span class="string">"f1("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Table</span></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> Bowl b1 = <span class="keyword">new</span> Bowl(<span class="number">1</span>);</span><br><span class="line">  Table()&#123;</span><br><span class="line">    print(<span class="string">"table()"</span>);</span><br><span class="line">    b2.f1(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</span><br><span class="line">    print(<span class="string">"f2("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl b2 = <span class="keyword">new</span> Bowl(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cupboard</span></span>&#123;</span><br><span class="line">  Bowl b3 = <span class="keyword">new</span> Bowl(<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">static</span> Bowl b4 = <span class="keyword">new</span> Bowl(<span class="number">4</span>);</span><br><span class="line">  Cupboard()&#123;</span><br><span class="line">    print(<span class="string">"cupboard()"</span>);</span><br><span class="line">    b4.f1(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(<span class="keyword">int</span> marker)</span></span>&#123;</span><br><span class="line">    print(<span class="string">"f3("</span> + marker + <span class="string">")"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Bowl b5 = <span class="keyword">new</span> Bowl(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    print(<span class="string">"test.."</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    print(<span class="string">"test.."</span>);</span><br><span class="line">    <span class="keyword">new</span> Cupboard();</span><br><span class="line">    table.f2(<span class="number">1</span>);</span><br><span class="line">    cupboard.f3(<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> Table table = <span class="keyword">new</span> Table();</span><br><span class="line">  <span class="keyword">static</span> Cupboard cupboard = <span class="keyword">new</span> Cupboard();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* output:</span></span><br><span class="line"><span class="comment">* Bowl(1) Bowl(2) table() f1(1) Bowl(4) Bowl(5) Bowl(3) cupboard() f1(2)</span></span><br><span class="line"><span class="comment">* test.. Bowl(3) cupboard() f1(2) test.. Bowl(3) cupboard() f1(2) f2(1) f(2)</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>上述程序执行过程：<br>要执行<code>main()</code>(静态方法)，必须加载<code>StaticInitialization</code>类，然后其静态域<code>table</code>和<code>cupboard</code>被初始化，这将导致对应的类也被加载，并且由于它们也都包含静态的<code>Bowl</code>对象，因为<code>Bowl</code>随后也被加载。这样，在这个特殊的程序中和所有类在<code>main()</code>开始之前都已被加载。<br>对象的创建过程，假设有个<code>Dog</code>类：</p><ul><li>构造器其实也是静态方法，因此，当首次创建类型为<code>Dog</code>的对象时，或者<code>Dog</code>类的静态方法/静态域首次被访问时，java解释器必须查找类路径，以定位<code>Dog.class</code>文件。</li><li>然后载入<code>Dog.class</code>，有关静态初始化的所有动作都会执行。因此，静态初始化只在<code>Class</code>对象首次加载时进行一次。</li><li>当用<code>new Dog()</code>创建对象时，首先将在堆上为<code>Dog</code>对象分配足够的存储空间</li><li>这块存储空间将会被清零，这就自动地将<code>Dog</code>对象中的所有基本类型设置为初始化，引用设置为null</li><li>执行所有出现于字段定义处的初始化动作</li><li>执行构造器</li></ul><p>静态数据初始化的几个特点：</p><ul><li>静态数据只有在第一次被访问时才会初始化，此后不会再次被初始化</li><li>初始化的顺序是先静态对象(倘若尚未由于对象创建而被初始化)，而后是“非静态”对象</li></ul><h3 id="显示的静态初始化"><a href="#显示的静态初始化" class="headerlink" title="显示的静态初始化"></a>显示的静态初始化</h3><p>Java允许将多个静态初始化动作组织成一个特殊的“静态字句”，也称为“静态块”，即<code>static { }</code>。</p><h3 id="非静态实例初始化"><a href="#非静态实例初始化" class="headerlink" title="非静态实例初始化"></a>非静态实例初始化</h3><p>少了<code>static</code>关键字的代码块，用于支持“匿名内部类”的初始化，即<code>{ }</code>。</p><h2 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h2><ul><li>两个数组<code>a1 = a2</code>，表示a1和a2是相同数组的别名，指向同一个数组，对a2修改，在a1可以看到改变。</li><li><code>Integer[] a = {...}</code>与<code>Integer[] a = new Integer[]{...}</code>，前者只能用于数组被定义之处，后者可以在任何地方使用，包括方法调用内部</li></ul><h2 id="java清理"><a href="#java清理" class="headerlink" title="java清理"></a>java清理</h2><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>GC垃圾收集机制具体可见：<a href="http://jackeyzzhold.xyz/2018/03/20/java-GC/" target="_blank" rel="noopener">博客入口</a></p><h3 id="finalize-方法"><a href="#finalize-方法" class="headerlink" title="finalize()方法"></a>finalize()方法</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ul><li><code>finalize()</code>是<code>Object</code>的<code>protected</code>方法，子类可以覆盖该方法以实现资源清理工作，GC在回收对象之前调用该方法。</li><li><code>finalize()</code>与C++中的析构函数不是对应的。C++中的析构函数调用的时机是确定的（对象离开作用域或delete掉），但Java中的<code>finalize</code>的调用具有不确定性</li><li>不建议用<code>finalize</code>方法完成“非内存资源”的清理工作，但建议用于：① 清理本地对象(通过JNI创建的对象)；② 作为确保某些非内存资源(如Socket、文件等)释放的一个补充：在<code>finalize</code>方法中显式调用其他资源释放方法。</li></ul><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><ul><li>一些与finalize相关的方法，由于一些致命的缺陷，已经被废弃了，如<code>System.runFinalizersOnExit()</code>方法、<code>Runtime.runFinalizersOnExit()</code>方法</li><li><code>System.gc()</code>与<code>System.runFinalization()</code>方法增加了<code>finalize</code>方法执行的机会，但不可盲目依赖它们</li><li>Java语言规范并不保证<code>finalize</code>方法会被及时地执行、而且根本不会保证它们会被执行</li><li><code>finalize</code>方法可能会带来性能问题。因为JVM通常在单独的低优先级线程中完成<code>finalize</code>的执行</li><li>对象再生问题：<code>finalize</code>方法中，可将待回收对象赋值给<code>GC Roots</code>可达的对象引用，从而达到对象再生的目的</li><li><code>finalize</code>方法至多由GC执行一次(用户当然可以手动调用对象的<code>finalize</code>方法，但并不影响GC对<code>finalize</code>的行为)</li></ul><h4 id="执行过程-生命周期"><a href="#执行过程-生命周期" class="headerlink" title="执行过程(生命周期)"></a>执行过程(生命周期)</h4><ol><li>首先，大致描述一下finalize流程：当对象变成(GC Roots)不可达时，GC会判断该对象是否覆盖了finalize方法，若未覆盖，则直接将其回收。否则，若对象未执行过finalize方法，将其放入F-Queue队列，由一低优先级线程执行该队列中对象的finalize方法。执行finalize方法完毕后，GC会再次判断该对象是否可达，若不可达，则进行回收，否则，对象“复活”。</li><li>具体的finalize流程：<br>对象可由两种状态，涉及到两类状态空间，一是终结状态空间 <code>F = {unfinalized, finalizable, finalized}</code>；二是可达状态空间 <code>R = {reachable, finalizer-reachable, unreachable}</code>。各状态含义如下：<ul><li>unfinalized: 新建对象会先进入此状态，GC并未准备执行其finalize方法，因为该对象是可达的</li><li>finalizable: 表示GC可对该对象执行finalize方法，GC已检测到该对象不可达。正如前面所述，GC通过F-Queue队列和一专用线程完成finalize的执行</li><li>finalized: 表示GC已经对该对象执行过finalize方法</li><li>reachable: 表示GC Roots引用可达</li><li>finalizer-reachable(f-reachable)：表示不是reachable，但可通过某个finalizable对象可达</li><li>unreachable：对象不可通过上面两种途径可达</li></ul></li></ol><p>状态变迁图：<br><img src="/2018/12/17/java编程思想-初始化与清理and访问权限控制/pic2.png" alt=""><br>变迁说明：</p><ol><li>新建对象首先处于<code>[reachable, unfinalized]</code>状态(A)</li><li>随着程序的运行，一些引用关系会消失，导致状态变迁，从<code>reachable</code>状态变迁到<code>f-reachable(B, C, D)</code>或<code>unreachable(E, F)</code>状态</li><li>若JVM检测到处于<code>unfinalized</code>状态的对象变成<code>f-reachable</code>或<code>unreachable</code>，JVM会将其标记为<code>finalizable</code>状态(G,H)。若对象原处于<code>[unreachable, unfinalized]</code>状态，则同时将其标记为<code>f-reachable(H)</code>。</li><li>在某个时刻，JVM取出某个<code>finalizable</code>对象，将其标记为<code>finalized</code>并在某个线程中执行其<code>finalize</code>方法。由于是在活动线程中引用了该对象，该对象将变迁到<code>(reachable, finalized)</code>状态(K或J)。该动作将影响某些其他对象从<code>f-reachable</code>状态重新回到<code>reachable</code>状态<code>(L, M, N)</code></li><li>处于<code>finalizable</code>状态的对象不能同时是<code>unreahable</code>的，由第4点可知，将对象<code>finalizable</code>对象标记为<code>finalized</code>时会由某个线程执行该对象的<code>finalize</code>方法，致使其变成<code>reachable</code>。这也是图中只有八个状态点的原因</li><li>程序员手动调用<code>finalize</code>方法并不会影响到上述内部标记的变化，因此JVM只会至多调用<code>finalize</code>一次，即使该对象“复活”也是如此。程序员手动调用多少次不影响JVM的行为</li><li>若JVM检测到<code>finalized</code>状态的对象变成<code>unreachable</code>，回收其内存(I)</li><li>若对象并未覆盖<code>finalize</code>方法，JVM会进行优化，直接回收对象（O）</li><li>注：<code>System.runFinalizersOnExit()</code>等方法可以使对象即使处于<code>reachable</code>状态，JVM仍对其执行<code>finalize</code>方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">*   对象复活</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GC</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 新建对象，因为SAVE_HOOK指向这个对象，对象此时的状态是(reachable,unfinalized)</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> GC();</span><br><span class="line">        <span class="comment">//将SAVE_HOOK设置成null，此时刚才创建的对象就不可达了，因为没有句柄再指向它了，对象此时状态是(unreachable，unfinalized)</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//强制系统执行垃圾回收，系统发现刚才创建的对象处于unreachable状态，并检测到这个对象的类覆盖了finalize方法，因此把这个对象放入F-Queue队列，由低优先级线程执行它的finalize方法，此时对象的状态变成(unreachable, finalizable)或者是(finalizer-reachable,finalizable)</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// sleep，目的是给低优先级线程从F-Queue队列取出对象并执行其finalize方法提供机会。在执行完对象的finalize方法中的super.finalize()时，对象的状态变成(unreachable,finalized)状态，但接下来在finalize方法中又执行了SAVE_HOOK = this;这句话，又有句柄指向这个对象了，对象又可达了。因此对象的状态又变成了(reachable, finalized)状态。</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 这里楼主说对象处于(reachable,finalized)状态应该是合理的。对象的finalized方法被执行了，因此是finalized状态。又因为在finalize方法是执行了SAVE_HOOK=this这句话，本来是unreachable的对象，又变成reachable了。</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123; <span class="comment">//此时对象应该处于(reachable, finalized)状态</span></span><br><span class="line">            <span class="comment">// 这句话会输出，注意对象由unreachable，经过finalize复活了。</span></span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 再一次将SAVE_HOOK放空，此时刚才复活的对象，状态变成(unreachable,finalized)</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// 再一次强制系统回收垃圾，此时系统发现对象不可达，虽然覆盖了finalize方法，但已经执行过了，因此直接回收。</span></span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">// 为系统回收垃圾提供机会</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != SAVE_HOOK) &#123;</span><br><span class="line">            <span class="comment">// 这句话不会输出，因为对象已经彻底消失了。</span></span><br><span class="line">            System.out.println(<span class="string">"Yes , I am still alive"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"No , I am dead"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"execute method finalize()"</span>);</span><br><span class="line">       <span class="comment">// 这句话让对象的状态由unreachable变成reachable，就是对象复活</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java访问权限"><a href="#java访问权限" class="headerlink" title="java访问权限"></a>java访问权限</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这部分内容包括java的初始化、垃圾清理以及访问权限控制。其中包括静态成员、非静态成员以及特殊结构的初始化过程；垃圾回收机制与垃圾回收机制无法处理的特殊清理方法；最后是访问权限控制的部分内容。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想-操作符and控制流程</title>
    <link href="http://yoursite.com/2018/12/14/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E6%93%8D%E4%BD%9C%E7%AC%A6and%E6%8E%A7%E5%88%B6%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/14/java编程思想-操作符and控制流程/</id>
    <published>2018-12-14T05:51:34.000Z</published>
    <updated>2019-03-01T04:08:55.988Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p>这部分内容主要讲的是java操作符的一些特性以及控制流程如<code>for</code>,<code>while</code>等等。<br><a id="more"></a></p></blockquote><hr><p><img src="/2018/12/14/java编程思想-操作符and控制流程/pic1.png" alt="">                                                                    </p><h2 id="java操作符"><a href="#java操作符" class="headerlink" title="java操作符"></a>java操作符</h2><h3 id="对象赋值"><a href="#对象赋值" class="headerlink" title="对象赋值"></a>对象赋值</h3><p>对对象赋值实际是对对象引用进行操作，是将引用从一个地方复制到另一个地方，即假设<code>c=d</code>，那么c和d都指向原本只有d指向的那个对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tank</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br><span class="line">Tank t1 = <span class="keyword">new</span> Tank();</span><br><span class="line">Tank t2 = <span class="keyword">new</span> Tank();</span><br><span class="line">t1.level = <span class="number">9</span>;</span><br><span class="line">t2.level = <span class="number">47</span>;</span><br><span class="line">t1 = t2;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* output:</span></span><br><span class="line"><span class="comment">* t1.level = 47</span></span><br><span class="line"><span class="comment">* t2.level = 47</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">t1.level = <span class="number">27</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* output:</span></span><br><span class="line"><span class="comment">* t1.level = 27</span></span><br><span class="line"><span class="comment">* t2.level = 27</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></p><p>这是由于<code>t1 = t2</code>导致两个引用都指向了同一个对象，而原本<code>t1</code>指向的值为9的对象丢失最终被垃圾回收器自动清理。这个现象通常称作“别名现象”，为避免这种现象，可以<code>t1.level = t2.level</code></p><h3 id="对象的比较"><a href="#对象的比较" class="headerlink" title="对象的比较"></a>对象的比较</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer n1 = <span class="keyword">new</span> Integer(<span class="number">47</span>);</span><br><span class="line">Integer n2 = <span class="keyword">new</span> Integer(<span class="number">47</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* n1 == n2   output : false;</span></span><br><span class="line"><span class="comment">* n1 != n2   output : true;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>虽然两个对象的值一样，但是==与!=比较的是对象的引用，因此得到的结果如上。若要比较对象的实际内容，可用<code>n1.equals(n2)</code>。但是在自己实现的类中使用<code>.equals()</code>还是无法比较对象的实际内容，这是由于<code>.equals()</code>默认行为是比较引用的，除非在自己类中覆盖<code>.equals()</code>方法，而在大多数的Java类库中都实现了<code>.equals()</code>。</p><h3 id="对char、byte、short类型进行移位处理"><a href="#对char、byte、short类型进行移位处理" class="headerlink" title="对char、byte、short类型进行移位处理"></a>对char、byte、short类型进行移位处理</h3><p>对char、byte、short类型进行移位处理之前，需要转成int型，并且得到的结果也是int类型的值。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这部分内容主要讲的是java操作符的一些特性以及控制流程如&lt;code&gt;for&lt;/code&gt;,&lt;code&gt;while&lt;/code&gt;等等。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java编程思想-对象</title>
    <link href="http://yoursite.com/2018/11/02/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3-%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/11/02/java编程思想-对象/</id>
    <published>2018-11-02T05:47:35.000Z</published>
    <updated>2019-03-01T04:55:59.864Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p>这部分内容讲的是java中什么是对象，对象与引用的关系，对象如何创建的，对象如何销毁的，最后涉及到类的一些特性。<br><a id="more"></a></p></blockquote><hr><p><img src="/2018/11/02/java编程思想-对象/Java-对象.png" alt=""></p><h2 id="对象、对象引用、句柄"><a href="#对象、对象引用、句柄" class="headerlink" title="对象、对象引用、句柄"></a>对象、对象引用、句柄</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Light it = <span class="keyword">new</span> Light();</span><br><span class="line">it.on();</span><br></pre></td></tr></table></figure><p>上述例子中，类的名称为<code>Light</code>，调用<code>new</code>方法创建类<code>Light</code>的新对象，然后用对象引用<code>it</code>关联创建的新对象。<code>.on()</code>作为类对象的接口，向对象发出请求执行任务。<br>通常对象需要关联引用才能够传递消息，执行任务；引用可以单独存在。</p><h3 id="对象的定义"><a href="#对象的定义" class="headerlink" title="对象的定义"></a>对象的定义</h3><p>在Java里面，对象有五大基本特性</p><ul><li>万物皆为对象：不仅仅是基本数据变量，可以是任何概念化构件</li><li>程序是对象的集合，通过发送消息来告知彼此所要做的                             </li><li>每个对象都有自己的由其他对象所构成的存储</li><li>每个对象都是某个类的一个实例</li><li>某一特定类型的所有对象都可以接受同样的消息</li></ul><p>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)<br><img src="/2018/11/02/java编程思想-对象/pic1.png" alt=""><br>从上面的这张图里面可以看出，对象在内存中的结构主要包含以下几个部分：</p><ul><li>Mark Word(标记字段)：对象的Mark Word部分占4个字节，其内容是一系列的标记位，比如轻量级锁的标记位，偏向锁标记位等等。</li><li>class Pointer（Class对象指针）：Class对象指针的大小也是4个字节，其指向的位置是对象对应的Class对象（其对应的元数据对象）的内存地址</li><li>对象实际数据：这里面包括了对象的所有成员变量，其大小由各个成员变量的大小决定，比如：byte和boolean是1个字节，short和char是2个字节，int和float是4个字节，long和double是8个字节，reference是4个字节</li><li>对齐：最后一部分是对齐填充的字节，按8个字节填充。</li></ul><p>对象存储布局具体可见：<a href="https://www.cnblogs.com/duanxz/p/4967042.html" target="_blank" rel="noopener">博客入口</a></p><h3 id="对象引用"><a href="#对象引用" class="headerlink" title="对象引用"></a>对象引用</h3><p>java中的引用类型可分为：</p><ul><li>强引用：默认的引用类型，例如<code>StringBuffer buffer = new StringBuffer()</code>，就是<code>buffer</code>变量持有的为<code>StringBuilder</code>的强引用类型。</li><li>软引用：即<code>SoftReference</code>，其指向的对象只有在内存不足的时候进行回收。</li><li>弱引用：即<code>WeakReference</code>,其指向的对象在GC执行时会被回收。</li><li>虚引用：即<code>PhantomReference</code>,与<code>ReferenceQueue</code>结合，用作记录该引用指向的对象已被销毁。</li></ul><p>java虚拟机(JVM)是通过某些数据类型来执行计算的，其数据类型可分为：基本类型、引用类型和null类型。其中引用类型可分为：</p><ul><li>类类型：对类实例的引用</li><li>接口类型：对实现了该接口的某个类实例的引用</li><li>数组类型：对数组对象的引用，在JVM中，数组是个真正的对象</li></ul><p>JVM数据访问方式：</p><ul><li>句柄形式：引用指向句柄，句柄包含对象地址和对象类型</li><li>指针：直接存储对象地址<br>指针比句柄少一步，访问更快；但是值发生改变时，前者引用不用变，后者要改变指针。</li></ul><p>对象的访问定位：<br>建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范里面只规定了是一个指向对象的引用，并没有定义这个引用应该通过什么种方式去定位、访问到堆中的对象的具体位置，对象访问方式也是取决于虚拟机实现而定的。主流的访问方式有使用句柄和直接指针两种。<br>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据的具体各自的地址信息。<br><img src="/2018/11/02/java编程思想-对象/pic2.png" alt=""><br>如果使用直接指针访问的话，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址<br><img src="/2018/11/02/java编程思想-对象/pic3.png" alt=""><br>这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。<br>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问的在Java中非常频繁，因此这类开销积小成多也是一项非常可观的执行成本。从上一部分讲解的对象内存布局可以看出，就虚拟机HotSpot而言，它是使用第二种方式进行对象访问，但在整个软件开发的范围来看，各种语言、框架中使用句柄来访问的情况也十分常见。</p><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><h3 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br></pre></td></tr></table></figure><p>通常用<code>new</code>操作符来创建一个新的对象。</p><p>Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常(例外：克隆、反序列化)仅仅是一个<code>new</code>关键字而已，而在虚拟机中，对象(本文中讨论的对象限于普通Java对象，不包括数组和Class对象等)的创建又是怎样一个过程呢？<br>虚拟机遇到一条<code>new</code>指令时，</p><ul><li>首先jvm要检查类A是否已经被加载到了内存，即类的符号引用是否已经在常量池中，并且检查这个符号引用代表的类是否已被加载、解析和初始化过的。如果还没有，需要先触发类的加载、解析、初始化。然后在堆上创建对象。</li><li><p>为新生对象分配内存。<br>对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务具体便等同于一块确定大小 的内存从Java堆中划分出来，怎么划呢？</p><ul><li>假设Java堆中内存是绝对规整的，所有用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作 为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。</li><li>如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。</li></ul><p>选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此</p><ul><li>在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，</li><li>而使用CMS这种基于Mark-Sweep算法的收集器时（说明一下，CMS收集器可以通过UseCMSCompactAtFullCollection或CMSFullGCsBeforeCompaction来整理内存），就通常采用空闲列表。</li></ul><p>除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。解决这个问题有两个方案，</p><ul><li>一种是对分配内存空间的动作进行同步——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；</li><li>另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。</li></ul></li><li>完成实例数据部分的初始化工作（初始化为0值）<br>内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB的话，这一个工作也可以提前至TLAB分配时进行。这 步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</li><li>完成对象头的填充：如对象自身的运行时数据、类型指针等。</li></ul><p>接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。<br>在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，初始化才正式开始，开始调用<init>方法完成初始复制和构造函数，所有的字段都为零值。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执 行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。<br>下面代码是HotSpot虚拟机bytecodeInterpreter.cpp中的代码片段（这个解释器实现很少机会实际使用，大部分平台上都使用模板 解释器；当代码通过JIT编译器执行时差异就更大了。不过这段代码用于了解HotSpot的运作过程是没有什么问题的）。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 确保常量池中存放的是已解释的类</span></span><br><span class="line">    <span class="keyword">if</span> (!constants-&gt;tag_at(index).is_unresolved_klass()) &#123;</span><br><span class="line">      <span class="comment">// 断言确保是klassOop和instanceKlassOop（这部分下一节介绍）</span></span><br><span class="line">      oop entry = (klassOop) *constants-&gt;obj_at_addr(index);</span><br><span class="line">      assert(entry-&gt;is_klass(), <span class="string">"Should be resolved klass"</span>);</span><br><span class="line">      klassOop k_entry = (klassOop) entry;</span><br><span class="line">      assert(k_entry-&gt;klass_part()-&gt;oop_is_instance(), <span class="string">"Should be instanceKlass"</span>);</span><br><span class="line">      instanceKlass* ik = (instanceKlass*) k_entry-&gt;klass_part();</span><br><span class="line">      <span class="comment">// 确保对象所属类型已经经过初始化阶段</span></span><br><span class="line">      <span class="keyword">if</span> ( ik-&gt;is_initialized() &amp;&amp; ik-&gt;can_be_fastpath_allocated() ) &#123;</span><br><span class="line">        <span class="comment">// 取对象长度</span></span><br><span class="line">        <span class="keyword">size_t</span> obj_size = ik-&gt;size_helper();</span><br><span class="line">        oop result = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 记录是否需要将对象所有字段置零值</span></span><br><span class="line">        <span class="keyword">bool</span> need_zero = !ZeroTLAB;</span><br><span class="line">        <span class="comment">// 是否在TLAB中分配对象</span></span><br><span class="line">        <span class="keyword">if</span> (UseTLAB) &#123;</span><br><span class="line">          result = (oop) THREAD-&gt;tlab().allocate(obj_size);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="literal">NULL</span>) &#123;</span><br><span class="line">          need_zero = <span class="literal">true</span>;</span><br><span class="line">          <span class="comment">// 直接在eden中分配对象</span></span><br><span class="line">    retry:</span><br><span class="line">          HeapWord* compare_to = *Universe::heap()-&gt;top_addr();</span><br><span class="line">          HeapWord* new_top = compare_to + obj_size;</span><br><span class="line">          <span class="comment">// cmpxchg是x86中的CAS指令，这里是一个C++方法，通过CAS方式分配空间，并发失败的话，转到retry中重试直至成功分配为止</span></span><br><span class="line">          <span class="keyword">if</span> (new_top &lt;= *Universe::heap()-&gt;end_addr()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Atomic::cmpxchg_ptr(new_top, Universe::heap()-&gt;top_addr(), compare_to) != compare_to) &#123;</span><br><span class="line">              <span class="keyword">goto</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            result = (oop) compare_to;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (result != <span class="literal">NULL</span>) &#123;</span><br><span class="line">          <span class="comment">// 如果需要，为对象初始化零值</span></span><br><span class="line">          <span class="keyword">if</span> (need_zero ) &#123;</span><br><span class="line">            HeapWord* to_zero = (HeapWord*) result + <span class="keyword">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">            obj_size -= <span class="keyword">sizeof</span>(oopDesc) / oopSize;</span><br><span class="line">            <span class="keyword">if</span> (obj_size &gt; <span class="number">0</span> ) &#123;</span><br><span class="line">              <span class="built_in">memset</span>(to_zero, <span class="number">0</span>, obj_size * HeapWordSize);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 根据是否启用偏向锁，设置对象头信息</span></span><br><span class="line">          <span class="keyword">if</span> (UseBiasedLocking) &#123;</span><br><span class="line">            result-&gt;set_mark(ik-&gt;prototype_header());</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result-&gt;set_mark(markOopDesc::prototype());</span><br><span class="line">          &#125;</span><br><span class="line">          result-&gt;set_klass_gap(<span class="number">0</span>);</span><br><span class="line">          result-&gt;set_klass(k_entry);</span><br><span class="line">          <span class="comment">// 将对象引用入栈，继续执行下一条指令</span></span><br><span class="line">          SET_STACK_OBJECT(result, <span class="number">0</span>);</span><br><span class="line">          UPDATE_PC_AND_TOS_AND_CONTINUE(<span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></init></init></p><h3 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a>存储位置</h3><p>Java数据存储位置：</p><ul><li>寄存器：位于处理器内部，速度最快，数量有限，按需求分配，无法在程序中直接控制</li><li>堆栈：位于通用RAM(随机访问存储器)中，由堆栈指针控制分配，往上释放往下分配，故需要了解堆栈中数据的生命周期。存储数据有对象引用等</li><li>堆：通用的内存池(位于RAM区)，用于存放所有的Java对象，不需要了解生命周期，执行<code>new</code>时自动在堆中分配存储</li><li>常量存储：存放在代码内部</li><li>非RAM存储：把对象转化成可以存放在其他媒介上的事物，如流对象(对象转换成字节流发送至其他机器)和持久化对象(存放至磁盘)</li></ul><h3 id="特例：基本类型"><a href="#特例：基本类型" class="headerlink" title="特例：基本类型"></a>特例：基本类型</h3><p>当<code>new</code>创建一个特别小且简单的变量对象(如基本数据类型int、char、long等等)时存储至堆中，往往不是很有效，因此不用<code>new</code>来创建变量，而是创建一个并非是引用的“自动”变量，这个变量直接存储“值”，并置于堆栈中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'x'</span>;</span><br><span class="line">Character ch = <span class="keyword">new</span> Character(c);</span><br></pre></td></tr></table></figure></p><p>其中变量<code>c</code>为基本数据类型，存储在堆栈中，而通过<code>Character(c)</code>的自动装箱功能自动地将基本类型转换成包装器类型，存储在堆中。<br>高精度数字：<code>BigInteger</code>和<code>BigDecimal</code></p><h3 id="特例：数组"><a href="#特例：数组" class="headerlink" title="特例：数组"></a>特例：数组</h3><ul><li>数组的安全性：Java确保数组会被初始化，而且不能在它的范围之外被访问。这种范围检查，是以每个数组上少量的内存开销及运行时的下标检查为代价的</li><li>创建一个数组对象时，实际上就是创建一个引用数组，并且每个引用都会自动被初始化为一个特定值，该值拥有自己的关键字null。在使用任何引用前，必须为其指定一个对象。</li></ul><h2 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h2><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>作用域由花括号的位置决定。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">12</span>;</span><br><span class="line">  <span class="comment">// only x is available</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> q = <span class="number">30</span>;</span><br><span class="line">    <span class="comment">// both x and q are available</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// q is out of scope</span></span><br><span class="line">  <span class="comment">// only x is available</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>而作用域里定义的变量只可用于作用域结束之前</p><h3 id="对象的作用域"><a href="#对象的作用域" class="headerlink" title="对象的作用域"></a>对象的作用域</h3><p>Java对象与基本类型的生命周期不一样，当<code>new</code>创建一个Java对象时，它可以存活于作用域之外。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  String s = <span class="keyword">new</span> String(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>引用<code>s</code>在作用域终点就消失了，但是<code>s</code>指向的<code>String</code>对象仍继续占据内存空间。这就涉及到如何在作用域外传递和复制对象引用。</p><h3 id="对象的销毁-1"><a href="#对象的销毁-1" class="headerlink" title="对象的销毁"></a>对象的销毁</h3><p>Java存在一个垃圾回收器，用以监视用<code>new</code>创建的所有对象，并辨别那些不会再被引用的对象，随后释放这些对象的内存空间，以便供其他新的对象使用，消除了内存泄漏问题。<br>GC垃圾收集机制具体可见：<a href="http://jackeyzzhold.xyz/2018/03/20/java-GC/" target="_blank" rel="noopener">博客入口</a></p><h2 id="数据类型：类"><a href="#数据类型：类" class="headerlink" title="数据类型：类"></a>数据类型：类</h2><h3 id="字段"><a href="#字段" class="headerlink" title="字段"></a>字段</h3><p>字段有时被称为数据成员</p><ul><li>任何类型的对象，通过引用与其进行通信，必须初始化该引用，以便关联实际对象</li><li>基本类型的一种</li></ul><p>每个对象都有用来存储其字段的空间，普通字段不能在对象间共享。可以通过“引用名称.变量名称”进行字段赋值。<br>若类的某个成员是基本数据类型，则其存在一个默认值，但这并不适用于局部变量(及并非是某个类的字段),如某个方法中定义了<code>int x;</code>，那么<code>x</code>的值可能为任意值。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>java的方法决定了一个对象能够接受什么样的消息，其基本组成部分为：名称、参数、返回值和方法体</p><h3 id="名字可见性"><a href="#名字可见性" class="headerlink" title="名字可见性"></a>名字可见性</h3><p>反转域名确定唯一性</p><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p>通过static关键字满足以下两种需求：</p><ul><li>为某特定域分配单一存储空间，不考虑对象</li><li>希望某个方法不于包含它的类的任何对象关联在一起，即没有创建对象也可以调用这个方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Class StaticTest&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">48</span>;</span><br><span class="line">&#125;</span><br><span class="line">StaticTest st1 = <span class="keyword">new</span> StaticTest();</span><br><span class="line">StaticTest st2 = <span class="keyword">new</span> StaticTest();</span><br></pre></td></tr></table></figure><p>此时<code>st1.i</code>与<code>st2.i</code>指向同一存储空间。<br>引用static变量既可以使用对象引用去定位，也可以使用类名去定位，如<code>StaticTest.i</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这部分内容讲的是java中什么是对象，对象与引用的关系，对象如何创建的，对象如何销毁的，最后涉及到类的一些特性。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="java整理总结" scheme="http://yoursite.com/categories/java%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>deeplearning_word2vec</title>
    <link href="http://yoursite.com/2018/06/26/deeplearning-word2vec/"/>
    <id>http://yoursite.com/2018/06/26/deeplearning-word2vec/</id>
    <published>2018-06-26T09:42:03.000Z</published>
    <updated>2019-03-01T04:57:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p><strong>word2vec</strong> 是google在2013年推出的一个NLP工具，它的特点是将所有的词向量化，这样词与词之间就可以定量的去度量他们之间的关系，挖掘词之间的联系。虽然源码是开源的，但是谷歌的代码库国内无法访问，因此本文的讲解word2vec原理以Github上的<a href="https://github.com/tmikolov/word2vec" target="_blank" rel="noopener">word2vec</a>代码为准。<br><a id="more"></a></p></blockquote><hr><h2 id="词向量基础"><a href="#词向量基础" class="headerlink" title="词向量基础"></a>词向量基础</h2><h3 id="one-hot-representation"><a href="#one-hot-representation" class="headerlink" title="one hot representation"></a>one hot representation</h3><p>用词向量来表示词并不是word2vec的首创，在很久之前就出现了。最早的词向量是很冗长的，它使用是词向量维度大小为整个词汇表的大小，对于每个具体的词汇表中的词，将对应的位置置为1。比如我们有下面的5个词组成的词汇表，词”Queen”的序号为2， 那么它的词向量就是(0,1,0,0,0)。同样的道理，词”Woman”的词向量就是(0,0,0,1,0)。这种词向量的编码方式我们一般叫做1-of-N representation或者one hot representation.<br><img src="/2018/06/26/deeplearning-word2vec/pic1.png" alt=""><br>One hot representation用来表示词向量非常简单，但是却有很多问题。最大的问题是我们的词汇表一般都非常大，比如达到百万级别，这样每个词都用百万维的向量来表示简直是内存的灾难。这样的向量其实除了一个位置是1，其余的位置全部都是0，表达的效率不高，能不能把词向量的维度变小呢？</p><h3 id="Distributed-representation"><a href="#Distributed-representation" class="headerlink" title="Distributed representation"></a>Distributed representation</h3><p>Distributed representation可以解决One hot representation的问题，它的思路是通过训练，将每个词都映射到一个较短的词向量上来。所有的这些词向量就构成了向量空间，进而可以用普通的统计学的方法来研究词与词之间的关系。这个较短的词向量维度是多大呢？这个一般需要我们在训练时自己来指定。</p><p>比如下图我们将词汇表里的词用”Royalty”,”Masculinity”, “Femininity”和”Age”4个维度来表示，King这个词对应的词向量可能是(0.99,0.99,0.05,0.7)。当然在实际情况中，我们并不能对词向量的每个维度做一个很好的解释。<br><img src="/2018/06/26/deeplearning-word2vec/pic2.png" alt=""><br>有了用Distributed representation表示的较短的词向量，我们就可以较容易的分析词之间的关系了，比如我们将词的维度降维到2维，有一个有趣的研究表明，用下图的词向量表示我们的词时，我们可以发现：<br>$$\vec {King} - \vec {Man} + \vec {Woman} = \vec {Queen}$$<br><img src="/2018/06/26/deeplearning-word2vec/pic3.png" alt=""><br>可见我们只要得到了词汇表里所有词对应的词向量，那么我们就可以做很多有趣的事情了。不过，怎么训练得到合适的词向量呢？一个很常见的方法是使用神经网络语言模型。</p><p><strong>word2vec</strong> 做的事情很简单，大致来说，就是构建了一个多层神经网络，然后在给定文本中获取对应的输入和输出，在训练过程中不断修正神经网络中的参数，最后得到词向量。</p><h2 id="神经网络语言模型：CBOW、Skip-Gram"><a href="#神经网络语言模型：CBOW、Skip-Gram" class="headerlink" title="神经网络语言模型：CBOW、Skip-Gram"></a>神经网络语言模型：CBOW、Skip-Gram</h2><p>word2vec采用的是 <strong>n元语法模型(n-gram model)</strong>，即假设一个词只与周围n个词有关，而与文本中的其他词无关。</p><p>CBOW模型能够根据输入周围n-1个词来预测出这个词本身，而skip-gram模型能够根据词本身来预测周围有哪些词。也就是说，CBOW模型的输入是某个词A周围的n个单词的词向量之和，输出是词A本身的词向量；而skip-gram模型的输入是词A本身，输出是词A周围的n个单词的词向量(对的，要循环n遍)</p><h3 id="CBOW"><a href="#CBOW" class="headerlink" title="CBOW"></a>CBOW</h3><p>CBOW模型的训练输入是某一个特征词的上下文相关的词对应的词向量，而输出就是这特定的一个词的词向量。比如下面这段话，我们的上下文大小取值为4，特定的这个词是”Learning”，也就是我们需要的输出词向量,上下文对应的词有8个，前后各4个，这8个词是我们模型的输入。由于CBOW使用的是词袋模型，因此这8个词都是平等的，也就是不考虑他们和我们关注的词之间的距离大小，只要在我们上下文之内即可<br><img src="/2018/06/26/deeplearning-word2vec/pic4.png" alt=""><br>　这样我们这个CBOW的例子里，我们的输入是8个词向量，输出是所有词的softmax概率（训练的目标是期望训练样本特定词对应的softmax概率最大），对应的CBOW神经网络模型输入层有8个神经元，输出层有词汇表大小个神经元。隐藏层的神经元个数我们可以自己指定。通过DNN的反向传播算法，我们可以求出DNN模型的参数，同时得到所有的词对应的词向量。这样当我们有新的需求，要求出某8个词对应的最可能的输出中心词时，我们可以通过一次DNN前向传播算法并通过softmax激活函数找到概率最大的词对应的神经元即可。</p><h3 id="Skip-gram"><a href="#Skip-gram" class="headerlink" title="Skip-gram"></a>Skip-gram</h3><p>Skip-Gram模型和CBOW的思路是反着来的，即输入是特定的一个词的词向量，而输出是特定词对应的上下文词向量。还是上面的例子，我们的上下文大小取值为4， 特定的这个词”Learning”是我们的输入，而这8个上下文词是我们的输出。</p><p>这样我们这个Skip-Gram的例子里，我们的输入是特定词， 输出是softmax概率排前8的8个词，对应的Skip-Gram神经网络模型输入层有1个神经元，输出层有词汇表大小个神经元。隐藏层的神经元个数我们可以自己指定。通过DNN的反向传播算法，我们可以求出DNN模型的参数，同时得到所有的词对应的词向量。这样当我们有新的需求，要求出某1个词对应的最可能的8个上下文词时，我们可以通过一次DNN前向传播算法得到概率大小排前8的softmax概率对应的神经元所对应的词即可。</p><h2 id="word2vec的使用"><a href="#word2vec的使用" class="headerlink" title="word2vec的使用"></a>word2vec的使用</h2><p>word2vec也使用了CBOW与Skip-Gram来训练模型与得到词向量，但是并没有使用传统的DNN模型。最先优化使用的数据结构是用霍夫曼树来代替隐藏层和输出层的神经元，霍夫曼树的叶子节点起到输出层神经元的作用，叶子节点的个数即为词汇表的小大。 而内部节点则起到隐藏层神经元的作用。</p><p>word2vec有两种改进方法，一种是基于Hierarchical Softmax的，另一种是基于Negative Sampling的。</p><h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><p>霍夫曼树的建立过程如下：<br>输入：权值为(w1,w2,…wn)的n个节点<br>输出：对应的霍夫曼树<br>1）将(w1,w2,…wn)看做是有n棵树的森林，每个树仅有一个节点。<br>2）在森林中选择根节点权值最小的两棵树进行合并，得到一个新的树，这两颗树分布作为新树的左右子树。新树的根节点权重为左右子树的根节点权重之和。<br>3） 将之前的根节点权值最小的两棵树从森林删除，并把新树加入森林。<br>4）重复步骤2）和3）直到森林里只有一棵树为止。<br>下面我们用一个具体的例子来说明霍夫曼树建立的过程，我们有(a,b,c,d,e,f)共6个节点，节点的权值分布是(16,4,8,6,20,3)。<br>首先是最小的b和f合并，得到的新树根节点权重是7.此时森林里5棵树，根节点权重分别是16,8,6,20,7。此时根节点权重最小的6,7合并，得到新子树，依次类推，最终得到下面的霍夫曼树。<br><img src="/2018/06/26/deeplearning-word2vec/pic6.png" alt=""><br>那么霍夫曼树有什么好处呢？一般得到霍夫曼树后我们会对叶子节点进行霍夫曼编码，由于权重高的叶子节点越靠近根节点，而权重低的叶子节点会远离根节点，这样我们的高权重节点编码值较短，而低权重值编码值较长。这保证的树的带权路径最短，也符合我们的信息论，即我们希望越常用的词拥有更短的编码。如何编码呢？一般对于一个霍夫曼树的节点（根节点除外），可以约定左子树编码为0，右子树编码为1.如上图，则可以得到c的编码是00。</p><p>在word2vec中，约定编码方式和上面的例子相反，即约定左子树编码为1，右子树编码为0，同时约定左子树的权重不小于右子树的权重。</p><h3 id="基于Hierarchical-Softmax的word2vec模型"><a href="#基于Hierarchical-Softmax的word2vec模型" class="headerlink" title="基于Hierarchical Softmax的word2vec模型"></a>基于Hierarchical Softmax的word2vec模型</h3><h4 id="传统神经网络的局限性"><a href="#传统神经网络的局限性" class="headerlink" title="传统神经网络的局限性"></a>传统神经网络的局限性</h4><p>理论上说，无论是CBOW模型还是skip-gram模型，其具体的实现都可以用神经网络来完成。问题在于，这样做的计算量太大了。我们可以简略估计一下。首先定义一些变量的含义:</p><ul><li>n:一个词的上下文包含的词数，与n-gram中n的含义相同</li><li>m:词向量的长度，通常在10~100</li><li>h:隐藏层的规模，一般在100量级</li><li>N:词典的规模，通常在1W~10W</li><li>T:训练文本中单词个数</li></ul><p>以CBOW为例，输入层为n-1个单词的词向量，长度为m(n-1)，隐藏层的规模为h,输出层的规模为N。那么前向的时间复杂度就是o(m(n-1)h+hN) = o(hN) 这还是处理一个词所需要的复杂度。如果要处理所有文本，则需要o(hNT)的时间复杂度。这个是不可接受的。同时我们也注意到，o(hNT)之中，h和T的值相对固定，想要对其进行优化，主要还是应该从N入手。而输出层的规模之所以为N，是因为这个神经网络要完成的是N选1的任务。<br><img src="/2018/06/26/deeplearning-word2vec/pic7.png" alt=""><br>如上图所示，传统的神经网络词向量语言模型，里面一般有三层，输入层（词向量），隐藏层和输出层（softmax层）。里面最大的问题在于从隐藏层到输出的softmax层的计算量很大，因为要计算所有词的softmax概率，再去找概率最大的值。这个模型如下图所示。其中V是词汇表的大小，</p><p>那么可不可以减小N的值呢？答案是可以的。<strong>解决的思路就是将一次分类分解为多次分类，这也是Hierarchical Softmax的核心思想。</strong> 举个栗子，有[1,2,3,4,5,6,7,8]这8个分类，想要判断词A属于哪个分类，我们可以一步步来，首先判断A是属于[1,2,3,4]还是属于[5,6,7,8]。如果判断出属于[1,2,3,4]，那么就进一步分析是属于[1,2]还是[3,4]，以此类推，如图中所示的那样。这样一来，就把单个词的时间复杂度从o(h<em>N)降为o(h</em>logN)，更重要的减少了内存的开销。<br><img src="/2018/06/26/deeplearning-word2vec/pic5.png" alt=""><br>从上面可以看到从输入到输出，中间是一个树形结构，其中的每一个节点都完成一个二分类(logistic分类)问题。那么就存在一个如何构建树的问题。这里采用huffman树，因为这样构建的话，出现频率越高的词所经过的路径越短，从而使得所有单词的平均路径长度达到最短。</p><h4 id="模型概述"><a href="#模型概述" class="headerlink" title="模型概述"></a>模型概述</h4><p>word2vec对传统模型做了改进。</p><ul><li>首先，对于从输入层到隐藏层的映射，没有采取神经网络的线性变换加激活函数的方法，而是采用简单的对所有输入词向量求和并取平均的方法。比如输入的是三个4维词向量：(1,2,3,4),(9,6,11,8),(5,10,7,12),那么我们word2vec映射后的词向量就是(5,6,7,8)。由于这里是从多个词向量变成了一个词向量。</li><li>第二个改进就是从隐藏层到输出的softmax层这里的计算量改进。为了避免要计算所有词的softmax概率，word2vec采样了霍夫曼树来代替从隐藏层到输出softmax层的映射。我们在上一节已经介绍了霍夫曼树的原理。如何映射呢？这里就是理解word2vec的关键所在了。</li></ul><p>由于我们把之前所有都要计算的从输出softmax层的概率计算变成了一颗二叉霍夫曼树，那么我们的softmax概率计算只需要沿着树形结构进行就可以了。如下图所示，我们可以沿着霍夫曼树从根节点一直走到我们的叶子节点的词w2。<br><img src="/2018/06/26/deeplearning-word2vec/pic8.png" alt=""></p><p>和之前的神经网络语言模型相比，我们的霍夫曼树的所有内部节点就类似之前神经网络隐藏层的神经元,其中，根节点的词向量对应我们的投影后的词向量，而所有叶子节点就类似于之前神经网络softmax输出层的神经元，叶子节点的个数就是词汇表的大小。在霍夫曼树中，隐藏层到输出层的softmax映射不是一下子完成的，而是沿着霍夫曼树一步步完成的，因此这种softmax取名为”Hierarchical Softmax”。</p><p>如何“沿着霍夫曼树一步步完成”呢？在word2vec中，我们采用了二元逻辑回归的方法，即规定沿着左子树走，那么就是负类(霍夫曼树编码1)，沿着右子树走，那么就是正类(霍夫曼树编码0)。判别正类和负类的方法是使用sigmoid函数，即：<br>$$P(+) = \sigma(x_w^T\theta) = \frac{1}{1+e^{-x_w^T\theta}}$$<br>其中$x_w$是当前内部节点的词向量，而θ则是我们需要从训练样本求出的逻辑回归的模型参数。</p><p>使用霍夫曼树有什么好处呢？首先，由于是二叉树，之前计算量为V,现在变成了$log_2V$。第二，由于使用霍夫曼树是高频的词靠近树根，这样高频词需要更少的时间会被找到，这符合我们的贪心优化思想。</p><p>容易理解，被划分为左子树而成为负类的概率为P(−)=1−P(+)。在某一个内部节点，要判断是沿左子树还是右子树走的标准就是看P(−),P(+)谁的概率值大。而控制P(−),P(+)谁的概率值大的因素一个是当前节点的词向量，另一个是当前节点的模型参数θ。</p><p>对于上图中的$w_2$，如果它是一个训练样本的输出，那么我们期望对于里面的隐藏节点$n(w_2,1)$的P(−)概率大，$n(w_2,2)$的P(−)概率大，$n(w_2,3)$的P(+)概率大。</p><p>　　　　回到基于Hierarchical Softmax的word2vec本身，我们的目标就是找到合适的所有节点的词向量和所有内部节点θ, 使训练样本达到最大似然。那么如何达到最大似然呢？</p><h4 id="模型梯度计算"><a href="#模型梯度计算" class="headerlink" title="模型梯度计算"></a>模型梯度计算</h4><p>我们使用最大似然法来寻找所有节点的词向量和所有内部节点θ。先拿上面的$w_2$例子来看，我们期望最大化下面的似然函数：<br>$$\prod_{i=1}^3P(n(w_i),i) = (1- \frac{1}{1+e^{-x_w^T\theta_1}})(1- \frac{1}{1+e^{-x_w^T\theta_2}})\frac{1}{1+e^{-x_w^T\theta_3}}$$<br>对于所有的训练样本，我们期望最大化所有样本的似然函数乘积。</p><p>为了便于我们后面一般化的描述，我们定义输入的词为w,其从输入层词向量求和平均后的霍夫曼树根节点词向量为$x_w$, 从根节点到w所在的叶子节点，包含的节点总数为$l_w$, w在霍夫曼树中从根节点开始，经过的第i个节点表示为$p^w_i$,对应的霍夫曼编码为$d^w_i∈{0,1}$,其中$i=2,3,…l_w$。而该节点对应的模型参数表示为$θ^w_i$, 其中$i=1,2,…l_{w-1}$，没有$i=l_w$是因为模型参数仅仅针对于霍夫曼树的内部节点。</p><p>定义w经过的霍夫曼树某一个节点j的逻辑回归概率为$P(d^w_j|x_w,θ^w_{j-1})$，其表达式为：<br>$$P(d_j^w|x_w, \theta_{j-1}^w)= \begin{cases}  \sigma(x_w^T\theta_{j-1}^w)&amp; {d_j^w=0}\ 1-  \sigma(x_w^T\theta_{j-1}^w) &amp; {d_j^w = 1} \end{cases}$$</p><p>那么对于某一个目标输出词w,其最大似然为：<br>$$\prod_{j=2}^{l_w}P(d_j^w|x_w, \theta_{j-1}^w) = \prod_{j=2}^{l_w} [\sigma(x_w^T\theta_{j-1}^w)] ^{1-d_j^w}[1-\sigma(x_w^T\theta_{j-1}^w)]^{d_j^w}$$</p><p>在word2vec中，由于使用的是随机梯度上升法，所以并没有把所有样本的似然乘起来得到真正的训练集最大似然，仅仅每次只用一个样本更新梯度，这样做的目的是减少梯度计算量。这样我们可以得到w的对数似然函数L如下：<br>$$L= log \prod_{j=2}^{l_w}P(d_j^w|x_w, \theta_{j-1}^w) = \sum\limits_{j=2}^{l_w} ((1-d_j^w) log [\sigma(x_w^T\theta_{j-1}^w)]  + d_j^w log[1-\sigma(x_w^T\theta_{j-1}^w)])$$</p><p>要得到模型中w词向量和内部节点的模型参数θ, 我们使用梯度上升法即可。首先我们求模型参数$θ^w_{j-1}$的梯度：<br>$$\frac{\partial L}{\partial \theta_{j-1}^w}=(1-d_j^w)\frac{(\sigma(x_w^T\theta_{j-1}^w)(1-\sigma(x_w^T\theta_{j-1}^w)}{\sigma(x_w^T\theta_{j-1}^w)}x_w - d_j^w \frac{(\sigma(x_w^T\theta_{j-1}^w)(1-\sigma(x_w^T\theta_{j-1}^w)}{1- \sigma(x_w^T\theta_{j-1}^w)}x_w=(1-d_j^w)(1-\sigma(x_w^T\theta_{j-1}^w))x_w -  d_j^w\sigma(x_w^T\theta_{j-1}^w)x_w=(1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))x_w$$</p><p>如果大家看过之前写的逻辑回归原理小结，会发现这里的梯度推导过程基本类似。<br>同样的方法，可以求出xw的梯度表达式如下：<br>$$\frac{\partial L}{\partial x_w} = (1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))\theta_{j-1}^w$$</p><p>有了梯度表达式，我们就可以用梯度上升法进行迭代来一步步的求解我们需要的所有的$θ^w_{j-1}$和$x_w$。</p><h4 id="基于Hierarchical-Softmax的CBOW模型"><a href="#基于Hierarchical-Softmax的CBOW模型" class="headerlink" title="基于Hierarchical Softmax的CBOW模型"></a>基于Hierarchical Softmax的CBOW模型</h4><p>由于word2vec有两种模型：CBOW和Skip-Gram,我们先看看基于CBOW模型时， Hierarchical Softmax如何使用。</p><p>首先我们要定义词向量的维度大小M，以及CBOW的上下文大小2c,这样我们对于训练样本中的每一个词，其前面的c个词和后面的c个词作为了CBOW模型的输入,该词本身作为样本的输出，期望softmax概率最大。</p><p>在做CBOW模型前，我们需要先将词汇表建立成一颗霍夫曼树。</p><p>对于从输入层到隐藏层（投影层），这一步比较简单，就是对w周围的2c个词向量求和取平均即可，即：<br>$$x_w = \frac{1}{2c}\sum\limits_{i=1}^{2c}x_i$$<br>第二步，通过梯度上升法来更新我们的$θ^w_{j-1}$和$x_w$，注意这里的$x_w$是由2c个词向量相加而成，我们做梯度更新完毕后会用梯度项直接更新原始的各个$x_i(i=1,2,,,,2c)$，即：<br>$$\theta_{j-1}^w = \theta_{j-1}^w + \eta  (1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))x_w$$<br>$$x_w= x_w +\eta  (1-d_j^w-\sigma(x_w^T\theta_{j-1}^w))\theta_{j-1}^w \;(i =1,2..,2c)$$<br>其中η为梯度上升法的步长。</p><p>这里总结下基于Hierarchical Softmax的CBOW模型算法流程，梯度迭代使用了随机梯度上升法：</p><p>输入：基于CBOW的语料训练样本，词向量的维度大小M，CBOW的上下文大小2c,步长η<br>输出：霍夫曼树的内部节点模型参数θ，所有的词向量w</p><ul><li>基于语料训练样本建立霍夫曼树。</li><li>随机初始化所有的模型参数θ，所有的词向量w</li><li>进行梯度上升迭代过程，对于训练集中的每一个样本(context(w),w)做如下处理：<ul><li>e=0， 计算$x_w= \frac{1}{2c}\sum\limits_{i=1}^{2c}x_i$</li><li>for j = 2 to $l_w$, 计算：<br>$f = \sigma(x_w^T\theta_{j-1}^w)$<br>$g = (1-d_j^w-f)\eta$<br>$e = e + g\theta_{j-1}^w$<br>$\theta_{j-1}^w= \theta_{j-1}^w + gx_w$</li><li>对于$context(w)$中的每一个词向量$x_i$(共2c个)进行更新：<br>$x_i = x_i + e$</li><li>如果梯度收敛，则结束梯度迭代，否则回到步骤3继续迭代。</li></ul></li></ul><h4 id="基于Hierarchical-Softmax的Skip-Gram模型"><a href="#基于Hierarchical-Softmax的Skip-Gram模型" class="headerlink" title="基于Hierarchical Softmax的Skip-Gram模型"></a>基于Hierarchical Softmax的Skip-Gram模型</h4><p>现在我们先看看基于Skip-Gram模型时， Hierarchical Softmax如何使用。此时输入的只有一个词w,输出的为2c个词向量context(w)。</p><p>我们对于训练样本中的每一个词，该词本身作为样本的输入， 其前面的c个词和后面的c个词作为了Skip-Gram模型的输出,，期望这些词的softmax概率比其他的词大。</p><p>Skip-Gram模型和CBOW模型其实是反过来的，在上一篇已经讲过。</p><p>在做CBOW模型前，我们需要先将词汇表建立成一颗霍夫曼树。</p><p>对于从输入层到隐藏层（投影层），这一步比CBOW简单，由于只有一个词，所以，即xw就是词w对应的词向量。</p><p>第二步，通过梯度上升法来更新我们的$θ^w_{j-1}$和$x_w$，注意这里的$x_w$周围有2c个词向量，此时如果我们期望$P(x_i|x_w),i=1,2…2c$最大。此时我们注意到由于上下文是相互的，在期望$P(x_i|x_w),i=1,2…2c$最大化的同时，反过来我们也期望$P(x_w|x_i),i=1,2…2c$最大。那么是使用$P(x_i|x_w)$好还是$P(x_w|x_i)$好呢，word2vec使用了后者，这样做的好处就是在一次迭代时，我们不是更新$x_w$一个词，而是$x_i,i=1,2…2c$共2c个词。这样整体的迭代会更加的均衡。因为这个原因，Skip-Gram模型并没有和CBOW模型一样对输入进行迭代更新，而是对2c个输出进行迭代更新。</p><p>这里总结下基于Hierarchical Softmax的Skip-Gram模型算法流程，梯度迭代使用了随机梯度上升法：</p><p>输入：基于Skip-Gram的语料训练样本，词向量的维度大小M，Skip-Gram的上下文大小2c,步长η<br>输出：霍夫曼树的内部节点模型参数θ，所有的词向量w</p><ul><li>基于语料训练样本建立霍夫曼树。</li><li>随机初始化所有的模型参数θ，所有的词向量w,</li><li>进行梯度上升迭代过程，对于训练集中的每一个样本(w,context(w))做如下处理：<ul><li>for i =1 to 2c:<ul><li>e=0</li><li>for j = 2 to $l_w$, 计算：<br>$f = \sigma(x_i^T\theta_{j-1}^w)$<br>$g = (1-d_j^w-f)\eta$<br>$e = e + g\theta_{j-1}^w$<br>$\theta_{j-1}^w= \theta_{j-1}^w+ gx_i$</li><li>$x_i = x_i + e$</li></ul></li><li>如果梯度收敛，则结束梯度迭代，算法结束，否则回到步骤a继续迭代。</li></ul></li></ul><h3 id="word2vec大致流程"><a href="#word2vec大致流程" class="headerlink" title="word2vec大致流程"></a>word2vec大致流程</h3><ul><li><strong>分词/词干提取和词形还原。</strong> 中文和英文的nlp各有各的难点，中文的难点在于需要进行分词，将一个个句子分解成一个单词数组。而英文虽然不需要分词，但是要处理各种各样的时态，所以要进行词干提取和词形还原。</li><li><strong>构造词典，统计词频。</strong> 这一步需要遍历一遍所有文本，找出所有出现过的词，并统计各词的出现频率。</li><li><strong>构造树形结构。</strong> 依照出现概率构造Huffman树。如果是完全二叉树，则简单很多，后面会仔细解释。需要注意的是，所有分类都应该处于叶节点。<br><img src="/2018/06/26/deeplearning-word2vec/pic9.png" alt=""></li><li><strong>生成节点所在的二进制码。</strong> 拿上图举例，22对应的二进制码为00,而17对应的是100。也就是说，这个二进制码反映了节点在树中的位置，就像门牌号一样，能按照编码从根节点一步步找到对应的叶节点。</li><li><strong>初始化各非叶节点的中间向量和叶节点中的词向量。</strong> 树中的各个节点，都存储着一个长为m的向量，但叶节点和非叶结点中的向量的含义不同。叶节点中存储的是各词的词向量，是作为神经网络的输入的。而非叶结点中存储的是中间向量，对应于神经网络中隐含层的参数，与输入一起决定分类结果。</li><li><strong>训练中间向量和词向量。</strong> 对于CBOW模型，首先将词A附近的n-1个词的词向量相加作为系统的输入，并且按照词A在步骤4中生成的二进制码，一步步的进行分类并按照分类结果训练中间向量和词向量。举个栗子，对于绿17节点，我们已经知道其二进制码是100。那么在第一个中间节点应该将对应的输入分类到右边。如果分类到左边，则表明分类错误，需要对向量进行修正。第二个，第三个节点也是这样，以此类推，直到达到叶节点。因此对于单个单词来说，最多只会改动其路径上的节点的中间向量，而不会改动其他节点。<br><img src="/2018/06/26/deeplearning-word2vec/pic10.png" alt=""></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;word2vec&lt;/strong&gt; 是google在2013年推出的一个NLP工具，它的特点是将所有的词向量化，这样词与词之间就可以定量的去度量他们之间的关系，挖掘词之间的联系。虽然源码是开源的，但是谷歌的代码库国内无法访问，因此本文的讲解word2vec原理以Github上的&lt;a href=&quot;https://github.com/tmikolov/word2vec&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;word2vec&lt;/a&gt;代码为准。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习整理总结" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>收集整理</title>
    <link href="http://yoursite.com/2018/06/12/%E6%94%B6%E9%9B%86%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2018/06/12/收集整理/</id>
    <published>2018-06-12T06:03:29.000Z</published>
    <updated>2019-03-01T04:57:44.457Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p>关于<code>tensorflow</code>教程指南与实施案例的收集整理<br><a id="more"></a></p></blockquote><hr><h2 id="第一步：给TF新手的教程指南"><a href="#第一步：给TF新手的教程指南" class="headerlink" title="第一步：给TF新手的教程指南"></a>第一步：给TF新手的教程指南</h2><h3 id="1：tf初学者需要明白的入门准备"><a href="#1：tf初学者需要明白的入门准备" class="headerlink" title="1：tf初学者需要明白的入门准备"></a>1：tf初学者需要明白的入门准备</h3><p>机器学习入门笔记：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/ml_introduction.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/ml_introduction.ipynb</a></p></blockquote><p>MNIST 数据集入门笔记</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/mnist_dataset_intro.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/mnist_dataset_intro.ipynb</a></p></blockquote><h3 id="2：tf初学者需要了解的入门基础"><a href="#2：tf初学者需要了解的入门基础" class="headerlink" title="2：tf初学者需要了解的入门基础"></a>2：tf初学者需要了解的入门基础</h3><p>Hello World</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/1_Introduction/helloworld.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/1_Introduction/helloworld.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/1_Introduction/helloworld.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/1_Introduction/helloworld.py</a></p></blockquote><p>基本操作</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/1_Introduction/basic_operations.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/1_Introduction/basic_operations.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/1_Introduction/basic_operations.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/1_Introduction/basic_operations.py</a></p></blockquote><h3 id="3：tf初学者需要掌握的基本模型"><a href="#3：tf初学者需要掌握的基本模型" class="headerlink" title="3：tf初学者需要掌握的基本模型"></a>3：tf初学者需要掌握的基本模型</h3><p>最近邻：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/nearest_neighbor.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/nearest_neighbor.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/nearest_neighbor.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/nearest_neighbor.py</a></p></blockquote><p>线性回归：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/linear_regression.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/linear_regression.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/linear_regression.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/linear_regression.py</a></p></blockquote><p>Logistic 回归：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/logistic_regression.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/2_BasicModels/logistic_regression.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/logistic_regression.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/2_BasicModels/logistic_regression.py</a></p></blockquote><h3 id="4：tf初学者需要尝试的神经网络"><a href="#4：tf初学者需要尝试的神经网络" class="headerlink" title="4：tf初学者需要尝试的神经网络"></a>4：tf初学者需要尝试的神经网络</h3><p>多层感知器：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/multilayer_perceptron.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/multilayer_perceptron.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/multilayer_perceptron.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/multilayer_perceptron.py</a></p></blockquote><p>卷积神经网络：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/convolutional_network.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/convolutional_network.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/convolutional_network.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/convolutional_network.py</a></p></blockquote><p>循环神经网络（LSTM）：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/recurrent_network.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/recurrent_network.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/recurrent_network.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/recurrent_network.py</a></p></blockquote><p>双向循环神经网络（LSTM）：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/bidirectional_rnn.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/bidirectional_rnn.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/bidirectional_rnn.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/bidirectional_rnn.py</a></p></blockquote><p>动态循环神经网络（LSTM）</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/dynamic_rnn.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/dynamic_rnn.py</a></p></blockquote><p>自编码器</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/autoencoder.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/3_NeuralNetworks/autoencoder.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/autoencoder.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/3_NeuralNetworks/autoencoder.py</a></p></blockquote><h3 id="5：tf初学者需要精通的实用技术"><a href="#5：tf初学者需要精通的实用技术" class="headerlink" title="5：tf初学者需要精通的实用技术"></a>5：tf初学者需要精通的实用技术</h3><p>保存和恢复模型</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/4_Utils/save_restore_model.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/4_Utils/save_restore_model.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/save_restore_model.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/save_restore_model.py</a></p></blockquote><p>图和损失可视化</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/4_Utils/tensorboard_basic.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/4_Utils/tensorboard_basic.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/tensorboard_basic.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/tensorboard_basic.py</a></p></blockquote><p>Tensorboard——高级可视化</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/tensorboard_advanced.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/4_Utils/tensorboard_advanced.py</a></p></blockquote><h3 id="5：tf初学者需要的懂得的多GPU基本操作"><a href="#5：tf初学者需要的懂得的多GPU基本操作" class="headerlink" title="5：tf初学者需要的懂得的多GPU基本操作"></a>5：tf初学者需要的懂得的多GPU基本操作</h3><p>多 GPU 上的基本操作</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/5_MultiGPU/multigpu_basics.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/5_MultiGPU/multigpu_basics.ipynb</a></p></blockquote><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/5_MultiGPU/multigpu_basics.py" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/examples/5_MultiGPU/multigpu_basics.py</a></p></blockquote><h3 id="6：案例需要的数据集"><a href="#6：案例需要的数据集" class="headerlink" title="6：案例需要的数据集"></a>6：案例需要的数据集</h3><p>有一些案例需要 MNIST 数据集进行训练和测试。运行这些案例时，该数据集会被自动下载下来（使用 input_data.py）。<br>MNIST数据集笔记：</p><blockquote><p><a href="https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/mnist_dataset_intro.ipynb" target="_blank" rel="noopener">https://github.com/aymericdamien/TensorFlow-Examples/blob/master/notebooks/0_Prerequisite/mnist_dataset_intro.ipynb</a></p></blockquote><p>官方网站：<a href="http://yann.lecun.com/exdb/mnist/" target="_blank" rel="noopener">http://yann.lecun.com/exdb/mnist/</a></p><h2 id="第二步：为TF新手准备的各个类型的案例、模型和数据集"><a href="#第二步：为TF新手准备的各个类型的案例、模型和数据集" class="headerlink" title="第二步：为TF新手准备的各个类型的案例、模型和数据集"></a>第二步：为TF新手准备的各个类型的案例、模型和数据集</h2><p>初步了解：TFLearnTensorFlow<br>接下来的示例来自TFLearn，这是一个为 TensorFlow 提供了简化的接口的库。里面有很多示例和预构建的运算和层。<br>使用教程：TFLearn 快速入门。通过一个具体的机器学习任务学习 TFLearn 基础。开发和训练一个深度神经网络分类器。<br>TFLearn地址：<a href="https://github.com/tflearn/tflearn" target="_blank" rel="noopener">https://github.com/tflearn/tflearn</a><br>示例：<a href="https://github.com/tflearn/tflearn/tree/master/examples" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/tree/master/examples</a><br>预构建的运算和层：<a href="http://tflearn.org/doc_index/#api" target="_blank" rel="noopener">http://tflearn.org/doc_index/#api</a><br>笔记：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/tutorials/intro/quickstart.md" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/tutorials/intro/quickstart.md</a></p></blockquote><p>基础模型以及数据集<br>线性回归，使用 TFLearn 实现线性回归</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/linear_regression.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/linear_regression.py</a></p></blockquote><p>逻辑运算符。使用 TFLearn 实现逻辑运算符</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/logical.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/logical.py</a></p></blockquote><p>权重保持。保存和还原一个模型</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/weights_persistence.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/weights_persistence.py</a></p></blockquote><p>微调。在一个新任务上微调一个预训练的模型</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/finetuning.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/finetuning.py</a></p></blockquote><p>使用 HDF5。使用 HDF5 处理大型数据集</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/use_hdf5.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/use_hdf5.py</a></p></blockquote><p>使用 DASK。使用 DASK 处理大型数据集</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/basics/use_dask.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/basics/use_dask.py</a></p></blockquote><p>计算机视觉模型及数据集<br>多层感知器。一种用于 MNIST 分类任务的多层感知实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/dnn.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/dnn.py</a></p></blockquote><p>卷积网络（MNIST）。用于分类 MNIST 数据集的一种卷积神经网络实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_mnist.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_mnist.py</a></p></blockquote><p>卷积网络（CIFAR-10）。用于分类 CIFAR-10 数据集的一种卷积神经网络实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_cifar10.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_cifar10.py</a></p></blockquote><p>网络中的网络。用于分类 CIFAR-10 数据集的 Network in Network 实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/network_in_network.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/network_in_network.py</a></p></blockquote><p>Alexnet。将 Alexnet 应用于 Oxford Flowers 17 分类任务</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/alexnet.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/alexnet.py</a></p></blockquote><p>VGGNet。将 VGGNet 应用于 Oxford Flowers 17 分类任务</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/vgg_network.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/vgg_network.py</a></p></blockquote><p>VGGNet Finetuning (Fast Training)。使用一个预训练的 VGG 网络并将其约束到你自己的数据上，以便实现快速训练</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/vgg_network_finetuning.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/vgg_network_finetuning.py</a></p></blockquote><p>RNN Pixels。使用 RNN（在像素的序列上）分类图像</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/rnn_pixels.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/rnn_pixels.py</a></p></blockquote><p>Highway Network。用于分类 MNIST 数据集的 Highway Network 实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/highway_dnn.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/highway_dnn.py</a></p></blockquote><p>Highway Convolutional Network。用于分类 MNIST 数据集的 Highway Convolutional Network 实现</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_highway_mnist.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/convnet_highway_mnist.py</a></p></blockquote><p>Residual Network (MNIST) 。应用于 MNIST 分类任务的一种瓶颈残差网络（bottleneck residual network）</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/residual_network_mnist.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/residual_network_mnist.py</a></p></blockquote><p>Residual Network (CIFAR-10)。应用于 CIFAR-10 分类任务的一种残差网络</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/residual_network_cifar10.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/residual_network_cifar10.py</a></p></blockquote><p>Google Inception（v3）。应用于 Oxford Flowers 17 分类任务的谷歌 Inception v3 网络</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/googlenet.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/googlenet.py</a></p></blockquote><p>自编码器。用于 MNIST 手写数字的自编码器</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/images/autoencoder.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/images/autoencoder.py</a></p></blockquote><p>自然语言处理模型及数据集<br>循环神经网络（LSTM），应用 LSTM 到 IMDB 情感数据集分类任</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm.py</a></p></blockquote><p>双向 RNN（LSTM），将一个双向 LSTM 应用到 IMDB 情感数据集分类任务：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/bidirectional_lstm.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/bidirectional_lstm.py</a></p></blockquote><p>动态 RNN（LSTM），利用动态 LSTM 从 IMDB 数据集分类可变长度文本：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/dynamic_lstm.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/dynamic_lstm.py</a></p></blockquote><p>城市名称生成，使用 LSTM 网络生成新的美国城市名：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm_generator_cityname.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm_generator_cityname.py</a></p></blockquote><p>莎士比亚手稿生成，使用 LSTM 网络生成新的莎士比亚手稿：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm_generator_shakespeare.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/lstm_generator_shakespeare.py</a></p></blockquote><p>Seq2seq，seq2seq 循环网络的教学示例：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/seq2seq_example.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/seq2seq_example.py</a></p></blockquote><p>CNN Seq，应用一个 1-D 卷积网络从 IMDB 情感数据集中分类词序列</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/nlp/cnn_sentence_classification.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/nlp/cnn_sentence_classification.py</a></p></blockquote><p>强化学习案例<br>Atari Pacman 1-step Q-Learning，使用 1-step Q-learning 教一台机器玩 Atari 游戏：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/reinforcement_learning/atari_1step_qlearning.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/reinforcement_learning/atari_1step_qlearning.py</a></p></blockquote><h2 id="第三步：为TF新手准备的其他方面内容"><a href="#第三步：为TF新手准备的其他方面内容" class="headerlink" title="第三步：为TF新手准备的其他方面内容"></a>第三步：为TF新手准备的其他方面内容</h2><p>Recommender-Wide&amp;Deep Network，推荐系统中 wide &amp; deep 网络的教学示例：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/others/recommender_wide_and_deep.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/others/recommender_wide_and_deep.py</a></p></blockquote><p>Spiral Classification Problem，对斯坦福 CS231n spiral 分类难题的 TFLearn 实现：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/notebooks/spiral.ipynb" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/notebooks/spiral.ipynb</a></p></blockquote><p>层，与 TensorFlow 一起使用 TFLearn 层：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/layers.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/layers.py</a></p></blockquote><p>训练器，使用 TFLearn 训练器类训练任何 TensorFlow 图：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/layers.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/layers.py</a></p></blockquote><p>Bulit-in Ops，连同 TensorFlow 使用 TFLearn built-in 操作：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/builtin_ops.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/builtin_ops.py</a></p></blockquote><p>Summaries，连同 TensorFlow 使用 TFLearn summarizers：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/summaries.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/summaries.py</a></p></blockquote><p>Variables，连同 TensorFlow 使用 TFLearn Variables：</p><blockquote><p><a href="https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/variables.py" target="_blank" rel="noopener">https://github.com/tflearn/tflearn/blob/master/examples/extending_tensorflow/variables.py</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于&lt;code&gt;tensorflow&lt;/code&gt;教程指南与实施案例的收集整理&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="杂" scheme="http://yoursite.com/categories/%E6%9D%82/"/>
    
    
      <category term="tf" scheme="http://yoursite.com/tags/tf/"/>
    
  </entry>
  
  <entry>
    <title>个性化推荐系统笔记</title>
    <link href="http://yoursite.com/2018/06/04/%E4%B8%AA%E6%80%A7%E5%8C%96%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/06/04/个性化推荐系统笔记/</id>
    <published>2018-06-04T10:49:57.000Z</published>
    <updated>2019-03-01T04:57:43.166Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p>个性化推荐系统案例分析，未完…<br><a id="more"></a></p></blockquote><hr><h2 id="程序解析"><a href="#程序解析" class="headerlink" title="程序解析"></a>程序解析</h2><h3 id="数据处理部分"><a href="#数据处理部分" class="headerlink" title="数据处理部分"></a>数据处理部分</h3><h4 id="导入的包"><a href="#导入的包" class="headerlink" title="导入的包"></a>导入的包</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> tensorflow.python.ops <span class="keyword">import</span> math_ops</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlretrieve</span><br><span class="line"><span class="keyword">from</span> os.path <span class="keyword">import</span> isfile, isdir</span><br><span class="line"><span class="keyword">from</span> tqdm <span class="keyword">import</span> tqdm</span><br><span class="line"><span class="keyword">import</span> zipfile</span><br><span class="line"><span class="keyword">import</span> hashlib</span><br></pre></td></tr></table></figure><h4 id="数据下载"><a href="#数据下载" class="headerlink" title="数据下载"></a>数据下载</h4><p>1) <code>os.path.join(,)</code>将路径拼接起来；<br>2) <code>os.path.exists()</code>判断路径是否存在；<br>3) <code>print(&#39;Found {} Data&#39;.format(database_name))</code>字符串占位符写法<br>4) <code>os.makedirs()</code>创建目录；<code>shutil.rmtree</code>删除目录<br>5) <code>with...as...</code>处理上下文环境产生的异常。<strong>工作过程：</strong> 紧跟<code>with</code>后面的语句被求值后，返回对象的<code>__enter__()</code>方法被调用，这个方法的返回值将被赋值给<code>as</code>后面的变量。当<code>with</code>后面的代码块全部被执行完之后，将调用前面返回对象的<code>__exit__()</code>方法。<br>6) <code>DLProgress(tqdm)</code> 显示下载进度条的格式<br>7) <code>urlretrieve(url, filename=None, reporthook=None, data=None)</code></p><pre><code>- 参数`finename`指定了保存本地路径(如果参数未指定，`urllib`会生成一个临时文件保存数据)- 参数`reporthook`是一个回调函数，当连接上服务器、以及相应的数据块传输完毕时会触发该回调，我们可以利用这个回调函数来显示当前的下载进度。- 参数`data`指post到服务器的数据，该方法返回一个包含两个元素的(filename, headers)元组，filename表示保存到本地的路径，header表示服务器的响应头。</code></pre><p>8) <code>assert</code> 没完善一个程序之前，我们不知道程序在哪里会出错，与其让它在运行最崩溃，不如在出现错误条件时就崩溃，这时候就需要<code>assert</code>断言。其是声明其布尔值必须为真的判定，如果发生异常就说明表达示为假。可以理解<code>assert</code>断言语句为<code>raise-if-not</code>，用来测试表示式，其返回值为假，就会触发异常。<strong>assert的异常参数</strong>，其实就是在 <strong>断言表达式后添加字符串信息</strong>，用来解释断言并更好的知道是哪里出了问题。<br>9) <code>hashlib.md5(open(save_path, &#39;rb&#39;).read()).hexdigest()</code>打开文件并读取文件内容，通过<code>hashlib.md5</code>进行加密，<code>hexdigest()</code>获取加密字符串。<br>10) <code>zipfile.ZipFile(filename,&#39;r&#39;)</code>读取zip文件；<code>zipfile.ZipFile.extractall</code>解压zip文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">_unzip</span><span class="params">(save_path, _, database_name, data_path)</span>:</span></span><br><span class="line">print(<span class="string">'Extracting &#123;&#125;...'</span>.format(database_name))</span><br><span class="line"><span class="keyword">with</span> zipfile.ZipFile(save_path) <span class="keyword">as</span> zf:</span><br><span class="line">zf.extractall(data_path)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download_extract</span><span class="params">(database_name, data_path)</span>:</span></span><br><span class="line">DATASET_ML1M=<span class="string">'ml-1m'</span></span><br><span class="line"><span class="keyword">if</span> database_name==DATASET_ML1M:</span><br><span class="line">url=<span class="string">'http://files.grouplens.org/datasets/movielens/ml-1m.zip'</span></span><br><span class="line">hashcode=<span class="string">'c4d9eecfca2ab87c1945afe126590906'</span></span><br><span class="line">extract_path=os.path.join(data_path,<span class="string">'ml-1m'</span>)</span><br><span class="line">save_path=os.path.join(data_path,<span class="string">'ml-1m.zip'</span>)</span><br><span class="line">extract_fn=_unzip</span><br><span class="line"><span class="keyword">if</span> os.path.exists(extract_path):</span><br><span class="line">print(<span class="string">'Found &#123;&#125; Data'</span>.format(database_name))</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(data_path):</span><br><span class="line">os.makedirs(data_path)</span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(save_path):</span><br><span class="line"><span class="keyword">with</span> DLProgress(unit=<span class="string">'B'</span>,unit_scale=<span class="keyword">True</span>,miniters=<span class="number">1</span>,desc=<span class="string">'Downloading &#123;&#125;'</span>.format(database_name)) <span class="keyword">as</span> pbar:</span><br><span class="line">urlretrieve(</span><br><span class="line">url,</span><br><span class="line">save_path,</span><br><span class="line">pbar.hook)</span><br><span class="line"><span class="keyword">assert</span> hashlib.md5(open(save_path,<span class="string">'rb'</span>).read()).hexdigest()==hashcode,\</span><br><span class="line"><span class="string">'&#123;&#125; file is corrupted. Remove the file and try again.'</span>.format(save_path)</span><br><span class="line">os.makedirs(extract_path)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">extract_fn(save_path,extract_path,database_name,data_path)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> err:</span><br><span class="line">shutil.rmtree(extract_path)</span><br><span class="line"><span class="keyword">raise</span> err</span><br><span class="line">print(<span class="string">'Done.'</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DLProgress</span><span class="params">(tqdm)</span>:</span></span><br><span class="line">last_block=<span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hook</span><span class="params">(self,block_num=<span class="number">1</span>,block_size=<span class="number">1</span>,total_size=None)</span>:</span></span><br><span class="line">self.total=total_size</span><br><span class="line">self.update((block_num-self.last_block)*block_size)</span><br><span class="line">self.last_block=block_num</span><br></pre></td></tr></table></figure><h4 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h4><ol><li><code>pd.read_table(&#39;./ml-1m/users.dat&#39;, sep=&#39;::&#39;, header=None, names=users_title, engine = &#39;python&#39;)</code> sep:分隔符；header：列名；names：结合header=None用于结果的列名列表。</li><li><code>users.filter(regex=&#39;UserID|Gender|Age|JobID&#39;)</code>过滤掉不符合条件，返回符合条件的数据。</li><li><code>users.values</code>原始数据；<code>users[&#39;Gender&#39;].map(gender_map)</code>映射</li><li><code>enumerate</code>对于一个可迭代的(iterable)/可遍历的对象(如列表、字符串)，<code>enumerate</code>将其组成一个索引序列，利用它可以同时获得索引和值</li><li><code>pattern = re.compile(r&#39;^(.*)\((\d+)\)$&#39;)</code>、<code>pattern.match(val).group(1)</code>返回匹配后的第一组数据。<br>6.</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">load_data</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#读取User数据</span></span><br><span class="line">users_title = [<span class="string">'UserID'</span>, <span class="string">'Gender'</span>, <span class="string">'Age'</span>, <span class="string">'JobID'</span>, <span class="string">'Zip-code'</span>]</span><br><span class="line">users = pd.read_table(<span class="string">'./ml-1m/users.dat'</span>, sep=<span class="string">'::'</span>, header=<span class="keyword">None</span>, names=users_title, engine = <span class="string">'python'</span>)</span><br><span class="line">users = users.filter(regex=<span class="string">'UserID|Gender|Age|JobID'</span>)</span><br><span class="line">users_orig = users.values</span><br><span class="line"><span class="comment">#改变User数据中性别和年龄</span></span><br><span class="line">gender_map = &#123;<span class="string">'F'</span>:<span class="number">0</span>, <span class="string">'M'</span>:<span class="number">1</span>&#125;</span><br><span class="line">users[<span class="string">'Gender'</span>] = users[<span class="string">'Gender'</span>].map(gender_map)</span><br><span class="line"></span><br><span class="line">age_map = &#123;val:ii <span class="keyword">for</span> ii,val <span class="keyword">in</span> enumerate(set(users[<span class="string">'Age'</span>]))&#125;</span><br><span class="line">users[<span class="string">'Age'</span>] = users[<span class="string">'Age'</span>].map(age_map)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取Movie数据集</span></span><br><span class="line">movies_title = [<span class="string">'MovieID'</span>, <span class="string">'Title'</span>, <span class="string">'Genres'</span>]</span><br><span class="line">movies = pd.read_table(<span class="string">'./ml-1m/movies.dat'</span>, sep=<span class="string">'::'</span>, header=<span class="keyword">None</span>, names=movies_title, engine = <span class="string">'python'</span>)</span><br><span class="line">movies_orig = movies.values</span><br><span class="line"><span class="comment">#将Title中的年份去掉</span></span><br><span class="line">pattern = re.compile(<span class="string">r'^(.*)\((\d+)\)$'</span>)</span><br><span class="line"></span><br><span class="line">title_map = &#123;val:pattern.match(val).group(<span class="number">1</span>) <span class="keyword">for</span> ii,val <span class="keyword">in</span> enumerate(set(movies[<span class="string">'Title'</span>]))&#125;</span><br><span class="line">movies[<span class="string">'Title'</span>] = movies[<span class="string">'Title'</span>].map(title_map)</span><br><span class="line"></span><br><span class="line"><span class="comment">#电影类型转数字字典</span></span><br><span class="line">genres_set = set()</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> movies[<span class="string">'Genres'</span>].str.split(<span class="string">'|'</span>):</span><br><span class="line">genres_set.update(val)</span><br><span class="line"></span><br><span class="line">genres_set.add(<span class="string">'&lt;PAD&gt;'</span>)</span><br><span class="line">genres2int = &#123;val:ii <span class="keyword">for</span> ii, val <span class="keyword">in</span> enumerate(genres_set)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#将电影类型转成等长数字列表，长度是18</span></span><br><span class="line">genres_map = &#123;val:[genres2int[row] <span class="keyword">for</span> row <span class="keyword">in</span> val.split(<span class="string">'|'</span>)] <span class="keyword">for</span> ii,val <span class="keyword">in</span> enumerate(set(movies[<span class="string">'Genres'</span>]))&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> genres_map:</span><br><span class="line"><span class="keyword">for</span> cnt <span class="keyword">in</span> range(max(genres2int.values()) - len(genres_map[key])):</span><br><span class="line">genres_map[key].insert(len(genres_map[key]) + cnt,genres2int[<span class="string">'&lt;PAD&gt;'</span>])</span><br><span class="line"></span><br><span class="line">movies[<span class="string">'Genres'</span>] = movies[<span class="string">'Genres'</span>].map(genres_map)</span><br><span class="line"></span><br><span class="line"><span class="comment">#电影Title转数字字典</span></span><br><span class="line">title_set = set()</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> movies[<span class="string">'Title'</span>].str.split():</span><br><span class="line">title_set.update(val)</span><br><span class="line"></span><br><span class="line">title_set.add(<span class="string">'&lt;PAD&gt;'</span>)</span><br><span class="line">title2int = &#123;val:ii <span class="keyword">for</span> ii, val <span class="keyword">in</span> enumerate(title_set)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#将电影Title转成等长数字列表，长度是15</span></span><br><span class="line">title_count = <span class="number">15</span></span><br><span class="line">title_map = &#123;val:[title2int[row] <span class="keyword">for</span> row <span class="keyword">in</span> val.split()] <span class="keyword">for</span> ii,val <span class="keyword">in</span> enumerate(set(movies[<span class="string">'Title'</span>]))&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> title_map:</span><br><span class="line"><span class="keyword">for</span> cnt <span class="keyword">in</span> range(title_count - len(title_map[key])):</span><br><span class="line">title_map[key].insert(len(title_map[key]) + cnt,title2int[<span class="string">'&lt;PAD&gt;'</span>])</span><br><span class="line"></span><br><span class="line">movies[<span class="string">'Title'</span>] = movies[<span class="string">'Title'</span>].map(title_map)</span><br><span class="line"></span><br><span class="line"><span class="comment">#读取评分数据集</span></span><br><span class="line">ratings_title = [<span class="string">'UserID'</span>,<span class="string">'MovieID'</span>, <span class="string">'ratings'</span>, <span class="string">'timestamps'</span>]</span><br><span class="line">ratings = pd.read_table(<span class="string">'./ml-1m/ratings.dat'</span>, sep=<span class="string">'::'</span>, header=<span class="keyword">None</span>, names=ratings_title, engine = <span class="string">'python'</span>)</span><br><span class="line">ratings = ratings.filter(regex=<span class="string">'UserID|MovieID|ratings'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#合并三个表</span></span><br><span class="line">data = pd.merge(pd.merge(ratings, users), movies)</span><br><span class="line"></span><br><span class="line"><span class="comment">#将数据分成X和y两张表</span></span><br><span class="line">target_fields = [<span class="string">'ratings'</span>]</span><br><span class="line">features_pd, targets_pd = data.drop(target_fields, axis=<span class="number">1</span>), data[target_fields]</span><br><span class="line"></span><br><span class="line">features = features_pd.values</span><br><span class="line">targets_values = targets_pd.values</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> title_count, title_set, genres2int, features, targets_values, ratings, users, movies, data, movies_orig, users_orig</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:</span><br><span class="line"><span class="comment">#title_count, title_set, genres2int, features, targets_values, ratings, users, movies, data, movies_orig, users_orig = load_data()</span></span><br><span class="line"><span class="comment">#pickle.dump((title_count, title_set, genres2int, features, targets_values, ratings, users, movies, data, movies_orig, users_orig), open('preprocess.p', 'wb'))</span></span><br><span class="line">title_count, title_set, genres2int, features, targets_values, ratings, users, movies, data, movies_orig, users_orig = pickle.load(open(<span class="string">'preprocess.p'</span>, mode=<span class="string">'rb'</span>))</span><br><span class="line">print(users.head())</span><br><span class="line">print(movies.head())</span><br><span class="line">print(movies.values[<span class="number">0</span>])</span><br></pre></td></tr></table></figure><p>###</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;个性化推荐系统案例分析，未完…&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="深度学习整理总结" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%95%B4%E7%90%86%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="推荐" scheme="http://yoursite.com/tags/%E6%8E%A8%E8%8D%90/"/>
    
  </entry>
  
  <entry>
    <title>模式识别总结7_pca</title>
    <link href="http://yoursite.com/2018/05/22/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%80%BB%E7%BB%937-pca/"/>
    <id>http://yoursite.com/2018/05/22/模式识别总结7-pca/</id>
    <published>2018-05-22T05:52:28.000Z</published>
    <updated>2019-03-01T04:57:41.548Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p>主成分分析(Principle Component Analysis) 最早被提出是用于数据分析上的一种方法，用于降维变换，其主要思想就是从一组特征中计算出一组按贡献程度从大到小排列的新特征，这组新特征是原始特征的线性组合，且相互之间不相关。<br><a id="more"></a></p></blockquote><hr><h2 id="pca的用途"><a href="#pca的用途" class="headerlink" title="pca的用途"></a>pca的用途</h2><p>一个模式识别系统设计的好坏，首要取决于所选用的特征是否较好的反映了正在研究的问题。模式识别问题的第一步是获取特征，获取来的特征被称作原始特征，其中可能有很多特征与我们研究的问题没多大关系，它们在后续的分类中甚至还有可能影响分类性能；另外，就算这些特征都是与研究问题有联系的，但是太多的特征会导致计算量大、推广能力差，所以原始特征必须要进一步清洗得到二次特征，即在保证分类器效果的前提下应该使特征数尽可能的少，主要有两种办法：</p><ul><li>一种是特征选择，从D个特征中选出d(d小于D)个特征</li><li>另一种是特征提取或特征变换，通过把特征空间降维变换得到d个特征。</li></ul><p>关于特征选择，需要回答两方面的问题：</p><ul><li>特征的评价准则：如何衡量一组特征对分类的有效性</li><li>特征的寻优算法：怎样更快地找到性能最优或较好的特征组合。</li></ul><p>关于特征提取，通常采用线性变换:$y=W^Tx$；一般情况下的特征变换就是降维变换，即高维空间到低维空间的映射。<br><strong>主成分分析(Principle Component Analysis)</strong> 最早被提出是用于数据分析上的一种方法，其主要思想就是从一组特征中计算出一组按贡献程度从大到小排列的新特征，这组新特征是原始特征的线性组合，且相互之间不相关。</p><p>是通过正交变换将一组可能存在相关性的变量转换为一组线性不相关的变量，转换后的这组变量叫主成分。通俗的讲就是将分布在多个维度的高维数据投射到几个轴上。</p><h2 id="pca算法"><a href="#pca算法" class="headerlink" title="pca算法"></a>pca算法</h2><p>1、假设由数据的特征和记录构成二维矩阵$X$，即$X$的一列表示一个特征，一行表示一条记录(一个示例)，$X$是一个$m$行$n$列的矩阵(需要进行减去平均值处理)。</p><p>2、计算$X$的转置$X^T$。$X^T$为$n$行$m$列的矩阵。</p><p>3、计算$X^T$任意两行之间的协方差，得到一个$n$行$n$列的协方差矩阵$CovX$。</p><p>4、求$CovX$的特征值和特征向量，得到$n$个特征值和一个$n$行$n$列的特征向量矩阵$V_0$。</p><p>5、根据$n$个特征值的大小，降序排序，取最大的$k$个特征值，并取这$k$个特征值对应的特征向量，得到一个$k$行$n$列的特征向量矩阵$V$。</p><p>6、将$k$行$n$列的特征向量$V$与$n$行$m$列的矩阵$X^T$相乘，得到$k$行$m$列的矩阵$Y_0$。</p><p>7、将$Y_0$进行转置就得到$m$行$k$列的矩阵$Y$，这个矩阵$Y$就是包含$k$个主要成分的数据。<br>算法代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pca</span><span class="params">(dataMat,topNfeat=<span class="number">9999999</span>)</span>:</span></span><br><span class="line">meanVals=mean(dataMat,axis=<span class="number">0</span>)  <span class="comment">##axis的值表示哪一维度压缩为1.=0时表示输出一行，每一列的平均值</span></span><br><span class="line">meanRemoved=dataMat-meanVals   <span class="comment">##减去平均值</span></span><br><span class="line">covMat=cov(meanRemoved,rowvar=<span class="number">0</span>)  <span class="comment">##协方差</span></span><br><span class="line">eigVals,eigVects=linalg.eig(mat(covMat))  <span class="comment">##特征值和特征向量</span></span><br><span class="line">eigValInd=argsort(eigVals)    <span class="comment">##特征值排序从小到大</span></span><br><span class="line">eigValInd=eigValInd[:-(topNfeat+<span class="number">1</span>):<span class="number">-1</span>]   </span><br><span class="line">redEigVects=eigVects[:,eigValInd]   <span class="comment">##前topNfeat个特征及特征向量</span></span><br><span class="line">lowDDataMat=meanRemoved*redEigVects  </span><br><span class="line">reconMat=(lowDDataMat*redEigVects.T)+meanVals</span><br><span class="line"><span class="keyword">return</span> lowDDataMat,reconMat</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主成分分析(Principle Component Analysis) 最早被提出是用于数据分析上的一种方法，用于降维变换，其主要思想就是从一组特征中计算出一组按贡献程度从大到小排列的新特征，这组新特征是原始特征的线性组合，且相互之间不相关。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="模式识别" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>模式识别总结6_cluster、ensemble</title>
    <link href="http://yoursite.com/2018/05/22/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%80%BB%E7%BB%936-cluster%E3%80%81ensemble/"/>
    <id>http://yoursite.com/2018/05/22/模式识别总结6-cluster、ensemble/</id>
    <published>2018-05-22T05:52:03.000Z</published>
    <updated>2019-03-01T04:57:39.277Z</updated>
    
    <content type="html"><![CDATA[<p><code>前言</code></p><blockquote><p> 聚类分析的基本思想是 “物以类聚、人以群分”，因此大量的数据集中必然存在相似的数据点，基于这个假设就可以将数据区分出来，并发现每个数据集(分类)的特征。<br>ensemble集成学习，训练若干个个体学习器，通过一定的结合策略，就可以最终形成一个强学习器，以达到博采众长的目的。<br><a id="more"></a></p></blockquote><hr><h2 id="聚类clustering"><a href="#聚类clustering" class="headerlink" title="聚类clustering"></a>聚类clustering</h2><h3 id="监督学习vs非监督学习"><a href="#监督学习vs非监督学习" class="headerlink" title="监督学习vs非监督学习"></a>监督学习vs非监督学习</h3><ul><li>监督学习：在那些数据属性特征与目标类别属性相联系的数据集中发现其中的模式关系，这种模式关系被用来预测测试集数据的目标属性值</li><li>非监督学习：没有目标属性</li></ul><h3 id="聚类基础概念"><a href="#聚类基础概念" class="headerlink" title="聚类基础概念"></a>聚类基础概念</h3><p><strong>聚类</strong> 是数据挖掘中的基本任务，聚类是将大量数据集中具有“相似”特征的数据点划分为统一类别，并最终生成多个类的方法。</p><p>聚类分析的基本思想是 <strong>“物以类聚、人以群分”</strong>，因此大量的数据集中必然存在相似的数据点，基于这个假设就可以将数据区分出来，并发现每个数据集(分类)的特征。</p><p>与聚类的概念类似的另外一个概念是“分类”，实际上二者经常被混用。但二者根本上是不同的：</p><ul><li>学习方式不同。聚类是一种非监督式学习算法，而分类是监督式学习算法。</li><li>对源数据集要求不同。聚类不要求源数据集有标签，但分类需要标签用来做学习。</li><li>应用场景不同。聚类一般应用于做数据探索性分析，而分类更多的用于预测性分析。</li><li>解读结果不同。聚类算法的结果是将不同的数据集按照各自的典型特征分成不同类别，不同人对聚类的结果解读可能不同；而分类的结果却是一个固定值，不存在不同解读的情况。</li></ul><p>聚类是一类成熟且经典的数据挖掘和机器学习算法，按照不同的维度划分有很多经典的算法，如 <strong>K均值(K-Means)</strong>、两步聚类、Kohonen等，甚至Python提供了9种聚类算法。</p><h3 id="分区聚类-Partitional-Clustering"><a href="#分区聚类-Partitional-Clustering" class="headerlink" title="分区聚类(Partitional Clustering)"></a>分区聚类(Partitional Clustering)</h3><p>点到聚类$i$中心的距离：<br>$$se_{k_i}=\sum_{x_j\in Cluster\quad i}||x_j-C_i||^2$$<br>目标函数：<br>$$se_k=\sum_{i=1}^kse_{k_i}$$</p><h4 id="K均值-K-Means"><a href="#K均值-K-Means" class="headerlink" title="K均值(K-Means)"></a>K均值(K-Means)</h4><p>聚类首先面临的一个问题是，如何衡量不同数据之间的“相似度”。大多数“相似度”都是基于距离计算的，距离计算可以分为两类：</p><ul><li>基于几何距离的“相似度”<br>为了方便计算，假设平面上两点a(x1,y1)与b(x2,y2)）<ul><li>欧式距离 : a和b平方和的开方(结果越大，相似度越高)<br>$$d_{12}=\sqrt{(x_1-x_2)^2+(y_1-y_2)^2}$$</li><li>曼哈顿距离 : 每个维度的距离之和(结果越大，相似度越高)<br>$$d_{12}=|x_1-x_2|+|y_1-y_2|$$</li><li>切比雪夫距离: 每个维度上距离的最大值(结果越大，相似度越高)<br>$$d_{12}=max(|x_1-x_2|,|y_1-y_2|)$$</li></ul></li><li>基于非几何距离的“相似度”<ul><li>余弦距离：两个向量的夹角<br>$$cos\theta=\dfrac{x_1x_2+y_1y_2}{\sqrt{x_1^2+y_1^2}\sqrt{x_2^2+y_2^2}}$$<br>夹角余弦取值范围为[-1,1]。夹角余弦越大表示两个向量的夹角越小，夹角余弦越小表示两向量的夹角越大。当两个向量的方向重合时夹角余弦取最大值1，当两个向量的方向完全相反夹角余弦取最小值-1。</li><li>汉明距离<br>两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。例如字符串“1111”与“1001”之间的汉明距离为2。</li><li>杰卡德相似系数(Jaccard similarity coefficient)<br>$$J(A,B)=\dfrac{|A\bigcap B|}{|A\bigcup B|}$$</li><li>相关系数(Correlation coefficient)<br>$$\rho_{XY}=\dfrac{Cov(X,Y)}{\sqrt{D(X)}\sqrt{D(Y)}}=\dfrac{E((X-EX)(Y-EY))}{\sqrt{D(X)}\sqrt{D(Y)}}$$<br>相关系数是衡量随机变量X与Y相关程度的一种方法，相关系数的取值范围是[-1,1]。相关系数的绝对值越大，则表明X与Y相关度越高。当X与Y线性相关时，相关系数取值为1(正线性相关)或-1(负线性相关)。</li></ul></li></ul><p>除了上述常用相似度计算方法外，还可能包括马氏距离、闵可夫斯基距离、标准欧氏距离等。</p><p>回到本文的主题 <strong>K-Means算法</strong> 来，通过上述算法来计算数据相似度(大多数选择欧氏距离)，但我们会发现不同维度间由于度量单位的差异，计算的结果值会产生很大差异。例如假设A和B两个点分别具有两个维度：订单金额和转化率，那么订单金额的取值范围可能是0到无穷大，而转化率的取值为0到1，因此计算结果会由于订单金额的取值范围而“片面”夸大了这一维度的计算比重。所以大多数情况下，如果存在这种度量量级的差异会选择数据标准化，使不同维度落到相同的数据区间内然后进行计算。</p><blockquote><p>上面说到大多数情况下需要标准化，就意味着不是所有的场景下都需要标准化，一种是原有的数据维度之间的量级差异不大，因此没有必要标准化；二是标准化后的结果在解读时会出现难以还原的问题，例如原本均值为180在标准化后可能就是0.31，而这个数据很难还原，只能进行相对其他维度的解读。</p></blockquote><p><strong>K-Means的计算步骤如下：</strong></p><ul><li>为每个聚类确定一个初始聚类中心，这样就有K个初始聚类中心。</li><li>将样本集中的样本按照最小距离原则分配到最邻近聚类。</li><li>使用每个聚类中的样本均值作为新的聚类中心。</li><li>重复步骤2.3直到聚类中心不再变化。</li><li>结束，得到K个聚类</li></ul><p>K-Means的计算既然作为一种经典算法，一定有很多 <strong>优势</strong>：</p><ul><li>它是解决聚类问题的一种经典算法，简单、快速而且可以用于多种数据类型。</li><li>对处理大数据集，该算法是相对可伸缩和高效率的。</li><li>因为它的复杂度是O(n k t ) , 其中, n 是所有对象的数目，k 是簇的数目，t 是迭代的次数。通常k &lt; &lt;n 且t &lt; &lt;n 。</li><li>算法尝试找出使平方误差函数值最小的k个划分。当结果簇是密集的，而簇与簇之间区别明显时, 它的效果较好。</li></ul><p>但是，传统K-Means也有很多 <strong>不足</strong>：</p><ul><li>既然基于均值计算，那么要求簇的平均值可以被定义和使用，此时字符串等非数值型数据则不适用。</li><li>K-Means的第一步是确定k（要生成的簇的数目），对于不同的初始值K，可能会导致不同结果。</li><li>应用数据集存在局限性，适用于球状或集中分布数据，不适用于特殊情况数据。如下面这种非球状的数据分布就无法正确分类。<br><img src="/2018/05/22/模式识别总结6-cluster、ensemble/pic1.png" alt=""></li><li>它对于“躁声”和孤立点数据是敏感的，少量的该类数据能够对平均值产生极大的影响。</li></ul><h4 id="模糊C均值聚类FCM"><a href="#模糊C均值聚类FCM" class="headerlink" title="模糊C均值聚类FCM"></a>模糊C均值聚类FCM</h4><p>FCM算法是基于对目标函数的优化基础上的一种数据聚类方法。聚类结果是每一个数据点对聚类中心的隶属程度，该隶属程度用一个数值来表示。FCM算法是一种无监督的模糊聚类方法，在算法实现过程中不需要人为的干预。这种算法的不足之处:首先，算法中需要设定一些参数，若参数的初始化选取的不合适，可能影响聚类结果的正确性;其次，当数据样本集合较大并且特征数目较多时，算法的实时性不太好。<br><strong>目标函数：</strong><br>$$J=\sum_{i=1}^C\sum_{k=1}^N(u_{i,k})^md_{i,k}^2\quad s.t.\sum_{i=1}^Cu_{i,k}=1$$<br><strong>聚类中心迭代公式：</strong><br>$$V_i=\frac{\sum_{k=1}^N(u_{i,k})^mx_k}{\sum_{k=1}^N(u_{i,k})^m}$$<br><strong>每个样本$k$属于类$i$的隶属度：</strong><br>$$u_{i,k}=\dfrac{1}{\sum_{j=1}^C(\dfrac{d_{k,i}}{d_{k,j}})^{\frac{2}{m-1}}}$$<br><strong>距离公式：</strong><br>$$d_{i,k}^2=||x_k-V_i||^2$$<br><strong>算法步骤：</strong></p><ul><li>初始化数据集</li><li>初始化隶属度数组</li><li>根据隶属度数组更新聚类中心</li><li>根据聚类中心更新隶属度数组</li><li>是否达到结束条件，没有达到则重复2-4步骤。</li></ul><h3 id="层次聚类"><a href="#层次聚类" class="headerlink" title="层次聚类"></a>层次聚类</h3><h4 id="Agglomerative-clustering"><a href="#Agglomerative-clustering" class="headerlink" title="Agglomerative clustering"></a>Agglomerative clustering</h4><p>是一种自底而上的层次聚类方法，它能够根据指定的相似度或距离定义计算出类之间的距离.<br><strong>Dendrogram：</strong> 依次将符合条件的类相连，最后得到使算法与数据均形象化的树状结构图。专门用来描述经层次聚类算法得到的结果。<br><img src="/2018/05/22/模式识别总结6-cluster、ensemble/pic2.png" alt=""><br><strong>Agglomerative Clustering Algorithm</strong></p><ul><li>1.将每一个元素单独定为一类</li><li>2.重复：每一轮都合并指定距离(对指定距离的理解很重要)最小的类</li><li>3.直到所有的元素都归为同一类</li></ul><p><strong>算法步骤：</strong></p><ul><li>将每个对象归为一类, 共得到N类, 每类仅包含一个对象. 类与类之间的距离就是它们所包含的对象之间的距离.</li><li>找到最接近的两个类并合并成一类, 于是总的类数少了一个.</li><li>重新计算新的类与所有旧类之间的距离.</li><li>重复第2步和第3步, 直到最后合并成一个类为止(此类包含了N个对象).</li></ul><p><strong>根据步骤三的不同，Agglomerative Clustering的三种不同方法</strong><br>依据对相似度(距离)的不同定义，将Agglomerative Clustering的聚类方法分为三种：</p><ul><li>Single-linkage:要比较的距离为元素对之间的最小距离(两个聚类的相似度取决于两个不同簇中最近的两个点)</li><li>Complete-linkage:要比较的距离为元素对之间的最大距离(组间距离等于两组对象之间的最大距离。)</li><li>Group average：要比较的距离为类之间的平均距离(平均距离的定义与计算：假设有A，B两个类，A中有n个元素，B中有m个元素。在A与B中各取一个元素，可得到他们之间的距离。将nm个这样的距离相加，得到距离和。最后距离和除以nm得到A，B两个类的平均距离。)</li></ul><h4 id="divisive"><a href="#divisive" class="headerlink" title="divisive"></a>divisive</h4><p>是一种自顶而下的层次聚类方法</p><h2 id="集成ensemble"><a href="#集成ensemble" class="headerlink" title="集成ensemble"></a>集成ensemble</h2><p>对于训练集数据，我们通过训练若干个个体学习器，通过一定的结合策略，就可以最终形成一个强学习器，以达到博采众长的目的。<br><img src="/2018/05/22/模式识别总结6-cluster、ensemble/pic3.png" alt=""><br>目前来说，<strong>同质个体学习器</strong> (个体学习器都是一个种类的，例如都是决策树的，或者都是神经网络的)的应用是最广泛的，一般我们常说的集成学习的方法都是指的同质个体学习器。而同质个体学习器使用最多的模型是CART决策树和神经网络。同质个体学习器按照个体学习器之间是否存在依赖关系可以分为两类，第一个是个体学习器之间存在 <strong>强依赖关系</strong>，一系列个体学习器基本都需要 <strong>串行生成</strong>，代表算法是 <strong>boosting系列算法</strong>，第二个是个体学习器之间不存在强依赖关系，一系列个体学习器可以 <strong>并行生成</strong>，代表算法是 <strong>bagging</strong> 和 <strong>随机森林(Random Forest)系列算法</strong>。</p><h3 id="boosting"><a href="#boosting" class="headerlink" title="boosting"></a>boosting</h3><p><img src="/2018/05/22/模式识别总结6-cluster、ensemble/pic4.png" alt=""><br>从图中可以看出，Boosting算法的工作机制是首先从训练集用初始权重训练出一个弱学习器1，根据弱学习的学习误差率表现来更新训练样本的权重，使得之前弱学习器1学习误差率高的训练样本点的权重变高，使得这些误差率高的点在后面的弱学习器2中得到更多的重视。然后基于调整权重后的训练集来训练弱学习器2.，如此重复进行，直到弱学习器数达到事先指定的数目T，最终将这T个弱学习器通过集合策略进行整合，得到最终的强学习器。　　</p><p>不过有几个具体的问题Boosting算法没有详细说明。<br>1) 如何计算学习误差率e?<br>2) 如何得到弱学习器权重系数α?<br>3) 如何更新样本权重D?<br>4) 使用何种结合策略？</p><h4 id="AdaBoost"><a href="#AdaBoost" class="headerlink" title="AdaBoost"></a>AdaBoost</h4><h5 id="分类问题算法"><a href="#分类问题算法" class="headerlink" title="分类问题算法"></a>分类问题算法</h5><p>输入为样本集$T={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}$，输出为{-1, +1}，弱分类器算法, 弱分类器迭代次数$K$。输出为最终的强分类器$f(x)$</p><p>初始化样本集权重为<br>$$D(1)=(w_{11},w_{12},…w_{1m});w_{1i}=\frac{1}{m};i=1,2…m$$<br>对于$k=1,2,…K$:</p><ul><li>使用具有权重$D_k$的样本集来训练数据，得到弱分类器$G_k(x)$</li><li>计算Gk(x)的分类误差率<br>$$e_k=P(G_k(x_i)≠y_i)=\sum_{i=1}^mw_{ki}I(G_k(x_i)≠y_i)$$</li><li>计算弱分类器的系数<br>$$α_k=\frac{1}{2}log\frac{1-e_k}{e_k}$$</li><li>更新样本集的权重分布<br>$$w_{k+1,i}=\frac{w_{ki}}{Z_K}exp(-α_ky_iG_k(x_i))\quad i=1,2,…m$$<br>这里$Z_k$是规范化因子<br>$$Z_k=\sum_{i=1}^mw_{ki}exp(-α_ky_iG_k(x_i))$$</li></ul><p>构建最终分类器为：<br>$$f(x)=sign(\sum_{k=1}^Kα_kG_k(x))$$<br>　　　　<br>对于Adaboost多元分类算法，其实原理和二元分类类似，最主要区别在弱分类器的系数上。比如Adaboost SAMME算法，它的弱分类器的系数<br>$$α_k=\frac{1}{2}log\frac{1-e_k}{e_k}+log(R-1)$$<br>其中R为类别数。从上式可以看出，如果是二元分类，R=2，则上式和我们的二元分类算法中的弱分类器的系数一致。</p><h5 id="回归问题算法"><a href="#回归问题算法" class="headerlink" title="回归问题算法"></a>回归问题算法</h5><p>输入为样本集$T={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}$，弱学习器算法, 弱学习器迭代次数$K$。输出为最终的强学习器$f(x)$<br>初始化样本集权重为<br>$$D(1)=(w_{11},w_{12},…w_{1m});w_{1i}=\frac{1}{m};i=1,2…m$$<br>对于$k=1,2,…K$:</p><ul><li>使用具有权重$D_k$的样本集来训练数据，得到弱学习器$G_k(x)$</li><li>计算训练集上的最大误差<br>$$E_k=max|y_i-G_k(x_i)|i=1,2…m$$</li><li>计算每个样本的相对误差:<ul><li>如果是线性误差，则$e_{ki}=\frac{|y_i-G_k(x_i)|}{E_k}$；</li><li>如果是平方误差，则$e_{ki}=\frac{(y_i-G_k(x_i))^2}{E^2_k}$</li><li>如果是指数误差，则$e_{ki}=1-exp(\frac{-y_i+G_k(x_i))}{E_k})$　　　　　　　　</li></ul></li><li>计算回归误差率<br>$$e_k=\sum_{i=1}^mw_{ki}e_{ki}$$</li><li>计算弱学习器的系数<br>$$α_k=\frac{e_k}{1-e_k}$$</li><li>更新样本集的权重分布为<br>$$w_{k+1,i}=\frac{w_{ki}}{Z_k}α<em>k^{1-e</em>{ki}}$$</li></ul><p>这里$Z_k$是规范化因子<br>$$Z_k=\sum_{i=1}^mw_{ki}α<em>k^{1-e</em>{ki}}$$</p><p>构建最终强学习器为：<br>$$f(x)=\sum_{k=1}^K(ln\frac{1}{αk})g(x)$$<br>其中，$g(x)$是所有$α_kG_k(x),k=1,2,….K$的中位数。　　　　</p><h5 id="Adaboost算法的正则化"><a href="#Adaboost算法的正则化" class="headerlink" title="Adaboost算法的正则化"></a>Adaboost算法的正则化</h5><p>为了防止Adaboost过拟合，我们通常也会加入正则化项，这个正则化项我们通常称为 <strong>步长(learning rate)</strong>。定义为$ν$,对于前面的弱学习器的迭代<br>$$f_k(x)=f_{k-1}(x)+α_kG_k(x)$$<br>如果我们加上了正则化项，则有<br>$$f_k(x)=f_{k-1}(x)+να_kG_k(x)$$<br>$ν$的取值范围为$0&lt;ν≤1$。对于同样的训练集学习效果，较小的$ν$意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。</p><h4 id="梯度提升树GBDT"><a href="#梯度提升树GBDT" class="headerlink" title="梯度提升树GBDT"></a>梯度提升树GBDT</h4><p>在GBDT的迭代中，假设我们前一轮迭代得到的强学习器是$f_{t-1}(x)$, 损失函数是$L(y,f_{t-1}(x))$, 我们本轮迭代的目标是找到一个CART回归树模型的弱学习器$h_t(x)$，让本轮的损失损失$L(y,f_t(x)=L(y,f_{t-1}(x)+h_t(x))$最小。也就是说，本轮迭代找到决策树，要让样本的损失尽量变得更小。</p><p>GBDT的思想可以用一个通俗的例子解释，假如有个人30岁，我们首先用20岁去拟合，发现损失有10岁，这时我们用6岁去拟合剩下的损失，发现差距还有4岁，第三轮我们用3岁拟合剩下的差距，差距就只有一岁了。如果我们的迭代轮数还没有完，可以继续迭代下面，每一轮迭代，拟合的岁数误差都会减小。</p><p>从上面的例子看这个思想还是蛮简单的，但是有个问题是这个损失的拟合不好度量，损失函数各种各样，怎么找到一种通用的拟合方法呢？</p><h5 id="GBDT的负梯度拟合"><a href="#GBDT的负梯度拟合" class="headerlink" title="GBDT的负梯度拟合"></a>GBDT的负梯度拟合</h5><p>在上一节中，我们介绍了GBDT的基本思路，但是没有解决损失函数拟合方法的问题。针对这个问题，大牛Freidman提出了用损失函数的负梯度来拟合本轮损失的近似值，进而拟合一个CART回归树。第$t$轮的第$i$个样本的损失函数的负梯度表示为<br>$$r_{ti}=-[\frac{∂L(y_i,f(x_i))}{∂f(x_i)}\rbrack_{f(x)}=f_{t-1}(x)$$</p><p>利用$(x_i,r_{ti})(i=1,2,..m)$,我们可以拟合一颗CART回归树，得到了第$t$颗回归树，其对应的叶节点区域$R_{tj},j=1,2,…,J$。其中$J$为叶子节点的个数。</p><p>针对每一个叶子节点里的样本，我们求出使损失函数最小，也就是拟合叶子节点最好的的输出值$c_{tj}$如下：</p><p>$$c_{tj}=\underbrace{arg\;min}<em>{c}\sum</em>{x_i\in R_{tj}}L(y_i,f_{t-1}(x_i)+c)$$</p><p>这样我们就得到了本轮的决策树拟合函数如下：<br>$$h_t(x) = \sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})$$</p><p>从而本轮最终得到的强学习器的表达式如下：<br>$$f_{t}(x) = f_{t-1}(x) + \sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})$$</p><p>通过损失函数的负梯度来拟合，我们找到了一种通用的拟合损失误差的办法，这样无轮是分类问题还是回归问题，我们通过其损失函数的负梯度的拟合，就可以用GBDT来解决我们的分类回归问题。区别仅仅在于损失函数不同导致的负梯度不同而已。</p><h5 id="GBDT回归算法"><a href="#GBDT回归算法" class="headerlink" title="GBDT回归算法"></a>GBDT回归算法</h5><p>好了，有了上面的思路，下面我们总结下GBDT的回归算法。为什么没有加上分类算法一起？那是因为分类算法的输出是不连续的类别值，需要一些处理才能使用负梯度。</p><p>输入是训练集样本$T={(x_1,y_1),(x_2,y_2),…(x_m,y_m)}$，最大迭代次数$T$, 损失函数$L$。输出是强学习器$f(x)$<br>初始化弱学习器<br>$$f_0(x) = \underbrace{arg\; min}<em>{c}\sum\limits</em>{i=1}^{m}L(y_i, c)$$</p><p>对迭代轮数$t=1,2,…T$有：</p><ul><li><p>对样本$i=1,2,…m$，计算负梯度<br>$$r_{ti} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg\rbrack_{f(x) = f_{t-1}\;\; (x)}$$</p></li><li><p>利用$(x_i,r_{ti})(i=1,2,..m)$, 拟合一颗CART回归树,得到第t颗回归树，其对应的叶子节点区域为$R_{tj},j=1,2,…,J$。其中J为回归树t的叶子节点的个数。</p></li><li><p>对叶子区域$j=1,2,..J$,计算最佳拟合值<br>$$c_{tj} = \underbrace{arg\; min}<em>{c}\sum\limits</em>{x_i \in R_{tj}} L(y_i,f_{t-1}(x_i) +c)$$</p></li><li><p>更新强学习器<br>$$f_{t}(x) = f_{t-1}(x) + \sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})$$<br>得到强学习器f(x)的表达式</p></li></ul><p>$$f(x) = f_T(x) =f_0(x) + \sum\limits_{t=1}^{T}\sum\limits_{j=1}^{J}c_{tj}I(x \in R_{tj})$$</p><h5 id="GBDT分类算法"><a href="#GBDT分类算法" class="headerlink" title="GBDT分类算法"></a>GBDT分类算法</h5><p>GBDT的分类算法从思想上和GBDT的回归算法没有区别，但是由于样本输出不是连续的值，而是离散的类别，导致我们无法直接从输出类别去拟合类别输出的误差。</p><p>为了解决这个问题，主要有两个方法，一个是用指数损失函数，此时GBDT退化为Adaboost算法。另一种方法是用类似于逻辑回归的对数似然损失函数的方法。也就是说，我们用的是类别的预测概率值和真实概率值的差来拟合损失。本文仅讨论用对数似然损失函数的GBDT分类。而对于对数似然损失函数，我们又有二元分类和多元分类的区别。</p><h6 id="二元GBDT分类算法"><a href="#二元GBDT分类算法" class="headerlink" title="二元GBDT分类算法"></a>二元GBDT分类算法</h6><p>对于二元GBDT，如果用类似于逻辑回归的对数似然损失函数，则损失函数为：<br>$$L(y, f(x)) = log(1+ exp(-yf(x)))$$<br>其中$y \in{-1, +1}$。则此时的负梯度误差为<br>$$r_{ti} = -\bigg[\frac{\partial L(y, f(x_i)))}{\partial f(x_i)}\bigg\rbrack_{f(x) = f_{t-1}\;\; (x)} = y_i/(1+exp(y_if(x_i)))$$</p><p>对于生成的决策树，我们各个叶子节点的最佳残差拟合值为</p><p>$$c_{tj}=\underbrace{arg\; min}<em>{c}\sum</em>{x_i\in R_{tj}}log(1+exp(-y_i(f_{t-1}(x_i)+c)))$$</p><p>由于上式比较难优化，我们一般使用近似值代替<br>$$c_{tj}=\dfrac{\sum_{x_i\in R_{tj}}r_{ti}}{\sum_{x_i\in R_{tj}}|r_{ti}|(1-|r_{ti}|)}$$</p><p>除了负梯度计算和叶子节点的最佳残差拟合的线性搜索，二元GBDT分类和GBDT回归算法过程相同。</p><h6 id="多元GBDT分类算法"><a href="#多元GBDT分类算法" class="headerlink" title="多元GBDT分类算法"></a>多元GBDT分类算法</h6><p>多元GBDT要比二元GBDT复杂一些，对应的是多元逻辑回归和二元逻辑回归的复杂度差别。假设类别数为$K$，则此时我们的对数似然损失函数为：<br>$$L(y, f(x)) = -  \sum\limits_{k=1}^{K}y_klog\;p_k(x)$$<br>其中如果样本输出类别为$k$，则$y_k=1$。第$k$类的概率$p_k(x)$的表达式为：<br>$$p_k(x) = exp(f_k(x)) \bigg / \sum\limits_{l=1}^{K} exp(f_l(x))$$<br>集合上两式，我们可以计算出第$t$轮的第$i$个样本对应类别$l$的负梯度误差为<br>$$r_{til} = -\bigg[\frac{\partial L(y_i, f(x_i)))}{\partial f(x_i)}\bigg]_{f_k(x) = f_{l, t-1}\;\; (x)} = y_{il} - p_{l, t-1}(x_i)$$<br>观察上式可以看出，其实这里的误差就是样本$i$对应类别$l$的真实概率和$t-1$轮预测概率的差值。<br>对于生成的决策树，我们各个叶子节点的最佳残差拟合值为<br>$$c_{tjl} = \underbrace{arg\; min}_{c_{jl}}\sum\limits_{i=0}^{m}\sum\limits_{k=1}^{K} L(y_k, f_{t-1, l}(x) + \sum\limits_{j=0}^{J}c_{jl} I(x_i \in R_{tj}))$$<br>由于上式比较难优化，我们一般使用近似值代替<br>$$c_{tjl} =  \frac{K-1}{K} \; \frac{\sum\limits_{x_i \in R_{tjl}}r_{til}}{\sum\limits_{x_i \in R_{til}}|r_{til}|(1-|r_{til}|)}$$<br>除了负梯度计算和叶子节点的最佳残差拟合的线性搜索，多元GBDT分类和二元GBDT分类以及GBDT回归算法过程相同。</p><h5 id="GBDT常用损失函数"><a href="#GBDT常用损失函数" class="headerlink" title="GBDT常用损失函数"></a>GBDT常用损失函数</h5><p>对常用的GBDT损失函数做一个总结。<br>对于分类算法，其损失函数一般有对数损失函数和指数损失函数两种:<br>1) 如果是指数损失函数，则损失函数表达式为<br>$$L(y, f(x)) = exp(-yf(x))$$<br>其负梯度计算和叶子节点的最佳残差拟合参见Adaboost原理。<br>2) 如果是对数损失函数，分为二元分类和多元分类两种。</p><p>对于回归算法，常用损失函数有如下4种:<br>1) 均方差，这个是最常见的回归损失函数了<br>$$L(y, f(x)) =(y-f(x))^2$$<br>2) 绝对损失，这个损失函数也很常见<br>$$L(y,f(x))=|y-f(x)|$$<br>对应负梯度误差为：<br>$$sign(y_i-f(x_i))$$<br>3) Huber损失，它是均方差和绝对损失的折衷产物，对于远离中心的异常点，采用绝对损失，而中心附近的点采用均方差。这个界限一般用分位数点度量。损失函数如下：<br>$$L(y, f(x))= \begin{cases} \frac{1}{2}(y-f(x))^2&amp; {|y-f(x)| \leq \delta}\ \delta(|y-f(x)| - \frac{\delta}{2})&amp; {|y-f(x)| &gt; \delta} \end{cases}$$　　　　<br>对应的负梯度误差为：<br>$$r(y_i, f(x_i))= \begin{cases} y_i-f(x_i)&amp; {|y_i-f(x_i)| \leq \delta}\ \delta sign(y_i-f(x_i))&amp; {|y_i-f(x_i)| &gt; \delta} \end{cases}$$<br>4) 分位数损失。它对应的是分位数回归的损失函数，表达式为<br>$$L(y, f(x)) =\sum\limits_{y \geq f(x)}\theta|y - f(x)| + \sum\limits_{y &lt; f(x)}(1-\theta)|y - f(x)|$$<br>其中$θ$为分位数，需要我们在回归前指定。对应的负梯度误差为：<br>$$r(y_i, f(x_i))= \begin{cases} \theta&amp; { y_i \geq f(x_i)}\ \theta - 1 &amp; {y_i &lt; f(x_i) } \end{cases}$$<br>对于Huber损失和分位数损失，主要用于健壮回归，也就是减少异常点对损失函数的影响。</p><h5 id="GBDT的正则化"><a href="#GBDT的正则化" class="headerlink" title="GBDT的正则化"></a>GBDT的正则化</h5><p>和Adaboost一样，我们也需要对GBDT进行正则化，防止过拟合。GBDT的正则化主要有三种方式。<br>第一种是和Adaboost类似的正则化项，即步长(learning rate)。定义为ν,对于前面的弱学习器的迭代<br>$$f_k(x)=f_{k-1}(x)+h_k(x)$$<br>如果我们加上了正则化项，则有<br>$$f_k(x)=f_{k-1}(x)+νh_k(x)$$<br>ν的取值范围为$0&lt;ν≤1$。对于同样的训练集学习效果，较小的$ν$意味着我们需要更多的弱学习器的迭代次数。通常我们用步长和迭代最大次数一起来决定算法的拟合效果。</p><p>第二种正则化的方式是通过子采样比例(subsample)。取值为(0,1]。注意这里的子采样和随机森林不一样，随机森林使用的是放回抽样，而这里是不放回抽样。如果取值为1，则全部样本都使用，等于没有使用子采样。如果取值小于1，则只有一部分样本会去做GBDT的决策树拟合。选择小于1的比例可以减少方差，即防止过拟合，但是会增加样本拟合的偏差，因此取值不能太低。推荐在[0.5, 0.8]之间。</p><p>使用了子采样的GBDT有时也称作随机梯度提升树(Stochastic Gradient Boosting Tree, SGBT)。由于使用了子采样，程序可以通过采样分发到不同的任务去做boosting的迭代过程，最后形成新树，从而减少弱学习器难以并行学习的弱点。</p><p>第三种是对于弱学习器即CART回归树进行正则化剪枝。</p><h3 id="bagging"><a href="#bagging" class="headerlink" title="bagging"></a>bagging</h3><p><img src="/2018/05/22/模式识别总结6-cluster、ensemble/pic5.png" alt=""><br>其特点即为：<strong>随机采样</strong><br>随机采样(bootstrap)就是从我们的训练集里面采集固定个数的样本，但是每采集一个样本后，都将样本放回。也就是说，之前采集到的样本在放回后有可能继续被采集到。对于我们的Bagging算法，一般会随机采集和训练集样本数$m$一样个数的样本。这样得到的采样集和训练集样本的个数相同，但是样本内容不同。如果我们对有$m$个样本训练集做$T$次的随机采样，，则由于随机性，$T$个采样集各不相同。</p><p>对于一个样本，它在某一次含$m$个样本的训练集的随机采样中，每次被采集到的概率是$\dfrac{1}{m}$，不被采集到的概率为$1-\dfrac{1}{m}$。如果$m$次采样都没有被采集中的概率是$(1-\dfrac{1}{m})^m$。当m→∞时，$(1-\dfrac{1}{m})^m$→$\dfrac{1}{e}≃0.368$。也就是说，在bagging的每轮随机采样中，训练集中大约有36.8%的数据没有被采样集采集中，这部分数据称之为 <strong>袋外数据OOB</strong>。这些数据没有参与训练集模型的拟合，因此可以用来检测模型的泛化能力。</p><p>bagging对于弱学习器没有限制，这和Adaboost一样。但是最常用的一般也是 <strong>决策树和神经网络。</strong></p><p>bagging的集合策略也比较简单，对于分类问题，通常使用 <strong>简单投票法</strong>，得到最多票数的类别或者类别之一为最终的模型输出。对于回归问题，通常使用 <strong>简单平均法</strong>，对T个弱学习器得到的回归结果进行算术平均得到最终的模型输出。</p><p>由于Bagging算法每次都进行采样来训练模型，因此泛化能力很强，对于降低模型的方差很有作用。当然对于训练集的拟合程度就会差一些，也就是模型的偏倚会大一些。</p><p><strong>装袋法的算法步骤：</strong></p><ul><li>从原始样本集中抽取训练集.每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）.共进行k轮抽取，得到k个训练集.（k个训练集相互独立）</li><li>每次使用一个训练集得到一个模型，k个训练集共得到k个模型.（注：根据具体问题采用不同的分类或回归方法，如决策树、神经网络等）</li><li>对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果.</li></ul><h3 id="随机森林Random-Forest-RF"><a href="#随机森林Random-Forest-RF" class="headerlink" title="随机森林Random Forest,RF"></a>随机森林Random Forest,RF</h3><p><strong>与bagging的不同之处：</strong></p><ul><li>首先，RF使用了CART决策树作为弱学习器，这让我们想到了梯度提示树GBDT。</li><li>第二，在使用决策树的基础上，RF对决策树的建立做了改进，对于普通的决策树，我们会在节点上所有的n个样本特征中选择一个最优的特征来做决策树的左右子树划分，但是RF通过随机选择节点上的一部分样本特征，这个数字小于$n$，假设为$n_{sub}$，然后在这些随机选择的$n_{sub}$个样本特征中，选择一个最优的特征来做决策树的左右子树划分。这样进一步增强了模型的泛化能力。　　　　</li></ul><p>如果$n_{sub}=n$，则此时RF的CART决策树和普通的CART决策树没有区别。$n_{sub}$越小，则模型约健壮，当然此时对于训练集的拟合程度会变差。也就是说$n_{sub}$越小，模型的方差会减小，但是偏倚会增大。在实际案例中，一般会通过交叉验证调参获取一个合适的$n_{sub}$的值。</p><h4 id="extra-trees"><a href="#extra-trees" class="headerlink" title="extra trees"></a>extra trees</h4><p>extra trees是RF的一个变种, 原理几乎和RF一模一样，仅有区别有：</p><ul><li>对于每个决策树的训练集，RF采用的是随机采样bootstrap来选择采样集作为每个决策树的训练集，而extra trees一般不采用随机采样，即每个决策树采用原始训练集。</li><li>在选定了划分特征后，RF的决策树会基于信息增益，基尼系数，均方差之类的原则，选择一个最优的特征值划分点，这和传统的决策树相同。但是extra trees比较的激进，他会随机的选择一个特征值来划分决策树。</li></ul><p>从第二点可以看出，由于随机选择了特征值的划分点位，而不是最优点位，这样会导致生成的决策树的规模一般会大于RF所生成的决策树。也就是说，模型的方差相对于RF进一步减少，但是偏倚相对于RF进一步增大。在某些时候，extra trees的泛化能力比RF更好。</p><h4 id="Totally-Random-Trees-Embedding"><a href="#Totally-Random-Trees-Embedding" class="headerlink" title="Totally Random Trees Embedding"></a>Totally Random Trees Embedding</h4><p>Totally Random Trees Embedding(以下简称 TRTE)是一种非监督学习的数据转化方法。它将低维的数据集映射到高维，从而让映射到高维的数据更好的运用于分类回归模型。我们知道，在支持向量机中运用了核方法来将低维的数据集映射到高维，此处TRTE提供了另外一种方法。</p><p>TRTE在数据转化的过程也使用了类似于RF的方法，建立T个决策树来拟合数据。当决策树建立完毕以后，数据集里的每个数据在T个决策树中叶子节点的位置也定下来了。比如我们有3颗决策树，每个决策树有5个叶子节点，某个数据特征x划分到第一个决策树的第2个叶子节点，第二个决策树的第3个叶子节点，第三个决策树的第5个叶子节点。则x映射后的特征编码为$(0,1,0,0,0,\quad0,0,1,0,0,\quad0,0,0,0,1)$, 有15维的高维特征。这里特征维度之间加上空格是为了强调三颗决策树各自的子编码。</p><p>映射到高维特征后，可以继续使用监督学习的各种分类回归算法了。</p><h4 id="Isolation-Forest"><a href="#Isolation-Forest" class="headerlink" title="Isolation Forest"></a>Isolation Forest</h4><p>Isolation Forest(以下简称IForest)是一种异常点检测的方法。它也使用了类似于RF的方法来检测异常点。</p><p>对于在T个决策树的样本集，IForest也会对训练集进行随机采样,但是采样个数不需要和RF一样，<strong>对于RF，需要采样到采样集样本个数等于训练集个数</strong>。但是IForest不需要采样这么多，一般来说，采样个数要远远小于训练集个数？为什么呢？因为我们的目的是异常点检测，只需要部分的样本我们一般就可以将异常点区别出来了。</p><p>对于每一个决策树的建立， IForest采用随机选择一个划分特征，对划分特征随机选择一个划分阈值。这点也和RF不同。</p><p>另外，IForest一般会选择一个比较小的最大决策树深度max_depth,原因同样本采集，用少量的异常点检测一般不需要这么大规模的决策树。</p><p>对于异常点的判断，则是将测试样本点$x$拟合到$T$颗决策树。计算在每颗决策树上该样本的叶子节点的深度$h_t(x)$。，从而可以计算出平均高度$h(x)$。此时我们用下面的公式计算样本点$x$的异常概率:<br>$$s(x,m)=2^{-\frac{h(x)}{c(m)}}$$<br>其中，$m$为样本个数。$c(m)$的表达式为：<br>$$c(m)=2ln(m-1)+ξ-2\frac{m-1}{m}$$<br>$ξ$为欧拉常数<br>$s(x,m)$的取值范围是[0,1],取值越接近于1，则是异常点的概率也越大。</p><h3 id="结合策略"><a href="#结合策略" class="headerlink" title="结合策略"></a>结合策略</h3><p>假定我得到的$T$个弱学习器是${h_1,h_2,…h_T}$</p><h4 id="平均法"><a href="#平均法" class="headerlink" title="平均法"></a>平均法</h4><p>对于数值类的回归预测问题，通常使用的结合策略是平均法，也就是说，对于若干个弱学习器的输出进行平均得到最终的预测输出。</p><ul><li>最简单的平均是算术平均，也就是说最终预测是<br>$$H(x)=\dfrac{1}{T}\sum_1^Th_i(x)$$</li><li>如果每个个体学习器有一个权重$w$，则最终预测是<br>$$H(x)=\sum_{i=1}^Tw_ih_i(x)$$</li><li>其中$w_i$是个体学习器$h_i$的权重，通常有<br>$$w_i≥0,\sum_{i=1}^Tw_i=1$$</li></ul><h4 id="投票法"><a href="#投票法" class="headerlink" title="投票法"></a>投票法</h4><p>对于分类问题的预测，我们通常使用的是投票法。假设我们的预测类别是${c_1,c_2,…c_K}$,对于任意一个预测样本$x$，我们的$T$个弱学习器的预测结果分别是$(h_1(x),h_2(x)…h_T(x))$。</p><ul><li>最简单的投票法是 <strong>相对多数投票法</strong>，也就是我们常说的少数服从多数，也就是$T$个弱学习器的对样本$x$的预测结果中，数量最多的类别$c_i$为最终的分类类别。如果不止一个类别获得最高票，则随机选择一个做最终类别。</li><li>稍微复杂的投票法是 <strong>绝对多数投票法</strong>，也就是我们常说的要票过半数。在相对多数投票法的基础上，不光要求获得最高票，还要求票过半数。否则会拒绝预测。</li><li>更加复杂的是 <strong>加权投票法</strong>，和加权平均法一样，每个弱学习器的分类票数要乘以一个权重，最终将各个类别的加权票数求和，最大的值对应的类别为最终类别。</li></ul><h4 id="学习法"><a href="#学习法" class="headerlink" title="学习法"></a>学习法</h4><p>上两节的方法都是对弱学习器的结果做平均或者投票，相对比较简单，但是可能学习误差较大，于是就有了 <strong>学习法</strong> 这种方法，对于学习法，代表方法是 <strong>stacking</strong>，当使用stacking的结合策略时， 我们不是对弱学习器的结果做简单的逻辑处理，而是再加上一层学习器，也就是说，我们将训练集弱学习器的学习结果作为输入，将训练集的输出作为输出，重新训练一个学习器来得到最终结果。<br>在这种情况下，我们将弱学习器称为 <strong>初级学习器</strong>，将用于结合的学习器称为 <strong>次级学习器</strong>。对于测试集，我们首先用初级学习器预测一次，得到次级学习器的输入样本，再用次级学习器预测一次，得到最终的预测结果。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;code&gt;前言&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; 聚类分析的基本思想是 “物以类聚、人以群分”，因此大量的数据集中必然存在相似的数据点，基于这个假设就可以将数据区分出来，并发现每个数据集(分类)的特征。&lt;br&gt;ensemble集成学习，训练若干个个体学习器，通过一定的结合策略，就可以最终形成一个强学习器，以达到博采众长的目的。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="模式识别" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>模式识别总结4_SVM</title>
    <link href="http://yoursite.com/2018/05/18/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB%E6%80%BB%E7%BB%934-SVM/"/>
    <id>http://yoursite.com/2018/05/18/模式识别总结4-SVM/</id>
    <published>2018-05-18T05:23:55.000Z</published>
    <updated>2018-09-22T07:36:53.547Z</updated>
    
    <content type="html"><![CDATA[<h2 id="了解SVM"><a href="#了解SVM" class="headerlink" title="了解SVM"></a>了解SVM</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>支持向量机(SVM)是90年代中期发展起来的基于统计学习理论的一种机器学习方法，通过寻求结构化风险最小来提高学习机泛化能力，实现经验风险和置信范围的最小化，从而达到在统计样本量较少的情况下，亦能获得良好统计规律的目的。<br>通俗来讲，它是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，即支持向量机的学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p><h3 id="线性分类"><a href="#线性分类" class="headerlink" title="线性分类"></a>线性分类</h3><p>一个线性分类器的学习目标便是要在$n$维的数据空间中找到一个 <strong>超平面hyper plane</strong> ，可以表示为$w^Tx+b=0$<br><strong>Logistic回归</strong> 目的是从特征学习出一个0/1分类模型，而这个模型是将特征的线性组合作为自变量，由于自变量的取值范围是负无穷到正无穷，因此使用Logistic(或者称作sigmoid)将自变量映射到(0,1)上，映射后的值被认为是$y=1$的概率。<br>$h_{\theta}=g(\theta^Tx)=\dfrac{1}{1+e^{-\theta^Tx}}=P(y=1|x;\theta)$<br><img src="/2018/05/18/模式识别总结4-SVM/pic1.png" alt=""><br>故：当$P(y=1|x;\theta)=h_{\theta}&gt;0.5$，则为$y=1$的类，反之属于$y=0$类<br>由$h_{\theta}&gt;0.5$得$\theta^Tx&gt;0$，即有<br>$$g(z)=\begin{cases}<br>1 &amp; z&gt;=0 \<br>-1 &amp; z<0 \end{cases}$$="" 而当$\theta^tx="">&gt;0$时，$h_{\theta}=1$，反之$h_{\theta}=0(-1)$。因此模型的训练目标即为让训练数据中$y=1$的特征$\theta^Tx&gt;&gt;0$，而$y=0$的特征$\theta^Tx&lt;&lt;0$</0></p><h3 id="函数间隔与几何间隔"><a href="#函数间隔与几何间隔" class="headerlink" title="函数间隔与几何间隔"></a>函数间隔与几何间隔</h3><p>在超平面$w^Tx+b=0$确定的情况下，$|w^T+b|$能够表示点$x$到距离超平面的远近，而通过观察$w^Tx+b$的符号与类标记$y$的符号是否一致可判断分类是否正确，故可用$y(w^Tx+b)$的正负值判定。由此引出<strong>functional margin</strong><br>$\widehat{\gamma}=y(w^Tx+b)=yf(x)$<br>超平面$(w,b)$关于训练数据集$T$的函数间隔：$\widehat{\gamma}=min\widehat{\gamma}_i\quad(i=1…n)$<br>但是函数间隔有限制，若成比例地改变$w,b$，那么函数间隔也会成比例地改变，但是超平面却没有改变。<br>故引出<strong>Geometrical margin</strong><br>$\widetilde{\gamma}=\dfrac{yf(x)}{||w||}=\dfrac{\widehat{\gamma}}{||w||}$<br><img src="/2018/05/18/模式识别总结4-SVM/pic2.png" alt=""></p><h3 id="最大间隔分类器"><a href="#最大间隔分类器" class="headerlink" title="最大间隔分类器"></a>最大间隔分类器</h3><p>对一个数据点进行分类，当超平面离数据点的“间隔”越大，分类的 <strong>确信度confidence</strong> 也越大。<br><img src="/2018/05/18/模式识别总结4-SVM/pic3.png" alt=""><br>由函数间隔和几何间隔的定义，可得：<br>$$\begin{cases}<br>y_i(w^Tx_i+b)=\widehat{\gamma}_i&gt;=\widehat{\gamma} &amp; i=1…n \<br>\widetilde{\gamma}=\dfrac{\widehat{\gamma}}{||w||} &amp; make\quad\widehat{\gamma}=1<br>\end{cases}$$<br>因此可得目标函数：<br>$$max\widetilde{\gamma}=max\dfrac{1}{||w||},\quad s.t.,y_i(w^T+x_i)&gt;=1,i=1…n$$<br><img src="/2018/05/18/模式识别总结4-SVM/pic4.png" alt=""><br>如图，中间的实线即为 <strong>最优超平面Optimal Hyper Plane</strong>，虚线上的点即为支持向量，满足$y(w^Tx+b)=1$</p><h2 id="深入SVM"><a href="#深入SVM" class="headerlink" title="深入SVM"></a>深入SVM</h2><h3 id="从原始问题到对偶问题的求解"><a href="#从原始问题到对偶问题的求解" class="headerlink" title="从原始问题到对偶问题的求解"></a>从原始问题到对偶问题的求解</h3><p>将目标函数变换，得到新的目标函数：<br>$$min\dfrac{||w||^2}{2},\quad s.t.,y_i(w^T+x_i)&gt;=1,i=1…n$$<br>此时的目标函数是二次的，约束条件是线性的，因此它是一个凸二次规划问题。<strong>目标最优，损失最小。</strong><br>由 <strong>拉格朗日对偶性</strong> 得到线性可分条件下支持向量机的对偶算法：<br><strong>第一步：定义拉格朗日函数</strong><br>$$\zeta(w,b,\alpha)=\dfrac{||w||^2}{2}-\sum_{i=1}^n\alpha_i(y_i(w^Tx_i+b)-1)$$<br>当所有的约束条件都满足时，存在：<br>$$\theta(w)=\underset{\alpha_i&gt;=0}{max}\zeta(w,b,\alpha)=\dfrac{||w||^2}{2}$$<br>因此，目标函数可变成：<br>$$\underset{w,b}{min}\dfrac{||w||^2}{2}=\underset{w,b}{min}\theta(w)=\underset{w,b}{min}\underset{\alpha_i&gt;=0}{max}\zeta(w,b,\alpha)=p^* $$</p><p><strong>第二步：对偶问题</strong><br>$$\underset{\alpha_i&gt;=0}{max}\underset{w,b}{min}\zeta(w,b,\alpha)=d^* $$</p><p><strong>转换成对偶问题的优点：</strong></p><ul><li>容易求解</li><li>自然地引入核函数，进而推广到非线性分类问题</li></ul><h3 id="KKT条件"><a href="#KKT条件" class="headerlink" title="KKT条件"></a>KKT条件</h3><p>一般地，一个最优化数学模型能够表示成下列标准形式:<br><img src="/2018/05/18/模式识别总结4-SVM/pic5.png" alt=""><br>其中，$f(x)$是需要最小化的函数，$h(x)$是等式约束，$g(x)$是不等式约束，$p$和$q$分别为等式约束和不等式约束的数量。<br>同时，得明白以下两点：</p><ul><li>凸优化的概念：$\mathcal{X} \subset \mathbb{R}^n$ 为一凸集， $f:\mathcal{X}\to \mathbb{R}$ 为一凸函数。凸优化就是要找出一点 $x^\ast \in \mathcal{X}$ ，使得每一 $x \in \mathcal{X}$ 满足 $f(x^\ast)\le f(x)$ 。</li><li>KKT条件的意义：它是一个非线性规划(Nonlinear Programming)问题能有最优化解法的必要和充分条件。</li></ul><p>而KKT条件就是指上面最优化数学模型的标准形式中的最小点 $x^\ast $ 必须满足下面的条件：<br><img src="/2018/05/18/模式识别总结4-SVM/pic6.png" alt=""><br>而SVM的目标函数的约束条件是满足KKT条件的，因此可以等价转换成对偶问题进行优化求解。</p><h3 id="对偶问题求解的三个步骤"><a href="#对偶问题求解的三个步骤" class="headerlink" title="对偶问题求解的三个步骤"></a>对偶问题求解的三个步骤</h3><p><strong>第一步：对$w,b$求偏导，得到$\underset{w,b}{min}\zeta(w,b,\alpha)$</strong><br><img src="/2018/05/18/模式识别总结4-SVM/pic7.png" alt=""><br><img src="/2018/05/18/模式识别总结4-SVM/pic8.png" alt=""><br>此时得到的式子中只有$\alpha$变量，故只要求出$\alpha$,就可以求出$w,b$</p><p><strong>第二步：求对$\alpha$ 的极大</strong><br><img src="/2018/05/18/模式识别总结4-SVM/pic9.png" alt=""><br>若求出了$\alpha$，根据$w=\sum_{i=1}^n\alpha_iy_ix_i$可以求出$w$；根据$b^\ast=-\dfrac{max_{i;y^{(i)}=-1}w^Tx^{(i)}+min_{i;y^{(i)}=1}w^Tx^{(i)}}{2}$可以得到$b$，最终可以得到分离超平面和分类决策函数。</p><p><strong>第三步：利用SMO算法求解对偶问题中的拉格朗日乘子$\alpha$</strong><br>将求极大公式转换成：<br><img src="/2018/05/18/模式识别总结4-SVM/pic10.png" alt=""><br><strong>思路：</strong><br>在要求的目标函数中，未知量只有$\alpha$，即在$\alpha_i={\alpha_1,…\alpha_n}$上求目标函数的最小值。为了求解这些乘子，每次从中任意抽取两个乘子$\alpha_1,\alpha_2$，然后固定其他乘子${\alpha_3,…\alpha_n}$，使得目标函数只有关于$\alpha_1,\alpha_2$的函数。这样不断地从一堆乘子中任意抽取两个求解，不断地迭代求解子问题，最终达到求解原问题的目的。<br><strong>选取乘子的条件：</strong><br><img src="/2018/05/18/模式识别总结4-SVM/pic11.png" alt=""></p><ul><li>情况一：表明$\alpha_i$是正常分类，在边界内部</li><li>情况二：表明$\alpha_i$是支持向量，在边界上</li><li>情况三：表明$\alpha_i$是在两条边界之间</li></ul><p>而不满足KKT条件，需要更新的乘子满足：</p><ul><li>情况一：$y_iu_i&lt;=1\quad but\quad\alpha_i&lt;C$</li><li>情况二：$y_iu_i&gt;=1\quad but\quad\alpha_i&gt;C$</li><li>情况三：$y_iu_i=1\quad but\quad\alpha_i=C\quad or\quad\alpha_i=0$</li></ul><p><strong>优化$\alpha$乘子的原理解析：</strong><br>由$\sum_{i=1}^ny_i\alpha_i=0$可得约束条件：<br>$$\alpha_1^{new}y_1+\alpha_2^{new}y_2=\alpha_1^{old}y_1+\alpha_2^{old}y_2=-\sum_{i=3}^ny_i\alpha_i=\zeta$$<br>再综合$0&lt;=\alpha_i&lt;=C$，可得优化的$\alpha$的取值范围：<br><img src="/2018/05/18/模式识别总结4-SVM/pic12.png" alt=""><br><img src="/2018/05/18/模式识别总结4-SVM/pic13.png" alt=""></p><p>由于选取两个乘子，其他固定，故可得目标函数为：<br>$$\underset{\alpha_1,\alpha_2}{min}W(\alpha_1,\alpha_2)=m\alpha_1^2+n\alpha_2^2+k\alpha_1\alpha_2+q\alpha_1+p\alpha_2$$<br>代入转换求导，然后在范围内截断取值更新$\alpha$值<br><img src="/2018/05/18/模式识别总结4-SVM/pic15.png" alt=""><br><img src="/2018/05/18/模式识别总结4-SVM/pic14.png" alt=""></p><h3 id="核函数"><a href="#核函数" class="headerlink" title="核函数"></a>核函数</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;了解SVM&quot;&gt;&lt;a href=&quot;#了解SVM&quot; class=&quot;headerlink&quot; title=&quot;了解SVM&quot;&gt;&lt;/a&gt;了解SVM&lt;/h2&gt;&lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="模式识别" scheme="http://yoursite.com/tags/%E6%A8%A1%E5%BC%8F%E8%AF%86%E5%88%AB/"/>
    
  </entry>
  
  <entry>
    <title>企业软件开发_EJB3.0、性能调优、web服务器</title>
    <link href="http://yoursite.com/2018/05/15/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-EJB3-0%E3%80%81%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98%E3%80%81web%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://yoursite.com/2018/05/15/企业软件开发-EJB3-0、性能调优、web服务器/</id>
    <published>2018-05-15T11:35:05.000Z</published>
    <updated>2018-09-22T07:36:53.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="企业软件系统概述"><a href="#企业软件系统概述" class="headerlink" title="企业软件系统概述"></a>企业软件系统概述</h2><p>计算程序的基本组成:</p><ul><li>表示层</li><li>业务逻辑层</li><li>数据访问层</li></ul><p>大型互联网应用系统具有的特点：</p><ul><li>高并发、大流量</li><li>高可用</li><li>海量数量</li><li>用户分布广泛、网络情况复杂</li><li>安全环境恶劣</li><li>需求快速变更，发布频繁</li></ul><p>网站访问的二八定律：</p><ul><li>80%的访问集中在20%的数据上</li><li>20%数据集中在内存缓存</li></ul><h2 id="web服务器"><a href="#web服务器" class="headerlink" title="web服务器"></a>web服务器</h2><ul><li>Microsoft IIS:仅支持window,用于.net</li><li>Tomcat<ul><li>轻量级</li><li>开源</li><li>被使用最广泛</li><li>主流jsp/servlet容器，但需要配合weblogic、Jboss等容器使用EJB</li></ul></li><li>Apache<ul><li>使用排名第一</li><li>以进程为基础的结构</li><li>与Tomcat的区别<ul><li>Apache支持静态页，Tomcat支持动态的</li><li>Apache是一个web服务器环境程序，可作为web服务器使用，tomcat 是应用(java)服务器，是Apache的扩展，又独立于Apache</li><li>Apache侧重http server，Tomcat侧重servlet引擎</li></ul></li></ul></li><li>Lighttpd<ul><li>德国的</li><li>OpenSource轻量级</li><li>单线程，针对大量持续连接</li></ul></li><li>Nginx<ul><li>俄罗斯的</li><li>以事件驱动方式编写的</li><li>反向代理、负载平web服务器、http反向代理和邮件代理服务器</li><li>全球使用量第三</li><li>特点：<ul><li>高并发连接</li><li>内存消耗少</li><li>配置文件非常简单</li><li>成本低廉</li></ul></li></ul></li><li>Tengine</li></ul><h2 id="Websphere-MQ"><a href="#Websphere-MQ" class="headerlink" title="Websphere MQ"></a>Websphere MQ</h2><p>WebSphere MQ 为用户和应用开发人员提供了一种直接，简单，成熟的手段以实现应用系统在不同操作系统平台之间稳定可靠地传递，交换重要的数据和信息，确保消息不丢失/不复传。</p><p>MQ的传输协议是TCP，以安全性为主，支持文件，不支持文件目录的传输。<br>MQ的连接机制是通道、队列，传输方式是消息(消息描述符+用户数据)</p><p>消息分为</p><ul><li>请求消息</li><li>回复消息</li><li>报文消息</li><li>报告消息</li></ul><p>死信队列是存储无法发送到其正确目的地的消息的队列。</p><p>WebSphere MQ是唯一可保证信息一次性传输的中间件,确保对消息一次仅且一次(once-and-only-once)的传递，做到不丢失、不重传、次序不乱。</p><p>触发应用程序是指MQ能够在触发条件满足时，唤醒应用程序的执行，即应用程序不必总是在运行中的。<br>触发的对象：</p><ul><li>应用程序</li><li>通道</li></ul><h2 id="EJB3-0"><a href="#EJB3-0" class="headerlink" title="EJB3.0"></a>EJB3.0</h2><p>相比EJB2.0：</p><ul><li>使用java元数据注释</li><li>简化访问EJB环境的API</li><li>不需要home接口、对象接口以及组件接口</li><li>提供另外两种获取资源的方式<ul><li>在EJB2.0:通过InitialContext的lookup方法来获取资源;</li><li>在EJB3.0:通过EJBContext的lookup方法;</li><li>通过依赖注入方式;</li></ul></li><li>消除了持久实体需要的所有接口</li></ul><h2 id="EJB性能优化"><a href="#EJB性能优化" class="headerlink" title="EJB性能优化"></a>EJB性能优化</h2><h3 id="无状态会话bean调优"><a href="#无状态会话bean调优" class="headerlink" title="无状态会话bean调优"></a>无状态会话bean调优</h3><ul><li>调整实例池大小</li><li>设置实例池空闲延时</li><li>有效缓存资源</li></ul><h3 id="有状态会话bean调优"><a href="#有状态会话bean调优" class="headerlink" title="有状态会话bean调优"></a>有状态会话bean调优</h3><ul><li>调整缓存大小</li><li>有效控制序列化</li></ul><h3 id="实体bean调优"><a href="#实体bean调优" class="headerlink" title="实体bean调优"></a>实体bean调优</h3><ul><li>使用CMP 2.x或JPA。</li><li>提供本地接口；</li><li>对实例池大小进行调整；</li><li>调整缓存大小；</li><li>选择合适的事务语义和事务隔离级别；</li><li>在获得大量数据时，建议使用JDBC；</li><li>在BMP中优化JDBC操作；</li><li>选择合适的RDBMS驱动；</li><li>批量更新或获取。</li></ul><h3 id="MDB调优"><a href="#MDB调优" class="headerlink" title="MDB调优"></a>MDB调优</h3><ul><li>调整实例池大小</li><li>JMS相关调整</li></ul><h3 id="web服务器调优"><a href="#web服务器调优" class="headerlink" title="web服务器调优"></a>web服务器调优</h3><ul><li>如果Web应用是无状态的，则关闭HTTP会话支持这一特性。&lt;%page session=“false”%&gt;</li><li>不要在session中存储大量的对象，及时释放会话。</li><li>针对不同HTTP keek-alive设置，设置相应的优化值。</li><li>将JSP重新编译选项关闭；</li><li>使用Web服务提供的JSP、Servlet缓存技术；</li><li>不要使用Servlet规范已经丢弃的单线程模型。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;企业软件系统概述&quot;&gt;&lt;a href=&quot;#企业软件系统概述&quot; class=&quot;headerlink&quot; title=&quot;企业软件系统概述&quot;&gt;&lt;/a&gt;企业软件系统概述&lt;/h2&gt;&lt;p&gt;计算程序的基本组成:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示层&lt;/li&gt;
&lt;li&gt;业务逻辑层&lt;/li
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="企业软件开发" scheme="http://yoursite.com/tags/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>企业软件开发_J2EE</title>
    <link href="http://yoursite.com/2018/05/14/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-J2EE/"/>
    <id>http://yoursite.com/2018/05/14/企业软件开发-J2EE/</id>
    <published>2018-05-14T08:49:01.000Z</published>
    <updated>2018-09-22T07:36:53.301Z</updated>
    
    <content type="html"><![CDATA[<h2 id="J2EE"><a href="#J2EE" class="headerlink" title="J2EE"></a>J2EE</h2><ul><li>J2ME:嵌入式设备及消费类电器</li><li>J2SE:普通PC应用</li><li>J2EE：企业网应用<ul><li>平台无关性</li><li>支持异构环境</li><li>可伸缩性强</li><li>保留现有系统</li><li>稳定的可用性</li><li>高效开发：开发人员只需集中精力处理商业逻辑</li><li>多层架构体系</li></ul></li></ul><h2 id="J2EE规范概述"><a href="#J2EE规范概述" class="headerlink" title="J2EE规范概述"></a>J2EE规范概述</h2><ul><li>Sun公司为企业计算推出的企业级Java平台，工业标准、开放路线</li><li>用于开发、部署和管理N层结构、面向Web的，以服务器为中心的企业级应用</li><li>简化企业解决方案的开发、部署和管理相关的复杂问题</li><li>以核心Java平台和Java 2平台的标准版为技术基础</li><li>J2EE应用编程模型：商业逻辑、表示逻辑</li><li>J2EE平台本质上是一个分布式的服务器应用程序设计环境<ul><li>为应用提供运行时的基础框架环境</li><li>一套用来创建应用的Java扩展编程接口API</li></ul></li></ul><h2 id="J2EE体系结构"><a href="#J2EE体系结构" class="headerlink" title="J2EE体系结构"></a>J2EE体系结构</h2><p>J2EE使用多层的分布式应用模型，应用逻辑按功能划分为组件，各个应用组件根据他们所在的层分布在不同的机器上。事实上，sun设计J2EE的初衷正是为了解决两层模式(client/server)的弊端，在传统模式中，客户端担当了过多的角色而显得臃肿，在这种模式中，第一次部署的时候比较容易，但难于升级或改进，可伸展性也不理想，而且经常基于某种专有的协议，通常是某种数据库协议。它使得重用业务逻辑和界面逻辑非常困难。现在J2EE的多层企业级应用模型将两层化模型中的不同层面切分成许多层。一个多层化应用能够为不同的每种服务提供一个独立的层，以下是J2EE典型的四层结构:</p><ul><li>运行在客户端机器上的客户层组件</li><li>运行在J2EE服务器上的Web层组件</li><li>运行在J2EE服务器上的业务逻辑层组件</li><li>运行在EIS服务器上的企业信息系统(Enterprise information system)层软件</li></ul><p><img src="/2018/05/14/企业软件开发-J2EE/pic1.png" alt=""></p><h3 id="J2EE应用程序组件"><a href="#J2EE应用程序组件" class="headerlink" title="J2EE应用程序组件"></a>J2EE应用程序组件</h3><p>J2EE应用程序是由组件构成的.J2EE组件是具有独立功能的软件单元，它们通过相关的类和文件组装成J2EE应用程序，并与其他组件交互。J2EE说明书中定义了以下的J2EE组件:</p><ul><li>应用客户端程序和applets是客户层组件.</li><li>Java Servlet和JavaServer Pages(JSP)是web层组件.</li><li>Enterprise JavaBeans(EJB)是业务层组件.</li></ul><h4 id="客户层组件"><a href="#客户层组件" class="headerlink" title="客户层组件"></a>客户层组件</h4><p>J2EE应用程序可以是基于web方式的,也可以是基于传统方式的.</p><h4 id="web-层组件"><a href="#web-层组件" class="headerlink" title="web 层组件"></a>web 层组件</h4><p>J2EE web层组件可以是JSP 页面或Servlets.按照J2EE规范，静态的HTML页面和Applets不算是web层组件。<br>正如下图所示的客户层那样，web层可能包含某些 JavaBean 对象来处理用户输入，并把输入发送给运行在业务层上的enterprise bean 来进行处理。<br><img src="/2018/05/14/企业软件开发-J2EE/pic2.png" alt=""></p><h4 id="业务层组件"><a href="#业务层组件" class="headerlink" title="业务层组件"></a>业务层组件</h4><p>业务层代码的逻辑用来满足银行，零售，金融等特殊商务领域的需要,由运行在业务层上的enterprise bean 进行处理. 下图表明了一个enterprise bean 是如何从客户端程序接收数据，进行处理(如果必要的话), 并发送到EIS 层储存的，这个过程也可以逆向进行。<br><img src="/2018/05/14/企业软件开发-J2EE/pic3.png" alt=""><br>有三种企业级的bean: 会话(session) beans, 实体(entity) beans, 和消息驱动(message-driven)beans. 会话bean 表示与客户端程序的临时交互. 当客户端程序执行完后, 会话bean 和相关数据就会消失. 相反, 实体bean 表示数据库的表中一行永久的记录. 当客户端程序中止或服务器关闭时, 就会有潜在的服务保证实体bean 的数据得以保存.消息驱动 bean 结合了会话bean 和 JMS(java消息服务,java message service)的消息监听器的特性, 允许一个业务层组件异步接收JMS 消息.</p><h3 id="企业信息系统层"><a href="#企业信息系统层" class="headerlink" title="企业信息系统层"></a>企业信息系统层</h3><p>企业信息系统层处理企业信息系统软件包括企业基础建设系统例如企业资源计划 (ERP), 大型机事务处理, 数据库系统,和其它的遗留信息系统. 例如，J2EE 应用组件可能为了数据库连接需要访问企业信息系统</p><h2 id="J2EE的结构"><a href="#J2EE的结构" class="headerlink" title="J2EE的结构"></a>J2EE的结构</h2><p>这种基于组件，具有平台无关性的J2EE结构使得J2EE程序的编写十分简单，因为业务逻辑被封装成可复用的组件，并且J2EE 服务器以容器的形式为所有的组件类型提供后台服务. 因为你不用自己开发这种服务, 所以你可以集中精力解决手头的业务问题.</p><h3 id="容器和服务"><a href="#容器和服务" class="headerlink" title="容器和服务"></a>容器和服务</h3><p>容器设置定制了J2EE服务器所提供得内在支持，包括安全，事务管理，JNDI(Java Naming and Directory Interface)寻址,远程连接等服务，以下列出最重要的几种服务：</p><ul><li><strong>J2EE安全(Security)</strong> 模型可以让你配置 web 组件或enterprise bean ,这样只有被授权的用户才能访问系统资源. 每一客户属于一个特别的角色，而每个角色只允许激活特定的方法。你应在enterprise bean的布置描述中声明角色和可被激活的方法。由于这种声明性的方法，你不必编写加强安全性的规则。</li><li><strong>J2EE事务管理(Transaction Management)</strong> 模型让你指定组成一个事务中所有方法间的关系，这样一个事务中的所有方法被当成一个单一的单元. 当客户端激活一个enterprise bean中的方法，容器介入一管理事务。因有容器管理事务，在enterprise bean中不必对事务的边界进行编码。要求控制分布式事务的代码会非常复杂。你只需在布置描述文件中声明enterprise bean的事务属性，而不用编写并调试复杂的代码。容器将读此文件并为你处理此enterprise bean的事务。</li><li><strong>JNDI寻址(JNDI Lookup)</strong> 服务向企业内的多重名字和目录服务提供了一个统一的接口,这样应用程序组件可以访问名字和目录服务.</li><li><strong>J2EE远程连接(Remote Client Connectivity)</strong> 模型管理客户端和enterprise bean间的低层交互. 当一个enterprise bean创建后, 一个客户端可以调用它的方法就象它和客户端位于同一虚拟机上一样.</li><li><strong>生存周期管理(Life Cycle Management)</strong> 模型管理enterprise bean的创建和移除,一个enterprise bean在其生存周期中将会历经几种状态。容器创建enterprise bean，并在可用实例池与活动状态中移动他，而最终将其从容器中移除。即使可以调用enterprise bean的create及remove方法，容器也将会在后台执行这些任务。</li><li><strong>数据库连接池(Database Connection Pooling)</strong> 模型是一个有价值的资源。获取数据库连接是一项耗时的工作，而且连接数非常有限。容器通过管理连接池来缓和这些问题。enterprise bean可从池中迅速获取连接。在bean释放连接之可为其他bean使用。</li></ul><h3 id="容器类型"><a href="#容器类型" class="headerlink" title="容器类型"></a>容器类型</h3><p>J2EE应用组件可以安装部署到以下几种容器中去:</p><ul><li><strong>EJB容器</strong> 管理所有J2EE应用程序中企业级bean的执行. enterprise bean和它们的容器运行在J2EE服务器上.</li><li><strong>Web容器</strong> 管理所有J2EE应用程序中JSP页面和Servlet组件的执行. Web组件和它们的容器运行在J2EE服务器上.</li><li><strong>应用程序客户端容器</strong> 管理所有J2EE应用程序中应用程序客户端组件的执行. 应用程序客户端和它们的容器运行在J2EE 服务器上.</li><li><strong>Applet容器</strong> 是运行在客户端机器上的web浏览器和Java插件的结合.</li></ul><p><img src="/2018/05/14/企业软件开发-J2EE/pic4.png" alt=""></p><h2 id="J2EE核心技术"><a href="#J2EE核心技术" class="headerlink" title="J2EE核心技术"></a>J2EE核心技术</h2><p>J2EE平台由一整套服务(Services)、应用程序接口(APIs)和协议构成，它对开发基于Web的多层应用提供了功能支持，下面对J2EE中的13种技术规范进行简单的描述(限于篇幅，这里只能进行简单的描述):</p><ul><li><strong>JDBC(Java Database Connectivity):</strong> JDBC API为访问不同的数据库提供了一种统一的途径，象ODBC一样，JDBC对开发者屏蔽了一些细节问题，另外，JDCB对数据库的访问也具有平台无关性。</li><li><strong>JNDI(Java Name and Directory Interface):</strong> JNDI API被用于执行名字和目录服务。它提供了一致的模型来存取和操作企业级的资源如DNS和LDAP，本地文件系统，或应用服务器中的对象。</li><li><strong>EJB(Enterprise JavaBean):</strong> J2EE技术之所以赢得某体广泛重视的原因之一就是EJB。它们提供了一个框架来开发和实施分布式商务逻辑，由此很显著地简化了具有可伸缩性和高度复杂的企业级应用的开发。EJB规范定义了EJB组件在何时如何与它们的容器进行交互作用。容器负责提供公用的服务，例如目录服务、事务管理、安全性、资源缓冲池以及容错性。但这里值得注意的是，EJB并不是实现J2EE的唯一途径。正是由于J2EE的开放性，使得有的厂商能够以一种和EJB平行的方式来达到同样的目的。</li><li><strong>RMI(Remote Method Invoke):</strong> 正如其名字所表示的那样，RMI协议调用远程对象上方法。它使用了序列化方式在客户端和服务器端传递数据。RMI是一种被EJB使用的更底层的协议。</li><li><strong>Java IDL/CORBA:</strong> 在Java IDL的支持下，开发人员可以将Java和CORBA((Common Object Request Broker Architecture,公共对象请求代理体系结构,通用对象请求代理体系结构)是由OMG组织制订的一种标准的面向对象应用程 序体系规范)集成在一起。他们可以创建Java对象并使之可在CORBA ORB中展开, 或者他们还可以创建Java类并作为和其它ORB一起展开的CORBA对象的客户。后一种方法提供了另外一种途径，通过它Java可以被用于将你的新的应用和旧的系统相集成。</li></ul><hr><ul><li><strong>JSP(Java Server Pages):</strong> JSP页面由HTML代码和嵌入其中的Java代码所组成。服务器在页面被客户端所请求以后对这些Java代码进行处理，然后将生成的HTML页面返回给客户端的浏览器。</li></ul><p><strong>1、JSP概述</strong></p><ul><li>在HTML语言中混合Java程序代码，由服务器端Java语言引擎解释执行</li><li>HTML负责描述信息显示格式，JSP负责描述处理逻辑</li><li>JSP代码执行需要JSP引擎，如Tomcat和Apache</li><li>JSP开发的典型方式<ul><li>直接使用：显示简单的动态效果</li><li>JSP + JavaBeans：需要与数据库连接，管理诸如帐号之类的信息</li><li>JSP + JavaBeans + Servlet：将事务逻辑与表现逻辑分开，JSP负责表现逻辑的处理和输出，Servlet专注于处理Web的关键业务逻辑</li></ul></li></ul><p><strong>2、JSP引擎的工作原理</strong></p><ul><li>将JSP页面翻译成一个Servlet(Java文件)</li><li>JSP引擎调用Java编译器对这个Servlet进行编译，得到可执行的class文件</li><li>JSP引擎调用java虚拟机来解释执行class文件，生成向客户端发送的应答，然后发送给客户<br>  <strong>上述步骤在JSP页面第一次被访问时才会执行，以后会因为类文件已经生成而提高效率</strong><br><img src="/2018/05/14/企业软件开发-J2EE/pic5.png" alt=""></li></ul><p><strong>3、JSP和ASP的比较</strong></p><ul><li>相似之处<ul><li>均是运行于服务器，都属于动态网页生成技术</li><li>都使用HTML来决定网页的版面，在HTML 代码中混合某种程序代码，由语言引擎解释执行程序代码</li><li>HTML负责描述显示样式，程序代码描述处理逻辑</li></ul></li><li>区别<ul><li>JSP基于JavaServlet及整个J2EE体系，支持跨平台</li><li>ASP由微软推出，只能在Windows平台上运行</li><li>ASP下的编程语言是 VBScript 之类的脚本语言，而JSP 使用的是Java</li><li>ASP与JSP还有一个更为本质的区别：两种语言引擎用完全不同的方式处理页面中嵌入的程序代码<ul><li>在ASP下，VBScript代码被ASP引擎解释执行</li><li>在JSP下，代码被编译成Servlet并由Java虚拟机执行，这种编译操作仅在对JSP页面的第一次请求时发生</li></ul></li></ul></li></ul><hr><ul><li><strong>Java Servlet:</strong> Servlet是一种小型的Java程序，它扩展了Web服务器的功能。作为一种服务器端的应用，当被请求时开始执行，这和CGI Perl脚本很相似。Servlet提供的功能大多与JSP类似，不过实现的方式不同。JSP通常是大多数HTML代码中嵌入少量的Java代码，而servlets全部由Java写成并且生成HTML。</li></ul><p><strong>1、Servlet概述</strong><br><strong>Servlets＝Server ＋Applet</strong></p><ul><li>运行于Web服务器端的Java小程序，用来扩展Web服务器功能</li><li>一种扩展Web服务器功能的技术，且由于用Java编写，所以能够访问整个Java API库，包括用于访问企业数据库的JDBC API</li><li>用特定的Java解决方案替代了其它的Web服Servlets务器方编程模式(如：CGI，ISAPI等)，因而继承了Java的所有特性(跨平台、多线程、OO)</li><li>用来编写Servlets的Servlet API对于服务器环境和协议没有任何特殊的要求，所以Servlets具有很强的可移植性，也不像利用CGI程序等其它方式那样具有性能局限</li><li>Servlets也同样使用HTTP协议与客户端进行通讯，所以有时也称Sevlets为“HTTP Servlets”</li></ul><p><strong>2、java servlet 和JSP的比较</strong></p><ul><li>相似之处<ul><li>均基于Java技术，都继承了Java的所有特性，且都可以使用Java API</li><li>工作方式相似：JSP代码先被JSP容器转换为Servlet代码再编译为类</li><li>两者在J2EE体系结构中的工作层次相同，都负责与客户端的连接</li></ul></li><li>区别<ul><li>编程方式不同：Servlets是一些运行于Web服务器端的Java小程序；而JSP是脚本，编写起来更简单容易</li><li>应用目的不同：Servlet主要用于从客户端接收请求信息，而JSP主要负责将服务器端信息传送到客户端</li><li>JSP真正意义：可将界面设计和业务逻辑设计分离</li></ul></li></ul><hr><ul><li><strong>XML(Extensible Markup Language):</strong> XML是一种可以用来定义其它标记语言的语言。它被用来在不同的商务过程中共享数据。XML的发展和Java是相互独立的，但是，它和Java具有的相同目标正是平台独立性。通过将Java和XML的组合，您可以得到一个完美的具有平台独立性的解决方案。</li><li><strong>JMS(Java Message Service):</strong> MS是用于和面向消息的中间件相互通信的应用程序接口(API)。它既支持点对点的域，有支持发布/订阅(publish/subscribe)类型的域，并且提供对下列类型的支持：经认可的消息传递,事务型消息的传递，一致性消息和具有持久性的订阅者支持。JMS还提供了另一种方式来对您的应用与旧的后台系统相集成。</li><li><strong>JTA(Java Transaction Architecture):</strong> JTA定义了一种标准的API，应用系统由此可以访问各种事务监控。</li><li><strong>JTS(Java Transaction Service):</strong> JTS是CORBA OTS事务监控的基本的实现。JTS规定了事务管理器的实现方式。该事务管理器是在高层支持Java Transaction API (JTA)规范，并且在较底层实现OMG OTS specification的Java映像。JTS事务管理器为应用服务器、资源管理器、独立的应用以及通信资源管理器提供了事务服务。</li><li><strong>JavaMail:</strong> JavaMail是用于存取邮件服务器的API，它提供了一套邮件服务器的抽象类。不仅支持SMTP服务器，也支持IMAP服务器。</li><li><strong>JAF(JavaBeans Activation Framework):</strong> JavaMail利用JAF来处理MIME编码的邮件附件。MIME的字节流可以被转换成Java对象，或者转换自Java对象。大多数应用都可以不需要直接使用JAF。</li></ul><hr><ul><li><strong>JavaBean</strong></li></ul><p><strong>1、概述</strong></p><ul><li>JavaBean是基于Java的组件模型，类似于Microsoft的COM组件<ul><li>JavaBean通过Java虚拟机执行</li><li>可以无限扩充Java程序的功能，通过组合快速生成新的应用程序</li><li>JavaBean传统的应用在于可视化的领域，如AWT下的应用<ul><li>自从JSP诞生后，JavaBean更多的应用在了非可视化领域，在服务器端应用方面表现出来了越来越强的生命力</li></ul></li></ul></li><li>JavaBean区别于Java类的特点<ul><li>有公共无参数的构造函数</li><li>每一个属性都要有set，get方法</li><li>实现Serializable接口</li></ul></li></ul><p><strong>2、JavaBean的组成</strong></p><ul><li>属性<ul><li>在设计Bean时可以改变的外观和行为特征</li><li>开发工具通过对Bean进行内省来获知其属性，进而发布其属性</li></ul></li><li>方法<ul><li>JavaBean中的方法就是通常的Java方法，它可以从其他组件或在脚本环境中调用</li><li>默认情况下，所有bean的公有方法都可以被外部调用，但bean一般只会引出其公有方法的一个子集</li></ul></li><li>事件<ul><li>Bean与其他组件交流信息的主要方式是发送和接收事件</li></ul></li></ul><hr><h2 id="J2EE安全机制"><a href="#J2EE安全机制" class="headerlink" title="J2EE安全机制"></a>J2EE安全机制</h2><p><strong>1、J2EE的安全概念</strong></p><ul><li>主体(Principal)<br>被在企业安全服务验证了的实体，常用主体名(用户登陆名)作为他的标识，通过与主体相关的验证数据(登陆密码)进行验证</li><li>安全策略域(Security Policy Domain)<br>从安全策略角度划分的逻辑区域，同一区域内的主体采用相同的安全策略</li><li>安全技术域(Security Technology Domain)<br>在一个安全技术域中使用同样的安全机制来执行安全策略，一个安全技术域可包括多个安全策略域</li><li>安全属性(Security Attributes)<br>每个主体都有一系列与之相关的安全属性，用于访问被保护的资源，检查用户身份和完成其他安全相关功能</li><li>凭证(Credential)<br>包含或引用为J2EE系统验证一个主体的安全属性。若通过，将获得一个包含安全属性的凭证</li></ul><p><strong>2、授权</strong><br>基于用户权限或用户类别管理对受保护系统资源的访问</p><ul><li>代码授权(Code Authorization)<ul><li>通过Java 2安全模型来限制特定J2SE的类和方法的执行，以保护系统安全</li></ul></li><li>调用者授权(Caller Authorization)<ul><li>由应用程序装配者或应用程序部署者分配的安全角色(具有相同安全属性的逻辑组)</li></ul></li><li>安全角色引用<ul><li>由应用程序提供者用来引用安全角色的标识</li></ul></li><li>用户和组<ul><li>实际环境中的用户及用户的集合</li></ul></li><li>访问控制<ul><li>确保安全角色只能访问已授予它安全权限的授权对象(EJB的远程方法、Web资源等)，访问控制在应用程序描述文件中与安全角色关联</li></ul></li><li>映射<ul><li>将实际环境中的用户和角色与安全角色联系起来，使实际用户具有对企业资源访问的适当权限</li></ul></li><li>被传播的调用者身份标识(Propagated Caller Identity)<ul><li>用传播调用者标识作为web组件和ejb组件调用者的标识来进行验证 ,要注意的是在调用链中传递的是用户的标识，而不是凭证(credentials)</li></ul></li></ul><p><strong>3、验证</strong><br>用户或组件调用者向系统证明身份的过程</p><ul><li>Web客户端的验证<ul><li>HTTP基本验证：利用用户名和密码作为验证信息</li><li>基于表单的验证：可根据用户需求定制登陆和出错界面</li><li>基于客户端证书的验证：通过HTTPS(HTTP over SSL)来保证验证的安全性</li></ul></li><li>Application客户端的验证(微信网页版怎么验证)<ul><li>单点登陆SSO<ul><li>在特定的逻辑安全区域中，只需要登陆一次即可访问不同应用系统中的授权资源</li><li>J2EE通过凭证来实现单点登陆</li></ul></li><li>惰性验证：用户访问受保护资源时才执行验证过程</li></ul></li></ul><p><strong>4、SSO的主要实现方式</strong></p><ul><li>共享cookies<br>基于共享同域的cookie是Web刚开始阶段时使用的一种方式，它利用浏览同域名之间自动传递cookies机制，实现两个域名之间系统令牌传递问题；另外，关于跨域问题，虽然cookies本身不跨域，但可以利用它实现跨域的SSO 。如：代理、暴露SSO令牌值等。<br><strong>缺点：不灵活而且有不少安全隐患，已经被抛弃。</strong></li></ul><p><strong>cookies原理</strong><br>当用户使用浏览器访问一个支持Cookie的网站的时候，用户会提供包括用户名在内的个人信息并且提交至服务器；接着，服务器在向客户端回传相应的超文本的同时也会发回这些个人信息，当然这些信息并不是存放在HTTP响应体（Response Body）中的，而是存放于HTTP响应头（Response Header）；当客户端浏览器接收到来自服务器的响应之后，浏览器会将这些信息存放在一个统一的位置，对于Windows操作系统而言，我们可以从： [系统盘]:\Documents and Settings[用户名]\Cookies目录中找到存储的Cookie；自此，客户端再向服务器发送请求的时候，都会把相应的Cookie再次发回至服务器。而这次，Cookie信息则存放在HTTP请求头（Request Header）了。有了Cookie这样的技术实现，服务器在接收到来自客户端浏览器的请求之后，就能够通过分析存放于请求头的Cookie得到客户端特有的信息，从而动态生成与该客户端相对应的内容。通常，我们可以从很多网站的登录界面中看到“请记住我”这样的选项，如果你勾选了它之后再登录，那么在下一次访问该网站的时候就不需要进行重复而繁琐的登录动作了，而这个功能就是通过Cookie实现的。</p><hr><ul><li>Broker-based(基于经纪人)<br>这种技术的特点就是，有一个集中的认证和用户帐号管理的服务器。经纪人给被用于进一步请求的电子身份存取。中央数据库的使用减少了管理的代价，并为认证提供一个公共和独立的 “第三方”。例如Kerberos、Sesame、IBM KryptoKnight(凭证库思想)等。Kerberos是由麻省理工大学发明的安全认证服务，已经被UNIX和Windows作为默认的安全认证服务集成进操作系统。</li><li>Agent-based(基于代理人)<br>在这种解决方案中，有一个自动地为不同的应用程序认证用户身份的代理程序。这个代理程序需要设计有不同的功能。比如，它可以使用口令表或加密密钥来自动地将认证的负担从用户移开。代理人被放在服务器上面，在服务器的认证系统和客户端认证方法之间充当一个“翻译”。例如SSH等。</li><li>Token-based<br>例如SecureID,WebID，现在被广泛使用的口令认证，比如FTP、邮件服务器的登录认证，这是一种简单易用的方式，实现一个口令在多种应用当中使用。</li><li>基于网关</li><li>基于SAML<br>SAML(Security Assertion Markup Language，安全断言标记语言)的出现大大简化了SSO，并被OASIS批准为SSO的执行标准。开源组织OpenSAML实现了SAML规范。</li></ul><h2 id="J2EE平台的角色分类"><a href="#J2EE平台的角色分类" class="headerlink" title="J2EE平台的角色分类"></a>J2EE平台的角色分类</h2><p><strong>角色分类</strong></p><ul><li>J2EE产品提供者<ul><li>实现提供了容器、API及其他特征的J2EE产品</li></ul></li><li>应用组件提供者<ul><li>开发应用程序构建块(如HTML文档、EJBs、JSPs等)</li><li>在许多场合该角色可进一步细分</li></ul></li><li>应用组装者<ul><li>使用由组件提供者开发的组件，并将他们组装成一个完整的J2EE应用</li></ul></li><li>部署者<ul><li>部署、配置和运行EJB及Web应用</li></ul></li><li>系统管理员<ul><li>配置和管理架构环境</li></ul></li><li>工具提供者<ul><li>提供应用组件开发和打包工具</li></ul></li></ul><p><strong>J2EE部署</strong></p><ul><li>JAR—Java Archive<ul><li>Java类文件</li><li>EJBs</li></ul></li><li>WAR—Web Archive<ul><li>Servlets</li><li>JSPs</li></ul></li><li>EAR—Enterprise Archive<ul><li>包含构成整个应用的所有其他JARs和WARs</li></ul></li><li>配置描述符<ul><li>XML</li><li>EJB JARs，WAR及EARs均需要</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;J2EE&quot;&gt;&lt;a href=&quot;#J2EE&quot; class=&quot;headerlink&quot; title=&quot;J2EE&quot;&gt;&lt;/a&gt;J2EE&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;J2ME:嵌入式设备及消费类电器&lt;/li&gt;
&lt;li&gt;J2SE:普通PC应用&lt;/li&gt;
&lt;li&gt;J2EE：企业网应
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="企业软件开发" scheme="http://yoursite.com/tags/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>企业软件开发_大型系统设计关键技术</title>
    <link href="http://yoursite.com/2018/05/12/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%A4%A7%E5%9E%8B%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%85%B3%E9%94%AE%E6%8A%80%E6%9C%AF/"/>
    <id>http://yoursite.com/2018/05/12/企业软件开发-大型系统设计关键技术/</id>
    <published>2018-05-12T11:54:20.000Z</published>
    <updated>2018-09-22T07:36:53.318Z</updated>
    
    <content type="html"><![CDATA[<h2 id="大型网站架构的目标与挑战"><a href="#大型网站架构的目标与挑战" class="headerlink" title="大型网站架构的目标与挑战"></a>大型网站架构的目标与挑战</h2><p><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic1.png" alt=""></p><h2 id="网站架构演变及其技术脉络"><a href="#网站架构演变及其技术脉络" class="headerlink" title="网站架构演变及其技术脉络"></a>网站架构演变及其技术脉络</h2><h3 id="硬件方面"><a href="#硬件方面" class="headerlink" title="硬件方面"></a>硬件方面</h3><ul><li><strong>处理能力的提升：</strong> 部署多颗CPU，选择多核心、具备更高运算频率、更大高速缓存的CPU；<br>处理能力的提升最直接的反应在于Web请求的处理效率和应用程序的执行效率。</li><li><strong>内存带宽与容量：</strong><br>内存带宽与容量的提升最直接的反应在于应对数据库大量的数据交换。</li><li><strong>磁盘搜索与I/O能力：</strong> 选择更高的转速、更大的硬盘缓存、组件磁盘阵列RAID<br>磁盘搜索与I/O能力的提升最直接反应在于数据库大量的查询和读写以及文件的读写。</li><li><strong>网络带宽的提升：</strong> 更大带宽、多线路接入、独享带宽</li></ul><h3 id="部署方面"><a href="#部署方面" class="headerlink" title="部署方面"></a>部署方面</h3><h4 id="1-web动静态资源分离及其与DB物理分离"><a href="#1-web动静态资源分离及其与DB物理分离" class="headerlink" title="1.web动静态资源分离及其与DB物理分离"></a>1.web动静态资源分离及其与DB物理分离</h4><p><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic2.png" alt=""></p><ul><li>优点：“简单”、安全性提高</li><li>缺点：存在单点，谈不上高可用性(high availability架构目标)</li><li>技术点：应用设计要保证可扩展(framework很重要Spring/Beetle)、Web Server动/静态资源分离、Web Server(Apache\Nginx\IIS\JBoss…)、Database Server(Mysql\Oracle\Redis…)</li></ul><p><strong>注意：</strong> 一般地，本文提到的物理服务器都是泛指pc级物理服务器；Web Server泛指HTTP服务器和应用服务器综合体对于一个试水性网站来说为了节约成本，Web Server和DB Server都放在同一台pc Server服务器上是常见的事情。当网站访问量增大，cpu处理能力是瓶颈的时候，通过把web Server和Db Server简单物理分开的，效果明显！</p><p>web动静态资源分离：</p><ul><li>img,doc,js,css等静态资源使用单独的Web HTTP Server处理请求</li><li>动态页面静态化处理</li></ul><p><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic3.png" alt=""></p><ul><li>效率最高、消耗最小的就是纯静态化的html页面，所以网站尽可能使用静态页面来实现。但是对于大量内容且频繁更新的网站，无法全部手动实现，于是出现了常见的信息发布系统CMS，像各门户站点的新闻频道，甚至其他频道，都是通过信息发布系统来管理和实现的，信息发布系统可以实现最简单的信息录入自动生成静态页面，还能具备频道管理、权限管理、自动抓取等功能。对于一个大型网站来说，拥有一套高效、可管理的CMS是必不可少的。</li><li>除了门户和信息发布类型的网站，对于交互性要求很高的社区类型网站来说，尽可能的静态化也是提高性能的必要手段，将社区内的帖子、文章进行实时的静态化，有更新的时候再重新静态化也是大量使用的策略，像Mop的大杂烩就是使用了这样的策略，网易社区等也是如此。</li><li>同时，html静态化也是某些缓存策略使用的手段，对于系统中频繁使用数据库查询但是内容更新很小的应用，可以考虑使用html静态化来实现，比如论坛中论坛的公用设置信息，这些信息目前的主流论坛都可以进行后台管理并且存储再数据库中，这些信息其实大量被前台程序调用，但是更新频率很小，可以考虑将这部分内容进行后台更新的时候进行静态化，这样避免了大量的数据库访问请求。</li></ul><h4 id="2-采取缓存处理"><a href="#2-采取缓存处理" class="headerlink" title="2.采取缓存处理"></a>2.采取缓存处理</h4><p>访问量持续增大，页面响应越来越慢。考虑到网站还处在试水性成长阶段，节约成本，硬件不动，着重应用本身优化。采取缓存处理机制是个必然的选择。<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic4.png" alt=""></p><ul><li>优点：简单有效、维护方便</li><li>缺点：依然存在单点</li><li><p>技术点：客户端(浏览器)缓存、前端页面缓存、页面片段缓存、本地数据缓存/数据库缓存</p><ul><li>客户端(浏览器)缓存<br>能够让浏览器缓存的数据一定要缓存；浏览器能够处理的运算，决不放在服务器端来处理。<ul><li>根据HTTP协议特性，修改Header参数(Cache-Control、Expires、Pragma、Last-Modified、Etag)，让浏览器来缓存页面(一些优秀开发框架会对此做透明的封装，例如：Beetle)</li><li>使用HTTP1.1协议，由于http pipelining技术特性，能够使用get请求的决不采取post请求</li><li>为了节约带宽，压缩页面(Content-Encoding: gzip)；页面各个元素能“小”即“小”，例如：js包压缩，js合并，图片压缩等</li><li>会话状态信息采取Cookie代替传统使用服务器Sessions对象存储习惯做法；使用Ajax实现页面局部刷新</li><li>如果可能，可采取浏览器插件技术突破浏览器功能限制，将原本在服务器端运算，尽量迁到浏览器端。ActiveX/Applet/Flash/….HTML5(最值得期待，她的出现必定改变整个Web世界)</li></ul></li><li><p>前端页面缓存</p><ul><li><p>访客向网站发出访问请求,由前端页面缓存器负担原服务器的处理进程做出响应,获取原服务器的相应网页内容,将其储存在自身的内存中,与此同时,传送给访客这一缓存的内容;如有另一访客也请求访问之前的相同内容,前端页面缓存器毋须再次获取原服务器上的相应内容,而直接从自身的内存中获取,将这一内容传送给访客。反之,前端页面缓存器也可缓存访客的GET和POST请求。</p></li><li><p>访客实际面对的是前端页面缓存器,与网站之间的通讯完全由前端页面缓存器反向代理,而非原服务器直接响应访客,这将大大加快访客上网流畅度,有效提升访问量,显著降低带宽占用,减轻原始服务器的繁忙度,加快响应速度,毋须不停地购置大内存,大硬盘,扩容电力设施为服务器端节省成本。<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic5.png" alt=""><br><strong>注意：</strong> 采用具备缓存功能的http反向代理服务器作前端页面缓存器，Varnish\Squid\Ncache\AiCache(商业)…[硬件F5]</p></li></ul></li><li><p>页面片段缓存ESI(Edge Side Includes)</p><ul><li>ESI是一个基于XML的标记语言，目的是在HTTP中组装各种资源。在实际环境中，一个动态生成的页面，当中可能只有少量的内容是频繁变化的或是个性化的，对于传统的Cache服务器来说，为了能够保证页面的时效性，却由于页面中这些少量的动态内容而无法将整个页面进行缓存。ESI通过使用简单的标记语言来对那些可以缓存和不能缓存的网页中的内容片断进行描述，每个网页都被划分成不同的小部分分别赋予不同的缓存控制策略，使Cache服务器可以根据这些策略在将完整的网页发送给用户之前将不同的小部分动态地组合在一起。通过这种控制，可以有效地减少从服务器抓取整个页面的次数，而只用从原服务器中提取少量的不能缓存的片断，因此可以有效降低原服务器的负载，同时提高用户访问的响应时间。</li><li>ESI需要服务器端支持，常见apache(mod_esi)、WebLogic、JSP标签库(JESI)等。</li></ul></li><li><p>本地数据缓存</p><ul><li>关系数据库系统(如：Oracle\MySql)<br>Query Cache策略：<ul><li>一般以sql为key来缓存查询结果，尽量不要拼sql，使用PreparedStatement的“？”模式sql；</li><li>Query Cache大小要根据数据库系统具体情况合理设置，过大只会浪费内存，参考值：128M</li></ul></li><li>关系数据库系统Data<br>Buffer策略：就是数据库数据内存缓存器，其访问命中率决定数据库性能，可根据实际物理内存大小适量增大，如：MySql建议buffer值为物理内存60-80%</li><li>应用服务器Cache包括：对象缓存(例如：对象线程安全，做成单例)，更新频率不大数据考虑缓存(如：基表数据、配置文件信息)，考虑使用线程池，对象池，连接池等</li><li>常见java解决方案：map\OSCache\EHCache等<br><strong>注意：</strong> 1、需要从数据库系统和Web应用服务器两个层面考虑缓存优化<br>2、常见缓存算法：（贝莱蒂算法、最近最少使用算法、最近最频繁使用算法、伪LRU算法）</li></ul></li></ul></li></ul><h4 id="3-增加机器做HA、数据库读写分离"><a href="#3-增加机器做HA、数据库读写分离" class="headerlink" title="3.增加机器做HA、数据库读写分离"></a>3.增加机器做HA、数据库读写分离</h4><p><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic6.png" alt=""></p><ul><li>优点：增加服务器和HA机制，系统性能及可用性得到保证</li><li>缺点：读写分离，增加程序难度，架构变复杂，维护难度增加</li><li>技术点：负载均衡、DAL、数据库读写分离<ul><li>负载均衡<br>LVS(LVS集群采用IP负载均衡技术和基于内容请求分发技术。调度器具有很好的吞吐率，将请求均衡地转移到不同的服务器上执行，且调度器自动屏蔽掉服务器的故障，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。整个服务器集群的结构对客户是透明的，而且无需修改客户端和服务器端的程序)<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic7.png" alt=""><br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic8.png" alt=""></li><li>数据库读写分离及DAL<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic9.png" alt=""><br>各个关系数据库厂商针对dal及replication都有自己方案<br>独立的DAL Proxy服务器(MySQL: mysqlproxy,Amoeba；PostgreSQL: PL/Proxy)DAL API(Java: Hibernate Shard,Ibatis Shard,HiveDB,Guzz；Python: Pyshards)</li></ul></li></ul><h4 id="4-CDN、分布式缓存、分库"><a href="#4-CDN、分布式缓存、分库" class="headerlink" title="4.CDN、分布式缓存、分库"></a>4.CDN、分布式缓存、分库</h4><p>网站业务发展迅速，数据量大幅增大是当前最大的挑战，用户分散各地区，某些地方用户访问响应很慢，影响体验和业务发展；同时，由于数据量过大，数据缓存在本地内存已经不现实，分布式缓存是必然选择了。<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic10.png" alt=""></p><ul><li>优点：异地缓存有效解决不同地方用户访问过慢的问题；分库策略带来网站性能整体提升</li><li>缺点：成本大幅增加，架构进一步复杂化，也维护难度进一步增大，架构开始臃肿了</li><li>技术点：CDN、分布式缓存、Shard分库<ul><li>CDN<br>CDN的全称是Content Delivery Network，即内容分发网络。其目的是通过在现有的Internet中增加一层新的网络架构，将网站的内容发布到最接近用户的网络”边缘”，使用户可以就近取得所需的内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。从技术上全面解决由于网络带宽小、用户访问量大、网点分布不均等原因所造成的用户访问网站响应速度慢的问题。 (也就是一个服务器的内容，平均分部到多个服务器上，服务器智能识别，让用户获取离用户最近的服务器，提高速度。</li><li>分布式缓存<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic11.png" alt=""><ul><li>本地缓存性能优秀，但容量有限，无伸缩性</li><li>采用分布式缓存方案突破容量限制，具备良好伸缩性；但分布式涉及远程网络通信消耗其性能本地缓存来得优秀，并可涉及节点状态维护及数据复制问题，其稳定性和可靠性是个挑战。</li><li>目前流行分布式缓存方案：memcached、membase、redis等，基本上当前的NoSQL方案都可以用来做分布式缓存方案</li></ul></li><li>分库：垂直分区和水平分区两种。<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic12.png" alt=""><br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic13.png" alt=""><br>垂直分库后，各模块数据之间如何关联查询？垂直分库前提是良好的松耦合的模块化设计<br>水平分区中，Shard是分布式解决方案，与数据库集中式的表空间分区是两个不同方案(分片Key识别(划分检索依据)是关键)</li></ul></li></ul><h4 id="5-多个数据中心，向分布式存储和计算的架构体系迈进"><a href="#5-多个数据中心，向分布式存储和计算的架构体系迈进" class="headerlink" title="5.多个数据中心，向分布式存储和计算的架构体系迈进"></a>5.多个数据中心，向分布式存储和计算的架构体系迈进</h4><p><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic14.png" alt=""></p><ul><li>优点：多数据中心，带来更高质量区域服务体验；分布式存储及计算架构有效解决pb级数据量存储、检索及计算性能问题</li><li>缺点：架构复杂、数据同步、一致性及系统维护、技能要求等成本十分高</li><li>技术点：分布式文件系统、Map/Reduce、Key-Value存储<ul><li>分布式存储计算解决方案[DFS、Map/Reduce、Key-Value DB]<br>DFS提供了一个全局命名空间的高可用(通过跨机器(和跨机架)的文件数据复制来达到高可用性，免受传统文件存储系统无法避免的许多失败的影响)文件系统，解决高容量数据高效、可靠存储问题；Map/Reduce的计算框架，它与DFS紧密协作，帮助处理收集到的海量数据;Key-Value DB代替传统的数据库，通过一些主键来组织海量数据，并实现高效的查询。<br><img src="/2018/05/12/企业软件开发-大型系统设计关键技术/pic15.png" alt=""><ul><li>DFS分布式文件系统，如：Lustre\HDFS\GFS\TFS\FreeNas等</li><li>Map/Reduce算法（计算框架），基本上现有NoSQL数据库中都支持此算法。</li><li>Key-Value DB，也作为NoSQL解决方案，如：BigTable\Tair\Hbase\ HyperTable等</li><li>提供完整解决方案：<ul><li>Google(GFS|Map/Reduce|BigTable)</li><li>Apache Hadoop(HDFS|Map/Reduce|HBase)<h2 id="架构设计理念与原则"><a href="#架构设计理念与原则" class="headerlink" title="架构设计理念与原则"></a>架构设计理念与原则</h2></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;大型网站架构的目标与挑战&quot;&gt;&lt;a href=&quot;#大型网站架构的目标与挑战&quot; class=&quot;headerlink&quot; title=&quot;大型网站架构的目标与挑战&quot;&gt;&lt;/a&gt;大型网站架构的目标与挑战&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/05/12/企业软件开发-大
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="企业软件开发" scheme="http://yoursite.com/tags/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>企业软件开发_开发模式SSH、SOA、ESB</title>
    <link href="http://yoursite.com/2018/05/12/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E5%BC%80%E5%8F%91%E6%A8%A1%E5%BC%8FSSH%E3%80%81SOA%E3%80%81ESB/"/>
    <id>http://yoursite.com/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/</id>
    <published>2018-05-12T11:52:57.000Z</published>
    <updated>2018-09-22T07:36:53.361Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic1.png" alt=""><br><a href="http://jackeyzzhold.xyz/2018/03/10/java-ssh%E6%A1%86%E6%9E%B6-3/" target="_blank" rel="noopener">见另外一篇博客内容</a></p><h2 id="SOA"><a href="#SOA" class="headerlink" title="SOA"></a>SOA</h2><p>SOA的全称是Service-Oriented Architecture，面向服务架构。它是一种架构，不是一种具体的开发技术。<br>SOA是通过功能组件化、服务化来实现系统集成、解决信息孤岛，这就是其主要目标。而更进一步则是实现更快响应业务的变化、更快推出新的应用系统。与此同时，SOA还实现了整合资源、资源复用。<br><strong>软件开发四阶段：</strong></p><ul><li>汇编语言开发</li><li>面向过程的软件</li><li>面向对象的组件开发</li><li>面向服务的架构开发，即SOA</li></ul><p><strong>SOA特点：</strong></p><ul><li>SOA是一种开发思想。是一种松耦合的框架。可以让软件超越开发语言。</li><li>SOA的开发需要SOA体系的支撑，就像J2EE应用一样，离不开应用服务器。SOA也一样，也有一个类似J2EE服务器的东西支持着整个SOA体系架构—-ESB(Enterprise Service Bus)，企业服务总线。通过这个总线，将多个系统连接起来。</li><li>SOA是基于消息请求响应的一个系统，对请求类型有高度的兼容性。与一个Web应用容器相比，web应用容器只能处理HTTP请求，而 SOA的ESB可以接受HTTP、FTP、WebService、JMS…等请求。这就使得SOA架构具有高度的兼容性，可以将不同的平台集成到一起，从而相互协调工作。</li></ul><p><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic2.png" alt=""></p><p><strong>SOA的使用场景：</strong><br><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic3.png" alt=""><br>通过上面的图我们可以看出，多个子系统直接相互交互，相互调用非常凌乱，这样我们就很不爽，所以我们就用到了我们的SOA架构，SOA又叫服务治理，SOA就是帮助我们把服务之间调用的乱七八糟的关系给治理起来，然后提供一个统一的标准，把我们的服务治理成下图所示，以前我们的服务是互相交互，现在是只对数据总线进行交互，这样系统就变得统一起来。<br><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic4.png" alt=""><br>统一标准：各系统的协议、地址、交互方式。<br>新的交互方式：各个系统分别根据统一标准向数据总线进行注册，各子系统调用其他子系统时，我们并不关心如果找到其他子系统，我们只招数据总线，数据总线再根据统一标准找其他子系统，所以数据总线在这里充当一个只路人的作用。<br><strong>SOA的好处：</strong></p><ul><li>降低用户成本，用户不需要关心各服务之间是什么语言的、不需要知道如果调用他们，只要通过统一标准找数据总线就可以了。</li><li>程序之间关系服务简单</li><li>识别哪些程序有问题（挂掉）</li></ul><p><strong>缺点：</strong> 提示了系统的复杂程度，性能有相应影响。</p><p><strong>数据总线：</strong><br><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic5.png" alt=""><br>数据总线是起到调度服务的作用，数据总线不是集成服务，数据总线更新一个调度框架，每个服务需要根据约定向数据总线注册服务，那么如何注册那？其实数据总线就像一个字典结构，<br>数据总线里面一个key对于一个value，key指的是服务名，value则是服务的调度方式，还有一点需要说明的是，数据总线只是指路人，服务是不经过数据总线的，如上图的黄色线的路径。<br>数据总线通过域名解析实现:一个域名绑定多台服务器，ajax也可以，dns也可以，解析域名嘛。<br>其实数据总线还有一些高级应用，比如心跳检测，实现负载均衡等等，就不细说了，目前应用数据总线的有阿里的dubbo,还有zookeeper。</p><h2 id="ESB"><a href="#ESB" class="headerlink" title="ESB"></a>ESB</h2><p>ESB是一种在松散耦合的服务和应用之间的标准的集成方式，可以作用于：</p><ul><li>面向服务的架构-分布式的应用由可重用的服务组成</li><li>面向消息的架构-应用之间通过ESB发送和接受消息</li><li>事件驱动的架构-应用之间异步地产生和接收消息</li></ul><p><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic6.png" alt=""><br><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic7.png" alt=""><br><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic8.png" alt=""></p><p><strong>ESB服务：</strong></p><ul><li>传输服务<ul><li>安全、可靠的数据传输</li><li>永久性/非永久性</li><li>同步/异步</li></ul></li><li>仲裁服务<ul><li>路由</li><li>格式转换</li></ul></li><li>事件服务<ul><li>事件发现和发布</li><li>Publish/Subscribe</li></ul></li></ul><p><strong>ESB功能：</strong></p><ul><li>通信</li><li>集成</li><li>服务交互</li><li>服务质量</li><li>安全性</li><li>消息处理</li><li>服务级别</li><li>管理和自治</li><li>建模</li><li>基础架构智能</li></ul><p><img src="/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic9.png" alt=""><br><strong>WebSphere DataPower</strong></p><ul><li>简化SOA</li><li>保护SOA</li><li>加速SOA</li></ul><p>应用场景：</p><ul><li>保护对外的web服务</li><li>传统系统集成</li><li>hub式的中介服务</li><li>加速动态的web站点</li></ul><p><strong>不采用传统架构，而采用ESB总线的原因：</strong></p><ul><li>利用开放标准，将软件资产展现为服务的架构</li><li>面向服务的体系架构</li><li>总体性价比</li></ul><hr><p><strong>OSB</strong></p><ul><li>易用性加强</li><li>性能提升<ul><li>采用Cache机制，为静态响应信息提升性能。静态响应信息是指在一段时间内不会发生变化的信息，如天气预报，手机套餐，人民币汇率等，这些数据变化的周期通常是1天，1月。</li><li>实现手段：采用比较成熟的开源Memcached或者轻量级的JCACHE。</li></ul></li><li>管控能力增强</li></ul><hr><p><strong>Mule</strong></p><ul><li>社区活跃度</li><li>易用性<br>“让一切变得更简单”是Mule的宗旨。2次重构核心架构、推出接入云应用，消息流，基于模式的配置以及热部署；Mule IDE3.0，将支持图元拖拽，简化开发。</li><li>扩展性<br>增加一个新协议非常简单，只需实现5个接口类即可</li><li>管理性<ul><li>异常处理框架<br><strong>异常策略设置级别:</strong> model和service<br><strong>异常处理方式：</strong><ul><li>1.将异常路由到指定的目的地</li><li>2.根据异常类型过滤异常，并路由到指定目的地</li><li>3.设置重试次数</li><li>4.当采用了事务时，可以在异常处理策略中设置当发生异常时是继续提交还是回滚事务。</li></ul></li></ul></li><li>文档<br>文档非常丰富，降低了使用门槛。</li></ul><hr><p><strong>ServiceMix</strong><br><strong>优势：</strong></p><ul><li>无缝集成CXF,ActiveMQ,Camel和ODE</li><li>JBI的优势</li><li>基于OSGI</li><li>基于Karaf</li></ul><p><strong>缺点：</strong></p><ul><li>JBI规范太复杂</li><li>架构复杂</li><li>缺少IDE的支持</li><li>缺少governor的支持</li><li>学习门槛高</li></ul><hr><p><strong>Synapse/WSO2 ESB</strong><br>WSO2 ESB对Synapse增加了企业级特征：</p><ul><li>1.基于WSO2的Carbon平台（OSGi框架）</li><li>2.支持集群、负载均衡和failover routing</li><li>3.支持流量控制和数据缓存</li></ul><p>还增加了外围产品：</p><ul><li><ol><li>WSO2 Governance Registry，服务注册产品</li></ol></li><li><ol><li>WSO2 ESB management console，ESB管理控制台</li></ol></li><li><ol><li>WSO2 Carbon Studio，开发ESB的studio</li></ol></li></ul><p><strong>WSO2 ESB的优势：</strong></p><ul><li>基于Axis</li><li>基于WSO2的Carbon平台</li><li>支持集群<br>集群中节点间的通信框架基于Apache Tribes（组通信框架）<br>相关信息持久化在内嵌的Derby中<br>支持一个主节点和多个从节点</li><li>failover routing<br>在集群环境中，所有的请求只能被主节点接收，从节点只能作为备份节点。</li><li>支持流量控制<br>在单个ESB实例或者集群中，可以在服务级别配置流量控制。当请求数超过阀值时，ESB将被拒绝访问。<br>实现机制：借助组件Throttling Mediator</li><li>支持数据缓存<br>集群中的各个ESB实例共享缓存的数据。当一个请求被ESB实例1处理完后返回响应信息，当再次向ESB实例1或者集群中其他的ESB实例发送该请求时，直接从缓存中取出原来的响应信息。<br>实现机制：借助组件Caching Mediator</li><li>WSO2 Governance Registry：开源中最优秀的服务注册项目</li><li>WSO2 ESB management console<br>创建和管理各组件（接入层、中介层和接出层）；<br>图形化地方式统计系统资源（CPU,内存）；<br>图像化统计ESB中各组件（接入层、中介层和接出层）接收发送消息的大小以及响应时间；<br>记录系统日志、SOAP日志；图形化显示消息的流向</li><li>文档丰富</li><li>大量使用实例</li></ul><p><strong>缺点：</strong></p><ul><li>架构不够清晰</li><li>扩展性差</li><li>组件比较混乱</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SSH&quot;&gt;&lt;a href=&quot;#SSH&quot; class=&quot;headerlink&quot; title=&quot;SSH&quot;&gt;&lt;/a&gt;SSH&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2018/05/12/企业软件开发-开发模式SSH、SOA、ESB/pic1.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="企业软件开发" scheme="http://yoursite.com/tags/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>企业软件开发_负载均衡</title>
    <link href="http://yoursite.com/2018/05/12/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    <id>http://yoursite.com/2018/05/12/企业软件开发-负载均衡/</id>
    <published>2018-05-12T11:51:09.000Z</published>
    <updated>2018-09-22T07:36:53.397Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><strong>负载均衡</strong> 是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。一个典型的使用负载均衡策略的是：在软件或者硬件四层交换的基础上搭建squid集群，低成本、高性能还有很强的扩张性，随时往架构中增减节点都非常容易。</p><h2 id="硬件四层交换"><a href="#硬件四层交换" class="headerlink" title="硬件四层交换"></a>硬件四层交换</h2><ul><li>第四层交换使用第三层和第四层信息包的报头信息，根据应用区间识别业务流，将整个区间段的业务流分配到合适的应用服务器进行处理。</li><li>第四层交换功能就像是虚拟IP，指向物理服务器。</li></ul><p>知名产品有：Alteon,F5等。Yahoo中国的近2000台服务器用了三四台Alteon。</p><h2 id="软件四层交换"><a href="#软件四层交换" class="headerlink" title="软件四层交换"></a>软件四层交换</h2><ul><li>YAHOO网站应用—-DNS</li><li>简单的应用—-URL重定向方式</li><li>不太重要的纯linux应用—-LVS</li><li>重要、流量大、应用简单、预算充足—-硬件(F5)(做双机)</li><li>企业应用，复杂、跨平台—-专业负载均衡软件<h3 id="URL重定向方式"><a href="#URL重定向方式" class="headerlink" title="URL重定向方式"></a>URL重定向方式</h3><strong>存在的问题:</strong></li><li>容易在浏览器上形成死循环</li><li>location存放位置问题、带session时重定向可能会出问题</li><li>一般只适用于HTTP方式</li><li>效率低于IP隧道</li><li>实时性不好</li></ul><h3 id="基于DNS"><a href="#基于DNS" class="headerlink" title="基于DNS"></a>基于DNS</h3><p>最早的负载均衡技术是通过DNS来实现的，<strong>在DNS中为多个地址配置同一个名字，因而查询这个名字的客户机将得到其中一个地址，从而使得不同的客户访问不同的服务器，达到负载均衡的目的。</strong></p><ul><li>DNS不能区分服务器的差异，也不能反映服务器的当前运行状态，当使用DNS负载均衡时，必须尽量保证不同的客户机均匀获得不同的地址。</li><li>为了使得地址能随机分配，应该使DNS数据中的刷新时间尽量短，不同地方的DNS服务器能更新对应的地址，达到随机获得地址，但是若设置过短，将使DNS流量大增造成额外的网络问题。</li><li>若某台服务器出现错误，即使及时修改了DNS设置，也需等待足够的时间(刷新时间)才能发挥作用。</li><li>与专业的负载均衡软件如PCL相比，DNS的问题有：<ul><li>往往不能根据系统与服务的状态来判断负载</li><li>往往不能建立较复杂的负载均衡算法</li></ul></li></ul><h3 id="基于LVS"><a href="#基于LVS" class="headerlink" title="基于LVS"></a>基于LVS</h3><p>LVS是一个开源的软件，可以实现LINUX平台下的简单负载均衡。负载均衡集群是在应用服务器高负载的情况下，由多台节点提供可伸缩的，高负载的服务器组以保证对外提供良好的服务响应，LVS就是实现这一功能的技术，是一种Linux操作系统上基于IP层的负载均衡调度技术，<strong>它在操作系统核心层上将来自IP层的TCP/UDP请求均衡地转移到不同的服务器。</strong><br><strong>优点：</strong></p><ul><li>开源免费</li><li>在网上能找到一些相关技术资源</li><li>具有软件负载均衡的一些优点</li></ul><p><strong>缺点：</strong></p><ul><li>没有可靠的支持服务</li><li>功能较为简单</li><li>开启隧道方式需重编译内核</li><li>配置复杂</li><li>只支持linux</li></ul><h3 id="专业负载均衡软件"><a href="#专业负载均衡软件" class="headerlink" title="专业负载均衡软件"></a>专业负载均衡软件</h3><p><strong>特点：</strong></p><ul><li>基于IP隧道的，独立于应用—-对比URL重定向</li><li>支持不同平台—-对比LVS</li><li>实时的—-对比DNS</li><li>能够根据系统、应用的情况来决定负载—-对比硬件</li><li>适用于企业级应用，可靠性、服务保障</li></ul><h2 id="session及负载均衡"><a href="#session及负载均衡" class="headerlink" title="session及负载均衡"></a>session及负载均衡</h2><p>在WEB开发中，服务器可以为每个用户浏览器创建一个 <strong>会话对象（session对象）</strong>，注意：一个浏览器独占一个session对象(默认情况下)。因此，在需要保存用户数据时，服务器程序可以把用户数据写到用户浏览器独占的session中，当用户使用浏览器访问其它程序时，其它程序可以从用户的session中取出该用户的数据，为用户服务。<br>在搭建java web应用程序时，对http session的处理策略很大程度决定了应用程序的扩展性、可用性，处理方案如下：</p><ul><li>在服务器端不保存session，完全无状态：<strong>采用Stateless</strong>，典型例子 <strong>REST</strong>。</li><li>基于浏览器CooKie的session共享<ul><li>把用户相关的session信息存储到浏览器的cookie中，也称为客户端session</li><li><strong>缺点：</strong> 只能够存储字符串、数值等基本类型的数据；cookie大小存在限制；安全性；带宽及数据解压缩、网络传输性能问题。</li></ul></li><li>基于数据库的session共享，实现分布式应用间session共享<ul><li>把session信息存储到数据库表，实现不同应用服务器间session信息的共享。如websphere portal、weblogic portal</li><li>优点：实现简单</li><li>缺点：数据库服务器相对于应用服务器更难扩展且资源更为宝贵，在高并发的web应用中，最大的性能瓶颈通常在于数据库服务器。</li></ul></li><li>基于应用服务器/servlet容器的clustering机制<ul><li>这个机制可以实现session replication的功能，如tomcat clustering/session replication、Jboss buddy replication</li><li>缺点：基于clustering的session复制性能很差，扩展性不行</li></ul></li><li>基于NFS的session共享<ul><li>实现共享各台服务器只需要mount共享服务器的存储session的磁盘即可，实现较为简单。但NFS对高并发读写性能不高、在硬盘I/O性能和网络带宽上存在较大瓶颈。</li></ul></li><li>基于Terracotta、Ehcache、JBossCache等java caching方案实现session共享</li><li>基于Memcached/Tokyo Tyrant等key-value DB的session共享：扩展性最好</li></ul><h2 id="系统拆分"><a href="#系统拆分" class="headerlink" title="系统拆分"></a>系统拆分</h2><ul><li>随着业务增加拆分为小系统</li><li>将所有内容部署在一起，依赖于 <strong>集群分发到多个节点上去做负载均衡</strong>，以实现切割</li><li><strong>独立工具、模块、服务的独立化和集群化，基于SOA服务的企业级应用</strong></li><li>数据库拆分<ul><li>散列</li><li>分区</li><li>分表</li><li>读写分离</li><li>多实例运算</li><li>采用nosql或内存数据库</li></ul></li></ul><h2 id="系统通信"><a href="#系统通信" class="headerlink" title="系统通信"></a>系统通信</h2><p>系统拆分导致系统需要通信，拆分时要尽量减少相互之间的通信，做到系统的低耦合、高内聚、减少外部依赖。</p><ul><li>早期的socket</li><li>RMI</li><li>基于RPC的web services</li><li>httpclient</li></ul><h2 id="负载均衡实例解决"><a href="#负载均衡实例解决" class="headerlink" title="负载均衡实例解决"></a>负载均衡实例解决</h2><h3 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h3><blockquote><p>怎样相对准确获取同时在线用户数，怎样实现类似于聊天室的管理员把用户踢出聊天室的功能，怎样实现类似在线聊天室的功能？</p></blockquote><h3 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h3><blockquote><p>怎样实现同一账号同一时间点只能有一个账号在线</p></blockquote><p><strong>流程图：</strong><br><img src="/2018/05/12/企业软件开发-负载均衡/pic1.png" alt=""></p><ul><li>在账户表的基础上，我新建了一个账户account_session表，用来记录登录账户的account_id和最新一次登录成功用户的session_id。</li><li>然后首先要修改登录方法：每次登录成功后，要将登录用户信息写入Session的同时还要更新account_session表里相应账户的session_id（当然，如果是第一次登录时，进行的便是插入动作）。</li><li>然后要修改获取当前用户信息的方法，在里面要做两重判断：<br>首先，看当前会话是否存在登录用户信息，如果没有，则肯定是未登录，不再赘述，如果有，还要再进一步要用当前会话里存的account_id去account_session表查询最新的session_id，与当前会话中的session_id作比较，如果是一致的，说明当前会话是最新的会话，登录状态正常，如果不一致，说明在当前登录会话创建后，被新的登录会话覆盖掉了，当前的登录会话已经失效，这时候，服务器应该删除当前的登录会话并返回提示给客户端，至此，限制账户同一时间单终端登录功能便实现了。</li></ul><h3 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h3><blockquote><p>在多标签的浏览器中（例如ie8、firefox、chrome），用户开几个标签使用同一个web应用，是一个session还是多个session</p></blockquote><p>在IE6中，每启动1个IE，在进程中就会增加1个iexplor.exe进程，一个此进程就表示1个session对象，就会产生1个唯一sessionID与之对应。但是在多页签的浏览器例如IE7，IE8 ，没启动一个IE，此时浏览器中会有俩个iexplor.exe进程存在，1个代表当前窗口对象，另1个代表页签对象，如果在窗口中新增加页签的话，iexplor.exe的数量会加1.<br>在多页签的浏览器中，进行测试，页面的page_load事件中，增加代码测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string a = Session.SessionID;</span><br><span class="line">Response.Write(a + <span class="string">"&lt;br&gt;"</span>);</span><br></pre></td></tr></table></figure></p><p>发现在1个窗口中，无论打开多少个页签，都是同1个sessionID，那么问题就出现了，比如说：我在一个多标签的浏览器中，打开了俩个页签，分别叫A页签与B页签，那么我此时在A页签中打开1个登陆界面，输入A账户的用户名与密码，并且用session保存这个A用户的账号与密码，然后在B页签里面输入B的账户与密码，并且用session保存起来，那么此时你回头再刷新下A的页签，你会发现A页签里的session保存的A的信息全部被B的信息所覆盖了，这就是多页签使用同1sessionID的产生覆盖的核心机制。那么我们该如何处理呢？<br>我的解决方案是：1个IE窗口只能做1个登陆操作，如果你想再登陆，那么重新打开1个IE对象。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">Button1_Click</span><span class="params">(object sender, EventArgs e)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Session[<span class="string">"a"</span>] != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                PublicMethods.ShowMessageBox(<span class="keyword">this</span>, <span class="string">"同一浏览器不能重复登录！"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Session[<span class="string">"a"</span>] = <span class="keyword">this</span>.txtName.Text.Trim();</span><br><span class="line">            Response.Redirect(<span class="string">"Test.aspx"</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>原理说明：1个多页签IE窗口无论打开多少个页签都是一个sessionID，那么这个sessionID对象下有1个key为a的session内容，如果你第一次登陆的话，这个session为a的内容为Null状态，如果你打开1个页签再做1个登陆操作的话，那么此时session a 就不为Null，提示用户新开1个窗口进行操作。因为新打开的IE会产生1个新的不重复的sessionID，此时这个sessionID对象对应的session a 还是为Null，那么可以进行登陆操作了。</p><h3 id="问题4"><a href="#问题4" class="headerlink" title="问题4"></a>问题4</h3><blockquote><p>struts2中避免用户重复提交同一页面的机制？</p></blockquote><p>防止表单重复提交，这是个很重要的知识点，而且很有用。当用户提交了一个表单，此时，地址栏显示的是处理这个表单的Action的地址，若此时刷新，则会重新发送一次表单数据，即又进行了一次提交，若这个Action是用来处理用户注册的，那么重复提交会再一次向数据库中插入之前已经插入的数据，这显然不是我们想要的。有两种方法，可以防止表单重复提交，一种是用Action的重定向，一种是用Session Token（Session令牌）。</p><p>第一种方法，Action处理完用户提交的数据后，重定向到另一个Action或是一个页面，使用户提交后，所停留的位置，不是当前处理数据的Action，这样用户再刷新时，就不会再次执行这个Action了，就会避免表单重复提交的问题了。</p><p>第二种方法，是一种很经典的处理这个问题的机制。这种方法是在用户要提交的表单中，加入一个&lt;s:token&gt;标签，这样，当浏览器第一次访问这个带有&lt;s:token&gt;标签的页面时，在服务器中，解析&lt;s:token&gt;标签的类（TokenTag.class），会生成一个随机的字符串（这个字符串，查看网页的源代码可以看到），并且发送给客户端的浏览器，同时，在服务器中，会把这个随机字符串保存到用户的session对象中。当第一次提交表单时，在服务器中，会比较客户端和服务器中分别保存的这个随机字符串，因为是第一次提交，所以这两个字符串相等，然后进行正常的业务处理。第一次提交后，在服务器中的session中保存的这个随机字符串，会改变为其他的随机值，注意，这是很重要的一步！此时，地址栏停留在处理用户提交数据的Action中，客户端中保存的随机字符串没有改变，若是刷新页面，即重复提交，服务器再进行两个字符串的比较，会不相等，就会跳转到name为invalid.token的结果页面中，这样就会防止表单重复提交了。<br>举例说明一下session token的机制:<br><strong>Login.jsp:</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;s:form action=<span class="string">"/test/token"</span> theme=<span class="string">"simple"</span>&gt;  </span><br><span class="line">        username:&lt;s:textfield name="username"&gt;&lt;/s:textfield&gt;&lt;br&gt;  </span><br><span class="line">        password:&lt;s:password name="password"&gt;&lt;/s:password&gt;&lt;br&gt;  </span><br><span class="line">        &lt;s:submit value="submit"&gt;&lt;/s:submit&gt;  </span><br><span class="line">        &lt;s:token&gt;&lt;/s:token&gt;&lt;!--一定要有这个标签--&gt;  </span><br><span class="line">    &lt;/s:form&gt;</span><br></pre></td></tr></table></figure></p><p><strong>struts.xml:</strong><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;action name=<span class="string">"token"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.suo.actions.TokenAction"</span>&gt;  </span><br><span class="line">            &lt;result name="success"&gt;/WEB-INF/result/LoginResult.jsp&lt;/result&gt;  </span><br><span class="line">            &lt;result name="invalid.token"&gt;/WEB-INF/result/TokenFailed.jsp&lt;/result&gt;  </span><br><span class="line">            &lt;!-- 若重复提交，则会跳转到这个页面，注意这里result的名字，一定要是invalid.token --&gt;  </span><br><span class="line"></span><br><span class="line">            &lt;interceptor-ref name="token"&gt;&lt;/interceptor-ref&gt;  </span><br><span class="line">            &lt;interceptor-ref name="defaultStack"&gt;&lt;/interceptor-ref&gt;  </span><br><span class="line">            &lt;!-- 这里一定要有这两个拦截器 --&gt;  </span><br><span class="line">        &lt;/action&gt;</span><br></pre></td></tr></table></figure></p><p><strong>TokenAction.java:</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.suo.actions;  </span><br><span class="line"><span class="keyword">import</span> java.util.Map;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;  </span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpSession;  </span><br><span class="line"><span class="keyword">import</span> org.apache.struts2.ServletActionContext;  </span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionContext;  </span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String username;  </span><br><span class="line">    <span class="keyword">private</span> String password;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> username;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.username = username;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> password;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.password = password;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function">    </span>&#123;     </span><br><span class="line">        <span class="keyword">return</span> SUCCESS;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="问题5"><a href="#问题5" class="headerlink" title="问题5"></a>问题5</h3><blockquote><p>怎样实现类似于gmail、sina等大型网站的用户自动登录功能</p></blockquote><p>在用户登录后，将用户的用户名和密码保存到cookie中发送给浏览器，浏览器下次再次访问的时候会把cookie内容带回来，服务器从cookie中区出用户名和密码进行验证，如果验证通过，则允许进入首页等，从而达到自动登录的目的。<br><strong>降低风险：</strong><br>1.通过将cookie中保存的信息进行加密处理，用户登陆成功以后，将时间戳和随机数合并通过MD5加密处理形成Token。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　String token = Utils.MD5(System.currentTimeMillis()+Math.Rand(<span class="number">0</span>,<span class="number">9999999</span>));</span><br></pre></td></tr></table></figure></p><p>当然，也可以通过用户名+系统时间生产Token或者将sessionId加密生产Token也可以。<br>2.将用户ID（uid或者userName）和有效时间（1个月）以及Token保存在cookie中，同时记录到数据库表中（Remember_Key）。<br>3.用户访问网站时，后台读取Cookie，获取uid和Token，去数据库对比，如果都存在，且在有效期内，则通过uid直接获取用户信息并保存session，直接跳转到首页。<br>前端可对此进行处理，获取到后台返回的数据后，展示用户名以及头像信息等。<br>4.后台需要做过滤器，过滤网站的所有页面，每当打开页面时，首先判断是否登陆，如果已经登陆则跳过，如果未登陆，需要先读取Cookie，判断是否匹配，如果匹配则跳过登陆，直接获取用户信息，否则跳转到登陆页面。</p><h3 id="问题6"><a href="#问题6" class="headerlink" title="问题6"></a>问题6</h3><blockquote><p>怎样实现类似于在线投票防止同一用户重复投票的功能。</p></blockquote><p><strong>方法一：利用Session对象</strong><br>在Global.asa的Session_OnStart事件中设置逻辑变量IsVoted，初始值为FALSE（表示还没有投票），投票之后在.asp程序中把IsVoted的值改为TRUE(表示已投过票)。每次投票之前都要判断IsVoted的值。如果IsVoted的值为TRUE，就不能再投票；如果值为FALSE，则可以投票。<br>因为Session对象的使用必须与浏览器的Cookies功能相配合，所以在判断IsVoted值之前，必须先判断浏览器的Cookies功能是否打开。如处于关闭状态，则此种方法失效，所以在这种情况下必须给出提示信息并用Response.End命令中断.asp程序的执行，防止连续反复投票。<br><strong>漏洞：</strong> 如果再打开一个新浏览器窗口，会发现在新打开的浏览器窗口中仍然可以投票。这是因为Session是私有的，一个Session中变量的改变并不影响另一个Session的同名变量的值。<br><strong>方法二：利用Cookies对象</strong><br>因为Cookies对象把变量的值保存在浏览器客户端，所以可以根据Cookies保存的IsVoted的值来判断用户是否投过票。Cookies变量和Session变量一样是私有的，但是如果我们定义了Cookies变量的生存期限，则Cookies变量是公有的，凡是从同一台机器上登录的用户在规定的时间期限没有达到时，都无法投票，这在一定程度上也能防止反复投票。<br><strong>漏洞：</strong> 在Windows 9x环境下，只要把 Windows/Cookies目录下所有＊.txt文件删除，又可重复投票。为了再进一步防止反复投票。<br><strong>方法三：验证IP地址与登录时间</strong><br>此方法首先利用Request.ServerVariables(REMOTE_ADDR)取得用户的IP地址。在Web Server端建立一个标准的MDB类型的数据库，此数据库有一个表，该表只有两个字段：IP地址和登录时间。之所以设置登录时间这个字段，是考虑到拨号上网用户可能共用同一个IP地址，如果一个IP地址只能投一次票，那么显然不合理。同时，我们还采用方法二同样的思想，必须每隔一个设定的时间段，同一个IP地址才能再次投票。所以这种方法比方法一、方法二在防止反复投票方面要严格得多。<br><strong>方法四：小范围调查</strong><br>这种方法只适用于小范围调查，思想与方法三相同，只是把方法三中的 IP地址换成可以唯一代表用户的字段，如学生证号、工作证号等。这时建立的MDB数据库只包括两个字段：证件号码与IsVoted(其中IsVoted是逻辑型字段， TRUE表示已投过票，FALSE表示还未投票，在建库时所有记录的IsVoted的值都设为 FALSE)。在投票之前，要求先输入正确的证件号码，然后再判断IsVoted的值。</p><h3 id="问题7"><a href="#问题7" class="headerlink" title="问题7"></a>问题7</h3><blockquote><p>微信网页版如何验证？<br>问题：<br>（1）如何将手机上的微信号与网页版上的二维码关联起来？<br>（2）如何验证登录并保证唯一性？<br>（3）为什么不直接用用户名和密码登录，而且 采用二维码？<br>（4）如何保证手机端和网页端信息的同步？<br>（5）如何保证在超时、网络断开、其他设备上登录后，原先已经登录的能够自动断开？</p></blockquote><p>1、微信网页版有一个二维码，这个二维码里面的信息其实就是一个url：<a href="https://login.weixin.qq.com/l/8fb2531b276849，" target="_blank" rel="noopener">https://login.weixin.qq.com/l/8fb2531b276849，</a> 当然后面带的那个参数是唯一的。<br>2、微信网页版打开后，就会向服务器发出一个ajax请求，请求的url却不是二维码里的url，而是这种格式：<br><a href="https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login?uuid=c758718a7fb844&amp;tip=1&amp;__=1410184901947，" target="_blank" rel="noopener">https://login.weixin.qq.com/cgi-bin/mmwebwx-bin/login?uuid=c758718a7fb844&amp;tip=1&amp;__=1410184901947，</a> (里面有三个参数，一个是二维码里面的url后面那个唯一的识别码uuid，一个是tip=1，一个是当前时间戳，参数名是一个下划线 _ )，如下图所示：<br><img src="/2018/05/12/企业软件开发-负载均衡/pic2.png" alt=""><br>同时把很多登录后才需要的相关资源都预先加载进来了，所以长连接等待登录用户得到确认后展示用户信息的速度很快，因为无需刷页面和加载头像外的其他资源。<br>3、服务器收到请求，就去数据库相应的表里面查询有没有这样一条记录：即get请求传过来的参数(uuid)跟一个微信用户id(其实就是微信号)绑定的一条记录，如下图所示：<br><img src="/2018/05/12/企业软件开发-负载均衡/pic3.png" alt=""></p><ul><li>1）如果没有这条记录，该请求会在服务器端保持27秒左右（如果用php实现，估计就是sleep一下，再查一下数据库，sleep一下，又查一下数据库，27秒之后还没有查到上面那条记录，就返回window.code=408）<br><img src="/2018/05/12/企业软件开发-负载均衡/pic4.png" alt=""><br><img src="/2018/05/12/企业软件开发-负载均衡/pic5.png" alt=""><br>页面收到这个返回值，则又发出一条请求（还是同样的请求，在服务器端保持27秒左右没有结果，就返回window.code=408，页面收到之后，再次发出请求，如此循环下去，直接找到这条记录）</li><li>2）如果有这条记录，而且ischeck=0，就显示<br><img src="/2018/05/12/企业软件开发-负载均衡/pic6.png" alt=""></li></ul><p>4、微信页面继续发送刚才的请求，这次就是查询ischeck字段是不是为1了：</p><ul><li>1）如果为1，则服务器给这个uuid对应的微信号做一个登录（比如session登录的，就用写入一个session），并返回一个cookie给浏览器用于保存登录状态，说这个微信号网页版已经登录了，而且还返回了登录跳转url，微信页面根据这个返回值，用js的window.location.href类似的方法，跳转一下，并加载登录后所需要的资源，到此，微信网页版登录完成。</li><li>2）如果不为1，则在服务器端保持27秒左右后，又回到原始的登录页面（相当于没有用手机扫描过，而且手机端再点登录网页版微信的时候，会提示那个二维码已经失效）</li></ul><p>5、至于微信查询的数据库的那条信息是执行插入呢？那肯定是手机了，手机访问二维码上的链接，带着唯一的uuid和自己的微信号，去插入这条信息，插入成功后，服务器会返回一个状态给微信，微信上就变成了一个按钮，要你确认是否登录微信，如果你点了确认，那么服务器上的这个uuid对应的那条记录的ischeck字段，就会被标记为1，由于客户端一直在反复查询是否有这条记录以及如果有这条记录，ischeck字段是否为1，所以能实现手机点击了确认，客户端就立刻跳转登录了。<br>6、对于验证过程，Open API 一般是通过授权令牌（Token）来解决的，原理是当用户通过授权后，分配一个限定条件下的令牌（如限制本机访问、限制授权有效时间、限制同时登录设备数等），使获得授权的用户仅在有限的前提下能访问相关服务。 像计算机休眠后曾做的授权就自动收回了，这样就有效的避免了在别人电脑上（尤其是网吧）打开，但忘记关闭或退出这类安全问题了。同时，整个授权过程的验证部分在手机端进行，有效杜绝了 PC 上泛滥的各类木马、『安全工具』的监听，大大降低了帐号被盗的风险。所以说，核心过程应该是：浏览器获得一个临时 id，通过长连接等待客户端扫描带有此 id 的二维码后，从长连接中获得客户端上报给 server 的帐号信息进行展示。 并在客户端点击确认后，获得服务器授信的令牌，进行随后的信息交互过程。 在超时、网络断开、其他设备上登录后，此前获得的令牌或丢失、或失效，对授权过程形成有效的安全防护。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;负载均衡&lt;/strong&gt; 是大型网站解决高负荷访问和大量并发请求采用的终极解决办法。一个典型的使用负载均衡策略的是：在软件
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="企业软件开发" scheme="http://yoursite.com/tags/%E4%BC%81%E4%B8%9A%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>项目管理_知识点总结</title>
    <link href="http://yoursite.com/2018/05/02/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86-%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/05/02/项目管理-知识点总结/</id>
    <published>2018-05-02T09:24:23.000Z</published>
    <updated>2018-09-22T07:36:53.673Z</updated>
    
    <content type="html"><![CDATA[<h2 id="项目管理概述"><a href="#项目管理概述" class="headerlink" title="项目管理概述"></a>项目管理概述</h2><h3 id="项目与运营"><a href="#项目与运营" class="headerlink" title="项目与运营"></a>项目与运营</h3><p><strong>项目(project)</strong> 是“为创造一个特定的产品、服务或者成果而采取的临时性的努力”<br><strong>运营(operation)</strong> 是在组织中为了维持业务而进行的工作</p><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><ul><li>项目有一个特定的目的</li><li>项目是临时性的</li><li>项目是通过不断完善细节而逐步开展的</li><li>项目通常需要来自不同领域的资源</li><li>项目应有一个主要客户或发起人 <strong>(project sponsor)</strong>–一般为项目提供方向和资金</li><li>项目含有不确定性</li></ul><h3 id="项目约束"><a href="#项目约束" class="headerlink" title="项目约束"></a>项目约束</h3><p><strong>三项约束(triple constraint)</strong></p><ul><li>范围</li><li>时间</li><li>成本<br>有些人将质量与三项约束合称为 <strong>四项约束</strong></li></ul><h3 id="项目管理"><a href="#项目管理" class="headerlink" title="项目管理"></a>项目管理</h3><p><strong>project management</strong> 是指“在项目活动中运用专门的知识、技能、工具和技术，以满足项目需求”</p><h4 id="项目干系人"><a href="#项目干系人" class="headerlink" title="项目干系人"></a>项目干系人</h4><p><strong>stakeholder</strong> 是指参与项目或受项目活动影响的人，包括项目发起人、项目团队、支持人员、客户、使用者、供应商，甚至是项目的反对者</p><h4 id="项目管理知识领域"><a href="#项目管理知识领域" class="headerlink" title="项目管理知识领域"></a>项目管理知识领域</h4><p><strong>project management knowledge area</strong> 指的是项目经理必须具备的一些重要知识和能力</p><ul><li>项目范围管理</li><li>项目时间管理</li><li>项目成本管理</li><li>项目质量管理</li><li>项目人力资源管理</li><li>项目沟通管理</li><li>项目风险管理</li><li>项目采购管理</li><li>项目干系人管理</li><li>项目综合管理</li></ul><h4 id="项目管理工具和技术"><a href="#项目管理工具和技术" class="headerlink" title="项目管理工具和技术"></a>项目管理工具和技术</h4><p><strong>project management tool and technique</strong> 用来帮助项目经理和他们的团队进行十大知识领域的项目管理从而完成工作</p><ul><li>甘特图(Gantt chart)</li><li>项目网络图(project network diagram)</li><li>关键路径分析(critical path analysis)</li></ul><h4 id="项目成功的标准"><a href="#项目成功的标准" class="headerlink" title="项目成功的标准"></a>项目成功的标准</h4><ul><li>项目达到了范围、时间和成本目标</li><li>项目使客户或者项目发起人感到满意</li><li>项目的结果达到了主要目标</li></ul><h3 id="项目群和项目组合管理"><a href="#项目群和项目组合管理" class="headerlink" title="项目群和项目组合管理"></a>项目群和项目组合管理</h3><p><strong>program</strong> 是指“一组相互联系的项目，宜使用协同方法进行管理来获得收益和进行控制，而这种收益和控制在单独管理这些项目时是不易获得的”<br><strong>项目群经理program manager</strong> 对领导项目群内项目的项目经理进行领导并指明方向。同样会协调项目团队、职能部门、供应商和运营员工的努力，以支持项目并保证项目产品和过程达到最大的收益。<br><strong>项目组合管理project portfolio management</strong> 将项目以及项目群组合并进行管理，使其作为一个投资组合，从而促成整个企业的成功</p><ul><li>项目管理致力于 <strong>战术目标Tactical goals</strong> ，即为短期的更为具体的目标</li><li>项目组合管理致力于 <strong>战略目标Strategic goals</strong> ，即为一个组织的长期目标</li></ul><h3 id="项目经理"><a href="#项目经理" class="headerlink" title="项目经理"></a>项目经理</h3><h3 id="项目管理专业"><a href="#项目管理专业" class="headerlink" title="项目管理专业"></a>项目管理专业</h3><p><strong>甘特图Gantt chart</strong> 是一种标准格式，它通过在日程表上列出各种项目活动及各自的开始和结束的时间来显示项目的进度信息。<br><strong>关键路径critical path</strong> 就是网络图中最长的路径，它决定着一个项目最早完成的日期，显示了一个项目的哪些任务影响了目标完成日期，并且它可以随着工作进展和更多信息变得可用而发生改变。<br><strong>项目管理办公室project management office,PMO</strong> 是一个有组织的团队，负责协调整个组织中的项目管理功能。<br><strong>项目管理协会Project management Institute,PMI</strong> ，国际性的项目管理专业协会,PMI提供 <strong>项目管理师Project management Professional,PMP</strong> 职业认证。</p><hr><h2 id="项目管理和IT背景"><a href="#项目管理和IT背景" class="headerlink" title="项目管理和IT背景"></a>项目管理和IT背景</h2><h3 id="项目管理的系统观点"><a href="#项目管理的系统观点" class="headerlink" title="项目管理的系统观点"></a>项目管理的系统观点</h3><p><strong>系统思维system thinking</strong> 描述了在组织的背景中执行项目的整体观点。<br><strong>系统方法system approach</strong> 是指采用整体的和分析的方法来解决复杂问题，包括使用系统哲学、系统分析和系统管理等方法。<br><strong>系统哲学system philosophy</strong> 是一整套系统地思考事物的思维模式。<br><strong>系统System</strong> 是为达到某些目的而在一个环境中运行的、由相互作用的要素组成的集合。<br><strong>系统分析system analysis</strong> 是解决问题的一种方法，需要定义所研究系统的范围，然后将它分解成各个部分来确认与评估相应的问题、机会、约束和需求。<br><strong>系统管理system management</strong> 处理与系统的创建、维护和改变相关的业务、技术和组织问题。<br><strong>三球模型the three-sphere model</strong> 处理三类问题： <strong>业务business、组织organization、技术technology</strong></p><h3 id="组织问题"><a href="#组织问题" class="headerlink" title="组织问题"></a>组织问题</h3><h4 id="组织框架"><a href="#组织框架" class="headerlink" title="组织框架"></a>组织框架</h4><ul><li><strong>结构框架structural frame</strong> 角色和责任，合作，控制。</li><li><strong>人力资源框架human resources frame</strong> 在组织需要和人力需求之间进行协调。</li><li><strong>政治框架political frame</strong> 由不同个人和利益集团联合组成，冲突和权利是关键问题。</li><li><strong>符号框架symbolic frame</strong> 事件相关的符号和意义。文化、语言、传统以及形象是这个框架的所有部分。</li></ul><h4 id="组织结构"><a href="#组织结构" class="headerlink" title="组织结构"></a>组织结构</h4><p><strong>组织结构organization structure</strong> 一般分为三类：</p><ul><li><strong>职能型fuctional</strong></li><li><strong>项目型project</strong></li><li><strong>矩阵型matrix</strong></li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic1.png" alt=""><br><img src="/2018/05/02/项目管理-知识点总结/pic2.png" alt=""></p><h4 id="组织文化"><a href="#组织文化" class="headerlink" title="组织文化"></a>组织文化</h4><p><strong>organization culture</strong> 是一系列共同的能够刻画组织职能的设想、价值和行为<br>组织文化有10个特点：</p><ul><li>成员认同度member identity</li><li>团队专注度group emphasis</li><li>人员聚集度people focus</li><li>单元集成度unit integration</li><li>控制力control</li><li>抗风险能力risk tolerance</li><li>奖励标准reward criteria</li><li>抗冲突能力conflict tolerance</li><li>结果导向度means-ends orientation</li><li>开放系统聚集度open-systems focus</li></ul><h3 id="干系人管理"><a href="#干系人管理" class="headerlink" title="干系人管理"></a>干系人管理</h3><h4 id="高层管理承诺的重要性"><a href="#高层管理承诺的重要性" class="headerlink" title="高层管理承诺的重要性"></a>高层管理承诺的重要性</h4><p>一些项目有一个称为 <strong>倡导者champion</strong> 的高级经理，扮演着项目的关键支持者。<br><strong>Top management Commitment</strong> 对于项目经理来说至关重要。原因如下：</p><ul><li>项目经理需要足够的资源</li><li>项目经理经常需要及时得到对于特定项目需求的认可</li><li>项目经理必须与组织内其他部门的人进行合作</li><li>项目经理通常需要在领导力方面获得指导和帮助</li></ul><h4 id="组织对信息技术投入的需求"><a href="#组织对信息技术投入的需求" class="headerlink" title="组织对信息技术投入的需求"></a>组织对信息技术投入的需求</h4><p><strong>The Need for Organizational Commitment to Information Technology</strong><br><strong>首席信息官CIO</strong> ，公司为IT主管设立的副总裁或者相当的职位。</p><h4 id="组织对标准的需求"><a href="#组织对标准的需求" class="headerlink" title="组织对标准的需求"></a>组织对标准的需求</h4><p><strong>首席项目官CPO</strong> ，进一步增加项目管理的力度。</p><h3 id="项目阶段和项目生命周期"><a href="#项目阶段和项目生命周期" class="headerlink" title="项目阶段和项目生命周期"></a>项目阶段和项目生命周期</h3><p><strong>项目生命周期project life cycle</strong> 是一系列项目阶段的集合，定义了在每个阶段中要进行的工作，包括什么时候给出什么样的可交付成果，每个阶段涉及的人员和时间，以及管理层将如何控制和验证每个阶段中产生的工作。<br><strong>可交付成果deliverable</strong> 是一个产品或者服务，作为项目的一部分而生产或提供的。</p><blockquote><p>在项目生命周期的早期阶段，对资源的需求是最低的，而不确定性的程度是最高的。  </p></blockquote><p><strong>项目可行性project feasibility</strong> 是指前两个传统的项目阶段(概念和开发)关注计划编制。<br><strong>项目获取project acquisition</strong> 是指后两个阶段(实施和收尾)关注实际工作的交付。<br><strong>工作分解结构WBS</strong> 通过把工作分解成不同级别的任务粗略描述了项目的工作。<br><img src="/2018/05/02/项目管理-知识点总结/pic3.png" alt=""><br><img src="/2018/05/02/项目管理-知识点总结/pic4.png" alt=""><br><strong>系统开发生命周期system devalopment life cycle,SDLC</strong> 是一个描述开发信息系统不同阶段的框架。其通用模型都是 <strong>可预测生命周期predictive life cycle</strong> 的模型，意味着可以很明确地表达项目的范围，并且可以精确预测进度和成本。包括：</p><ul><li>瀑布模型waterfall model</li><li>螺旋模型spiral model</li><li>渐增式构建模型incremental build model</li><li>原型模型prototyping model</li><li>快速应用开发模型Rapid Application Development,RAD</li></ul><p><strong>自适应软件开发adaptive software Development,ASD</strong> 生命周期模型假定软件开发是遵循一种自适应的方法的，因为在生命周期的早期需求不能被清晰地描述。<br><strong>敏捷软件开发agile software Development</strong> 已经成为一种流行的新方法，强调开发团队和业务专家之间的紧密协作。<br>高层管理的评审通常称为 <strong>阶段出口Phase exit</strong> 或者 <strong>检查点kill point</strong> ，对于保持项目的进度以及决定是否应该继续、改变方向或者终止项目是非常重要的。</p><h3 id="IT项目的环境"><a href="#IT项目的环境" class="headerlink" title="IT项目的环境"></a>IT项目的环境</h3><ul><li>IT项目的本质<ul><li>IT项目可能有很多变化</li><li>IT项目同样支持每一种可能的行业和业务功能</li></ul></li><li>IT项目团队成员的特征</li><li>多样的技术</li></ul><h3 id="影响IT项目管理的最新趋势"><a href="#影响IT项目管理的最新趋势" class="headerlink" title="影响IT项目管理的最新趋势"></a>影响IT项目管理的最新趋势</h3><ul><li><strong>全球化globalization</strong> ，当运作全球化项目时，项目经理需要解决：<ul><li>沟通</li><li>信任</li><li>共同的工作方式</li><li>工具</li></ul></li><li><strong>外包outsourcing</strong> 即一个组织从外部寻找来源以获取需要的产品和服务； <strong>海外外包offshoring</strong> 用来描述安排在另外一个国家的外包(跨国完成的外包工作)。</li><li><strong>虚拟团队virtual team</strong> 是指运用通讯技术实现跨时间和跨地域工作的个人组成的团队</li></ul><p><strong>Scrum</strong> 是为了完成具有复杂的、创新的工作范围项目的一种领先的敏捷开发方法。</p><hr><h2 id="项目管理过程组"><a href="#项目管理过程组" class="headerlink" title="项目管理过程组"></a>项目管理过程组</h2><p><strong>过程process</strong> 是针对某一特定结果的一系列行动。<br><strong>项目管理过程组project management process group</strong> 包括：</p><ul><li><strong>预启动</strong>：商业论证business case</li><li><strong>启动过程initiating process</strong> 包括定义和批准项目或者项目阶段。</li><li><strong>计划过程planning process</strong> 包括制定和维护一个可执行的计划，以保证项目满足组织的要求。其 <strong>输出</strong> 包括要完成项目范围说明、工作分解结构、项目进度表和其他内容</li><li><strong>执行过程executing process</strong> 包括协调人力和其他资源来执行项目的计划，以产生项目或者项目阶段的产品、服务或者结果。其 <strong>主要成果</strong> 是产生项目的实际工作。</li><li><strong>监控过程monitoring and controlling process</strong> 包括有规律地测量和监视项目进展，以保证项目团队能够满足项目目标。其 <strong>理想产出</strong> 是通过交付满足时间、成本和质量约束的项目来成功地完成项目。</li><li><strong>收尾过程closing process</strong> 包括对项目或者项目阶段的正式验收，并有效地终止。其 <strong>关键产出</strong> 是工作的正式验收和结束文档的撰写。</li></ul><blockquote><p>通常执行过程是最需要资源和时间的，其次是计划过程。启动和收尾过程通常是最短的，要求资源和时间也最少。</p></blockquote><p><strong>将过程组映射到知识领域</strong><br><img src="/2018/05/02/项目管理-知识点总结/pic5.png" alt=""><br><strong>方法学methodology</strong> 描述应该如何去做事情，不同的组织通常有不同做事方式。</p><ul><li>受控环境下的项目管理(PRINCE2)：定义了45个独立子进程，并将它们分为8个过程组</li><li>敏捷方法:一般用于 <strong>项目业务团队在产品生命周期早期不能清楚表达项目范围，但团队确实想在项目早期而不是后期提供一个潜在的可交付产品</strong> 的这类项目。</li><li>统一软件开发过程(RUP)框架：迭代的软件开发过程</li><li>六西格码方法论：DMAIC、DMADV</li></ul><hr><h2 id="项目综合管理"><a href="#项目综合管理" class="headerlink" title="项目综合管理"></a>项目综合管理</h2><p><strong>项目综合管理project integration management</strong> 涉及在整个项目生命周期中协调所有其他项目管理的知识领域。主要包括：</p><ul><li><strong>制定项目章程Developing the project charter</strong></li><li><strong>开发项目管理计划Developing the project management plan</strong></li><li><strong>指挥并管理项目执行Directing and managing project work</strong></li><li><strong>监控项目工作monitoring and controlling project work</strong></li><li><strong>综合变更控制performing integrated change control</strong></li><li><strong>项目或阶段收尾Closing the project or phase</strong></li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic6.png" alt=""><br>项目综合管理包括 <strong>接口管理interface management</strong> ，涉及识别和管理项目众多要素间相互作用的交接点。随着参与项目的人数的增加，这种接口的数量会呈指数增加。因此项目经理需要建立并维持组织界面间良好沟通和关系。</p><h3 id="战略计划与项目选择"><a href="#战略计划与项目选择" class="headerlink" title="战略计划与项目选择"></a>战略计划与项目选择</h3><p><strong>战略计划strategic planning</strong> 包括通过分析组织的优势和劣势，研究在商业环境中的机会和威胁，预测未来的趋势，以及预测对新产品和新服务的需求来确定长期目标。<br><strong>SWOT分析</strong> 包括分析 <strong>优势strength、劣势weakness、机会opportunity、威胁threat</strong> 。<br>SWOT分析的流行方法有 <strong>思维导图mind mapping</strong> ，是一种结构分解的技术，通过从一种核心理念发散出来的方式将想法和概念结构化。<br><img src="/2018/05/02/项目管理-知识点总结/pic17.png" alt=""></p><p><strong>选择项目的方法</strong> ：</p><ul><li>聚焦于广泛的组织需求:确定它们是否满足 <strong>需求need、资金funding、意愿will</strong></li><li>将IT项目分类<ul><li><strong>问题problem</strong> 是人们不期望出现的那些造成组织无法实现其目标的情况。</li><li><strong>机遇opportunity</strong> 是改善组织的机会。</li><li><strong>指示directive</strong> 是由管理层、政府或者某些外部影响施加的新要求。</li></ul></li><li>进行净现值分析、投资回报率和投资回收期分析<ul><li><strong>净现值NPV分析</strong> 就是一种计算预期净货币收益或损失的方法，该计算方法将当前时间点之后的所有未来预期现金流入和流出都作折现计算。NPV分析是一种对持续多年项目的现金流的一种公平比较。正的NPV值意味着一个项目的回报超过了其 <strong>资本成本cost of capital</strong> ，即把资金投资在别的地方可以获得的回报。在其他因素都一样的情况下，具有较高NPV值的项目比具有较低NPV值的项目更理想。<br>要确定NPV，按照以下步骤进行：<ul><li>为项目生命周期和其产出的产品确定预期成本和收益</li><li>确定 <strong>折现率discount rate</strong> ，将未来现金流折现的比率，也称为 <strong>资本率capitalization rate、资本的机会成本opportunity cost of capital</strong></li><li>计算NPV<br>$NPV=\sum_{t=0…n}A_t/(1+r)^t$，其中t为现金流的某年，n为现金流的最后一年，A是每年的现金流数目，r是折现率。</li></ul></li><li><strong>投资回报率ROI</strong> 是项目的收益减去成本并处以成本的结果。<br><strong>ROI=(折现收益总额-折现成本总额)/折现成本</strong><br><strong>要求回报率required rate of return</strong> 是每项投资中要求要达到的最低回报率。<br>通过发现导致项目的NPV为0的折现率，来确定投资的 <strong>内部收益率IRR</strong></li><li><strong>投资回收期分析payback period</strong> 是指净现金流的形式补偿项目总的投资所需要的时间，换言之，就是确定需经过多长时间累积收益等于累积成本以及后续成本。</li></ul></li><li>使用加权评分模型<br><strong>weighted scoring model</strong> 是一种基于多种标准进行项目选择的系统方法</li><li>实施平衡记分卡<br><strong>balanced scorecard</strong> 是一种方法论，将组织的价值驱动因素转换成一组定义好的衡量维度。</li></ul><p><strong>制定项目章程project charter</strong> ，用来正式确认项目存在并明确项目目标和项目管理的一种文件。启动过程的主要输出为项目章程，可以有以下输入：</p><ul><li><strong>项目工作说明书a project statement of work</strong></li><li><strong>商业论证a business case</strong></li><li><strong>合同agreements</strong></li><li><strong>企业环境因素enterprise environmental factors</strong></li><li><strong>组织过程资产信息organizational process assets</strong></li></ul><h3 id="创建项目管理计划"><a href="#创建项目管理计划" class="headerlink" title="创建项目管理计划"></a>创建项目管理计划</h3><p><strong>project management plan</strong> 是用于协调所有项目计划文档，并帮助指导项目的执行和控制的一种文件。项目管理计划应该是动态的、灵活的，并且随着环境或项目的变化而变化。</p><h3 id="指导和管理项目实施"><a href="#指导和管理项目实施" class="headerlink" title="指导和管理项目实施"></a>指导和管理项目实施</h3><p>主要内容是管理和实施在项目管理计划中确定的工作，还包括批准的变更请求、企业环境因素以及组织过程资产。</p><ul><li>协调计划和执行</li><li>提供强大领导力和支持性文化</li><li>利用产品、业务和应用领域知识</li><li>项目执行工具和技术<ul><li>专家评审法</li><li>会议</li><li>项目管理信息系统</li></ul></li></ul><h3 id="监控项目工作"><a href="#监控项目工作" class="headerlink" title="监控项目工作"></a>监控项目工作</h3><p>包括收集、衡量与发布绩效信息。还涉及评估度量与分析趋势以确定可以做出怎样的过程优化。<br><strong>基线baseline</strong> 是批准的项目管理计划加上批准的变更。<br><strong>重要输入：</strong></p><ul><li>项目管理计划</li><li>进度表</li><li>成本预算</li><li>变更确认</li><li>工作绩效信息</li><li>企业环境因素</li><li>组织过程资产</li></ul><p><strong>重要输出是：</strong></p><ul><li>变更请求<ul><li>推荐的纠正措施</li><li>预防措施</li><li>缺陷补救措施</li></ul></li><li>工作绩效报告</li></ul><h3 id="执行综合变更控制"><a href="#执行综合变更控制" class="headerlink" title="执行综合变更控制"></a>执行综合变更控制</h3><p><strong>综合变更控制integrated change control</strong> 涉及在项目的全生命周期中识别、评估及管理变更。主要的3个目标：</p><ul><li>影响那些产生变更的因素以确保变更都是有利的</li><li>确定一个变更已经出现过</li><li>及时地管理真正的变更</li></ul><p><strong>重要输入：</strong></p><ul><li>项目管理计划</li><li>工作绩效信息</li><li>变更请求</li><li>企业环境因素</li><li>组织过程资产</li></ul><p><strong>重要输出：</strong></p><ul><li>被批准的变更请求</li><li>变更日志</li><li>项目管理计划</li><li>文档的更新</li></ul><p><strong>变更控制系统change control system</strong> 是一个正式的、文档化的过程，描述了正式文档何时以及如何可以被变更。包括;</p><ul><li><strong>变更控制委员会change control board,CCB</strong> 是负责批准或否决项目变更的正式团体，主要职责是为准备变更请求提供指南、评价变更请求以及管理和实施核准的变更。</li><li><strong>配置管理configuration management</strong> 确保关于项目产品的描述是正确且完整的。</li><li><strong>用于沟通变更的流程</strong></li></ul><h3 id="项目或阶段收尾"><a href="#项目或阶段收尾" class="headerlink" title="项目或阶段收尾"></a>项目或阶段收尾</h3><p>将所有活动终止，并将已完成或取消的工作移交给适当的人员。<br><strong>主要输入：</strong></p><ul><li>项目管理计划</li><li>已接受的交付物</li><li>组织过程资产</li></ul><p><strong>主要工具和技术：</strong> 专家评审<br><strong>主要输出：</strong></p><ul><li>最终产品、服务或成果转移</li><li>组织过程资产更新</li></ul><p><strong>业务服务管理business service management,BSM</strong> 有助于将项目与企业战略相匹配的工具。</p><hr><h2 id="项目范围管理"><a href="#项目范围管理" class="headerlink" title="项目范围管理"></a>项目范围管理</h2><p><strong>范围scope</strong> 是指开发项目产品所涉及的所有工作和用来开展工作的所有过程。<br><strong>可交付成果deliverable</strong> 指作为项目的一部分而生产的产品。<br><strong>项目范围管理project scope management</strong> 是指对项目包括什么与不包括什么的界定和控制的过程。</p><ul><li><strong>制定范围管理计划</strong> 是指确定项目的范围和需求如何管理。<strong>输出</strong> 是范围管理计划和需求管理计划。</li><li><strong>收集需求collecting requirement</strong> 是指定义并记录项目最终产品的特点和功能，以及创造这些产品的过程。<strong>输出</strong> 是项目团队编制的需求文档和需求跟踪矩阵。<ul><li>通常是最困难的。</li><li>收集方法：原型法和文档分析法</li><li><strong>基准测试bench marking</strong> 是通过与执行组织的内部或外部的其他项目或产品进行比较，以获得具体项目实践或产品特征的需求思想。</li><li><strong>需求跟踪矩阵Requirement Traceability Matrix,RTM</strong> 是列出各种需求、需求属性和需求状态的一种表格，以确保所有需求被跟踪。</li></ul></li><li><strong>定义范围scope definition</strong> 是指评审范围管理计划、项目章程、需求文档和组织过程资产来创建一份范围说明书，并且随着需求的扩展和变更请求得到批准而增加更多的信息。<strong>输出</strong> 是项目范围说明书以及项目文档的更新。</li><li><strong>创建工作分解结构creating the WBS</strong> 是指将主要的项目可交付成果分解成更细小更易管理的部分。<strong>输出</strong> 是范围基线(工作分解结构、WBS词典)及项目文档的更新<ul><li><strong>WBS</strong> 是对项目所涉及工作面向交付成果的分组，定义了项目的全部范围。</li><li><strong>WBS分级</strong><ul><li>层级1：项目名称</li><li>层级2：工作分组，“概念”</li><li>层级3：定义需求</li><li>层级4：定义用户需求、(工作包)</li></ul></li><li><strong>工作包work package</strong> 即为WBS最底层的一项任务。</li><li>制作WBS的方法：<ul><li><strong>使用指南</strong></li><li><strong>类比法analogy approach</strong></li><li><strong>自上而下法top-down approach</strong> ，从项目最大条目开始，将它们分解为次一级的条目。</li><li><strong>自下而上法bottom-up approach</strong> ，先识别尽可能多的与项目有关的具体任务，再将这些具体任务集中并组织成概要任务或WBS中较高层次。</li><li><strong>思维导图法</strong></li></ul></li><li><strong>WBS字典dictionary</strong> 是一个描述WBS每项条目详细信息的文件。</li></ul></li><li><strong>验证范围validation scope</strong> 是指项目可交付成果的正式接受。<strong>输出</strong> 是被接受的可交付成果、变更请求、工作绩效信息以及项目文档更新。<ul><li><strong>范围蔓延scope creep</strong> 项目范围不断扩大的趋势。</li></ul></li><li><strong>控制范围controlling scope</strong> 是指对整个项目生命周期内的范围变化进行控制。<strong>输出</strong> 是工作绩效信息、变更请求、项目管理计划、项目文档和组织过程资产的更新。<ul><li>主要工具：实施偏差分析。<strong>偏差variance</strong> 是计划的与实际的效果之间的区别。</li><li>对于减少不完善和不断变化的需求的建议：<ul><li><strong>原型开发prototyping</strong> 是指开发系统或者系统的某些方面的可运行的副本，以帮助定义用户需求。</li><li><strong>用例建模</strong> 是一种对业务事件、启动者及系统响应方式进行识别与建模的过程。</li><li><strong>联合应用设计JAD</strong> 使用高度组织化和集中式的工作会议将项目干系人结合起来共同定义设计信息系统。</li></ul></li></ul></li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic7.png" alt=""></p><hr><h2 id="项目时间管理"><a href="#项目时间管理" class="headerlink" title="项目时间管理"></a>项目时间管理</h2><p><strong>project time management</strong> 就是确保项目按时完成所需的过程。</p><ul><li><strong>计划进度管理</strong> 是指确定将用于计划、执行和控制项目进度的政策、流程和文档。<strong>输出</strong> 是进度管理计划。<ul><li>项目进度模型的开发</li><li>在开发项目进度模型中使用的方法和工具：关键路径和关键链方法</li><li>精度水平和计量单位</li><li>控制阈值</li><li>性能测量的规划</li><li>报告格式</li><li>过程描述</li></ul></li><li><strong>定义活动</strong> 是指识别项目团队成员和干系人必须执行并产生项目的可交付成果的特定活动。<strong>活动activity或任务task</strong> 是工作的组成要素，通常出现在WBS中，有预计的工期、成本和资源要求。<strong>输出</strong> 是活动清单、活动属性、里程碑清单和更新的项目管理计划。<ul><li><strong>活动清单activity list</strong> 是包含在项目进度中的活动列表，包括活动名称、活动标识以及活动的简短描述。</li><li><strong>活动属性activity attribute</strong> 提供了与进度相关的更多信息，例如前导活动predecessors、后继活动successors、逻辑关系logical relationships等。</li><li><strong>项目的里程碑milestone</strong> 是项目中一个通常没有工期的重要事件。</li><li>活动定义过程的目标是保证项目团队完全理解他们必须做的所有工作是作为项目范围的一部分，以便他们能够开始安排工作进度。</li></ul></li><li><strong>排序活动</strong> 是指识别和记录项目活动之间的依赖关系。<strong>输出</strong> 是项目的进度网络图和更新的项目文档。<ul><li><strong>依赖dependency或关系relationship</strong> 与项目活动或任务的排序相关。</li><li>为项目活动之间创建依赖关系有三个基本原因：<ul><li><strong>强调依赖mandatory dependencies</strong> 是项目工作中内在的一种关系。某些时候称为 <strong>硬逻辑</strong></li><li><strong>自由依赖discretionary dependencies</strong> 是由项目团队定义的项目活动之间的关系</li><li><strong>外部依赖external dependencies</strong> 涉及项目和非项目活动之间的关系</li></ul></li><li><strong>网络图network diagram</strong> 是表示活动排序的首选技术，是项目活动之间的逻辑关系或者顺序的示意性的表示。<ul><li>网络图的格式使用的是 <strong>双代号网络图AOA或者箭线图法ADM</strong></li><li>网络图表示的是那些完成项目所必须执行的活动。</li><li>并不是WBS的每个项都出现在网络图上，只有与活动有关的依赖项需要显示</li><li><strong>前导图法PDM</strong> 也是一种网络图技术，使用方框表示活动</li><li>活动间的4种类型的依赖或者关系：<ul><li>完成-开始(finish-to-start)</li><li>开始-开始(start-to-start)</li><li>完成-完成(finish-to-finish)</li><li>开始-完成(start-to-finish)</li></ul></li><li>前导图比AOA网络图的优势所在:<ul><li>多数的项目管理软件使用前导图</li><li>前导图法避免了 <strong>虚活动dummy activity</strong> 的需要</li></ul></li></ul></li></ul></li><li><strong>估算活动资源</strong> 是指估算一个项目团队应该使用多少资源(人力、设备和原料)来执行项目活动。<strong>输出</strong> 是活动资源需求、资源分解结构(resource breakdown structure)和更新的项目文档。</li><li><strong>估算活动工期</strong> 是指估算完成单项活动所需的工作时间。<strong>输出</strong> 是活动工期估算和更新的项目文档。<ul><li><strong>工期duration</strong> 包括活动上花费的实际时间和占用时间。</li><li>工期估算：离散的数字、时间范围、<strong>三点估算three-point estimate</strong> 包括乐观、最可能和悲观的估算。</li></ul></li><li><p><strong>制定进度计划</strong> 是指分析活动序列、活动资源估算和活动工期估算来创建项目进度。<strong>输出</strong> 是进度基线、项目进度、进度数据、项目日历、更新的项目管理计划和更新的项目文件。</p><ul><li><strong>甘特图Gantt chart</strong><ul><li>在甘特图上增加里程碑。根据 <strong>SMART准则</strong> ，里程碑应当是;<ul><li>明确的specific</li><li>可度量的measurable</li><li>可分配的assignable</li><li>现实的realistic</li><li>有时间限制的time-framed</li></ul></li><li>使用跟踪甘特图来比较计划和实际的日期<ul><li><strong>跟踪甘特图tracking Gantt chart</strong> 一个比较计划和实际项目进度信息的甘特图。</li><li><strong>基线日期baseline date</strong> 活动的计划进度日期</li><li><strong>进度基线schedule baseline</strong> 整个经过审批的计划进度</li><li><strong>偏移的里程碑slipped milestone</strong> 意味着里程碑活动的实际完成时间比原来计划的要晚。白色菱形white diamond</li></ul></li></ul></li><li><p><strong>关键路径法critical path method,CPM</strong> 又称为 <strong>关键路径分析</strong> ，是一种网络图技术，用来预测整个项目的工期。</p><ul><li>项目的 <strong>关键路径</strong> 决定了项目最早完成时间的活动序列，是网络图的最长路径，其时差或者浮动时间最少。</li><li><strong>时差slack或者浮动时间float</strong> 指的是在不延误后继活动或者项目完成时间的情况下，任务可以推后的时间。</li><li><p>使用关键路径分析来保持进度均衡</p><ul><li><strong>自由时差free slack或者自由浮动时间free float</strong> 是一个活动在不延误紧接活动的最早开始时间的情况下可以被延误的时间。</li><li>一个活动的 <strong>最早开始时间early start date</strong> 是基于项目网络逻辑可以开始的最早的可能时间。</li><li><strong>总时差total slack或者总浮动时间</strong> 是一个活动从它最早开始时间起，在没有拖延计划项目完成日期的情况下被耽搁的时间。</li><li>利用正推和逆推计算自由时差和总时差<ul><li><strong>正推法forward pass</strong> 决定每个活动的最早开始和最早完成时间。一个活动的 <strong>最早完成时间early finish date</strong> 是基于项目网络逻辑最早可能完成的时间，最早开始时间加上第一个活动的工期就等于第一个活动的最早完成时间。</li><li><strong>逆推法backward pass</strong> 可决定最晚开始和最晚完成时间。一个活动的的 <strong>最晚开始时间late start date</strong> 是一个活动在不延迟项目完成时间的最晚可能开始的时间；一个活动的 <strong>最晚完成时间late finish date</strong> 是一个活动在不延迟项目完成时间的最晚可能完成的时间。</li></ul></li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic9.png" alt=""></p></li><li>使用关键路径来缩短项目的进度<ul><li><strong>赶工crashing</strong> 是一种为了以最少的成本最大限度地压缩工期，而在成本与进度之间进行均衡的技术。</li><li><strong>快速跟进fast tracking</strong> 包括并行执行那些通常以顺序方式执行的活动。</li></ul></li></ul></li><li><strong>关键链调度critical chain scheduling</strong> 是一种进度计划方法，在创建项目进度时考虑有限的资源，并且将缓冲包括进来以保护项目完成期限。<ul><li><strong>约束理论TOC</strong></li><li><strong>多任务multitasking</strong> 发生在一个资源在同一时间用于多个任务的时候。</li><li>使用关键链调度时，提高项目完成时间：<ul><li><strong>项目缓冲project buffer</strong> 在项目的完工日期之前增加的附加时间。</li><li><strong>汇入缓冲feeding buffer</strong> 指的是在那些前导是非关键路径任务的关键链任务之前增加的附加时间。</li></ul></li></ul></li><li><strong>计划评审技术PERT</strong><br>PERT使用 <strong>概率时间估算probabilistic time estimate</strong><br><strong>PERT加权平均=(乐观时间+4*最可能时间+悲观时间)/6</strong></li></ul></li><li><strong>控制进度</strong> 是指控制和管理项目进度的变更。<strong>输出</strong> 是工作绩效信息、进度预测、请求变更、项目管理计划的更新、项目文档的更新和组织过程资产的更新。</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic8.png" alt=""></p><hr><h2 id="项目成本管理"><a href="#项目成本管理" class="headerlink" title="项目成本管理"></a>项目成本管理</h2><p><strong>project cost management</strong> 包括用来确保在批准的预算范围内完成项目的必要过程。有4个过程：</p><ul><li>计划成本管理：包括确定用于计划、执行、控制项目成本的政策、程序和文档。<strong>输出</strong> 是成本管理计划。</li><li>成本估算：包括完成项目所需资源的近似或估算成本。<strong>输出</strong> 是活动的成本估算、估算的基础和更新的项目文档。</li><li>确定估算：包括将整体成本估算配置到各单项工作，以建立一个衡量绩效的基线。<strong>输出</strong> 是成本基线、项目资金需求和更新的项目文档。</li><li>成本控制：包括控制项目预算的变更。<br><img src="/2018/05/02/项目管理-知识点总结/pic10.png" alt=""></li></ul><h3 id="成本管理"><a href="#成本管理" class="headerlink" title="成本管理"></a>成本管理</h3><p><strong>利润profit</strong> 是收入减去支出。<br><strong>利润率profit margin</strong> 是利润和收入的比值。<br><strong>生命周期成本life cycle costing</strong> 是对贯穿于整个项目生命周期的成本状况的总体认识。<br><strong>现金流分析cash flow analysis</strong> 是用于确定项目每年的估计成本和收益以及由此产生的年度现金流的一种方法。<br><strong>有形成本或有形收益tangible costs or benefits</strong> 是能够容易地用货币来衡量的成本或收益。<br><strong>无形成本或无形收益intangible</strong> 是那种很难用货币来衡量成本或收益。<br><strong>直接成本direct costs</strong> 是与项目的产品和服务的生产直接相关的成本。例如工作人员的薪金，软硬件的成本等，可控的。<br><strong>间接成本indirect costs</strong> 是与项目的产品和服务的生产不直接相关的成本，但是间接地与项目的绩效挂钩。例如电力费用、纸巾等，不可控的。<br><strong>沉没成本sunk costs</strong> 是过去已经花掉的钱。<br><strong>学习曲线理论learning curve theory</strong> 指出当重复生产许多产品时，那些产品的单位成本随着数量的增多而呈现规律性的递减。<br><strong>储备金reserves</strong> 是包含于成本估算中，为减轻未来难以预测情形带来的成本风险而准备的那部分资金。<br><strong>应急储备金contingency reserves</strong> 是为一些可以部分预计的未来情况(也称已知的不确定事件)做准备，包含于项目的成本基线中。<br><strong>管理储备金management reserves</strong> 是为不能预测的未来情况(也称未知的不确定事件)做准备。</p><h3 id="计划成本管理"><a href="#计划成本管理" class="headerlink" title="计划成本管理"></a>计划成本管理</h3><p>成本管理计划包括：</p><ul><li>精确度</li><li>测量单位</li><li>组织程序链接</li><li>控制临界值</li><li>绩效测量规划</li><li>报告模板</li><li>过程描述</li></ul><h3 id="成本估算"><a href="#成本估算" class="headerlink" title="成本估算"></a>成本估算</h3><p>三种基本的成本估算类型：</p><ul><li>粗粒度估算rough order of magnitude,ROM 提供了项目成本的一个粗略估算。</li><li>预算估算budgetary estimate 用于将资金分配到组织的预算中。</li><li>确定性估算definitive estimate 提供一个精确的项目成本估算</li></ul><p>成本估算的工具和技术</p><ul><li>专家判断</li><li>类比成本估算</li><li>自下而上估算</li><li>三点估算</li><li>参数估算</li><li>质量成本</li><li>项目管理估算软件</li><li>供应商报价分析和储备分析</li></ul><h3 id="成本预算"><a href="#成本预算" class="headerlink" title="成本预算"></a>成本预算</h3><p>成本预算涉及将项目成本估算随时间分配给个体材料资源或单个工作项，这些个体材料资源或工作项是以项目工作分解结构为基础的。成本预算的目的就是编制一个成本基线，用来衡量项目绩效和资金需求。<br><strong>成本基线</strong> 是分时段的预算，项目经理用它来衡量和监控成本性能。</p><h3 id="成本控制"><a href="#成本控制" class="headerlink" title="成本控制"></a>成本控制</h3><p>项目成本控制包括检测成本执行情况、确保一个修改的成本基线中仅仅包括适当的项目变更，以及通知项目干系人那些经核准、影响成本的项目变更。<br><strong>挣值管理earned value management,EVM</strong> 是一个成本控制工具，综合了项目范围、时间和成本数据的项目绩效测量技术。其涉及WBS中的三个值：</p><ul><li><strong>计划值planned value,PV</strong> 也叫预算，是在给定时间内计划花费在某个活动上的已批准总成本估算的部分。</li><li><strong>实际成本actual cost,AC</strong> 是在给定时间内，完成一项活动所产生的直接成本和间接成本的总和。</li><li><strong>挣值earned value,EV</strong> 是实际完成工作的估算值。它是基于项目或活动初始计划成本的，是项目组当前实际完成工作的比率。<strong>完成百分比rate of performance,RP</strong> 是实际完成工作与在项目或活动周期给定时间内已完成计划工作的比率。</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic11.png" alt=""></p><hr><h2 id="项目质量管理"><a href="#项目质量管理" class="headerlink" title="项目质量管理"></a>项目质量管理</h2><p><strong>需求一致性conformance to requirement</strong> 是指项目过程和产品满足书面规范的要求。<br><strong>适用性fitness for use</strong> 是指产品能像它被预期的那样使用。<br><strong>项目质量管理</strong> 的目的是确保项目满足它所应满足的需求。客户是质量是否可接受的最终裁判者。项目质量管理有三个主要过程：</p><ul><li><strong>计划质量管理planning quality management</strong> 包括确认与项目有关的质量需求和标准以及如何满足它们。<strong>输出</strong> 是质量管理计划、过程改进计划、质量度量、质量检查表和项目文档更新。<strong>度量标准metric</strong> 是一个测量的标准，包括产品故障率、产品和服务的可行性以及客户满意度。</li><li><strong>实施质量保证</strong> 包括对整个项目绩效进行定期的评估以确保项目能够满足相关的质量标准。<strong>输出</strong> 是变更请求、项目管理计划更新、项目文档更新和组织过程资产更新。</li><li><strong>控制质量</strong> 包括监控特定的项目结果，确保它们遵循相关质量标准，并确定提高整体质量的方法。工具和技术：<strong>帕累托图、质量控制图、统计抽样</strong> ，<strong>输出</strong> 是质量控制度量、有效的变更、有效的可交付成果、工作绩效信息、变更请求、项目管理计划更新、项目文档更新和组织过程资产更新。</li></ul><h3 id="计划质量管理"><a href="#计划质量管理" class="headerlink" title="计划质量管理"></a>计划质量管理</h3><p><strong>实验设计design of experiment</strong> 是一种质量计划技术，用以帮助确认哪个变量对一个过程的整体结果影响最大。<br>IT项目中影响质量的重要范围部分包括：</p><ul><li><strong>功能性functionality</strong> 是一个系统执行其预定功能的程度。<strong>特色feature</strong> 是吸引用户的系统特性。</li><li><strong>系统输出system output</strong> 是系统产生的界面和报告</li><li><strong>性能performance</strong> 是一个产品或服务如何有效执行客户预期的功能。</li><li><strong>可靠性reliability</strong> 是指一个产品或服务在正常条件下表现出符合预期情况的能力。</li><li><strong>可维护性maintainability</strong> 说明进行产品维护的容易程度。</li></ul><h3 id="质量保证"><a href="#质量保证" class="headerlink" title="质量保证"></a>质量保证</h3><p><strong>质量保证quality assurance</strong> 包括满足一个项目相应质量标准的所有相关活动。<br><strong>持续改善kaizen</strong> 是一个日语词汇，意指更好的改善和改变<br><strong>精益lean</strong> 的目的是实现客户价值最大化，同时尽量减少浪费。<br>几个工具用于质量保证：</p><ul><li>实验设计</li><li>基准比较法benchmarking</li><li>质量审计quality audit</li></ul><h3 id="质量控制"><a href="#质量控制" class="headerlink" title="质量控制"></a>质量控制</h3><p>主要输出：</p><ul><li><strong>验收决策acceptance decision</strong> 确定作为项目的一部分而生产的产品或服务是否通过验收的决策。</li><li><strong>返工rework</strong> 指为使被拒收的项目达到和满足产品需求、规范或干系人的其他期望而采取的行动。</li><li><strong>过程调整process adjustment</strong> 指根据质量控制的度量结果，纠正或防止进一步的质量问题而作的调整。</li></ul><p>用于质量控制的工具和技术：</p><ul><li>七种质量工具<ul><li>因果图cause-and-effect diagram 或者 鱼骨图fishbone diagram 或者 石川图Ishikawa diagram</li><li>控制图control chart、七点运行法则seven run rule(星号表示)</li><li>检查表checksheet</li><li>散点图scatter diagram</li><li>直方图histogram</li><li>帕累托图pareto diagram、帕累托分析又称为80-20法则</li><li>流程图flowchart</li></ul></li><li>统计抽样statistical sampling</li><li>六西格玛法则<br>应用六西格玛进行质量控制的项目通常遵循称为DMAIC的五阶段改进流程：<ul><li>界定define</li><li>度量measure</li><li>分析analyze</li><li>改进improve</li><li>控制control</li></ul></li></ul><h3 id="现代质量管理"><a href="#现代质量管理" class="headerlink" title="现代质量管理"></a>现代质量管理</h3><h3 id="提高IT项目质量"><a href="#提高IT项目质量" class="headerlink" title="提高IT项目质量"></a>提高IT项目质量</h3><ul><li>领导</li><li>质量成本：是一致成本加上不一致成本。<ul><li>一致conformance 指交付满足要求的和适用的产品</li><li>不一致成本cost of nonconformance 指对故障或没有满足质量期望负责<br>与质量相关的5类主要成本：</li><li>预防成本prevention cost</li><li>评估成本appraisal cost</li><li>内部故障成本internal failure cost</li><li>外部故障成本external failure cost</li><li>测量和测试设备成本</li></ul></li><li>组织影响、工作环境因素和质量</li><li>质量中的期望与文化差异</li><li>成熟度模型maturity model<ul><li>软件质量功能配置模型software quality function deployment(SQFD)model</li><li>能力成熟度模型集成capability maturity model integration,CMMI</li><li>项目管理成熟度模型OPM3</li></ul></li></ul><hr><h2 id="项目人力资源管理"><a href="#项目人力资源管理" class="headerlink" title="项目人力资源管理"></a>项目人力资源管理</h2><p>项目人力资源管理就是最有效地发挥每个参与项目人员的作用的过程。包括：</p><ul><li>计划人力资源管理</li><li>组建项目团队</li><li>建设项目团队</li><li>管理项目团队</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic12.png" alt=""></p><h3 id="制定人力资源计划"><a href="#制定人力资源计划" class="headerlink" title="制定人力资源计划"></a>制定人力资源计划</h3><ul><li>项目组织结构图：组织分解结构OBS</li><li>责任分配矩阵RAM：就是将WBS中描述的项目工作与OBS中负责实施的人员相匹配的矩阵<ul><li>责任人responsibility</li><li>批准人accountability</li><li>审核人consultation</li><li>告知人informed</li></ul></li><li>人员配置管理计划staffing management plan和资源直方图resource histogram</li></ul><h3 id="组建项目团队"><a href="#组建项目团队" class="headerlink" title="组建项目团队"></a>组建项目团队</h3><ul><li>人力资源分配</li><li>资源负荷resource loading：是指在特定时段内，既定进度计划所需的个体资源的数量。<ul><li>过度分配overallocation:是指在给定时间内分配给某项工作的资源超过了它可用的资源。</li></ul></li><li>资源平衡resource leveling</li></ul><h3 id="建设项目团队"><a href="#建设项目团队" class="headerlink" title="建设项目团队"></a>建设项目团队</h3><p>团队建设team development的主要目标是帮助人们更有效地一起工作来提高项目绩效</p><ul><li>培训</li><li>团队建设活动<ul><li>梅耶斯-布里格性格类型指示器MBTI</li><li>社交类型模型</li><li>DISC模型</li></ul></li><li>奖励和赏识系统</li></ul><h3 id="管理项目团队"><a href="#管理项目团队" class="headerlink" title="管理项目团队"></a>管理项目团队</h3><p>管理项目团队的工具和技术：</p><ul><li>观察与交谈</li><li>项目绩效评价</li><li>人际技能</li><li>冲突管理</li></ul><hr><h2 id="项目沟通管理"><a href="#项目沟通管理" class="headerlink" title="项目沟通管理"></a>项目沟通管理</h2><p>项目沟通管理的目标是确保项目信息能够及时且适当地生成、收集、发送、存储和部署</p><ul><li>计划沟通管理</li><li>管理沟通<ul><li>用技术手段加强信息的创建和分配</li><li>选择适当的沟通方法和媒介<ul><li>互动沟通</li><li>推送沟通</li><li>拉式沟通</li></ul></li><li>报告绩效<ul><li>状态报告status report</li><li>进度报告progress report</li></ul></li></ul></li><li>控制沟通</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic13.png" alt=""></p><hr><h2 id="项目风险管理"><a href="#项目风险管理" class="headerlink" title="项目风险管理"></a>项目风险管理</h2><p>项目风险管理是关于识别、分析、响应项目全生命周期内的风险，并最好地满足项目目标的科学与艺术。<br><strong>风险偏好risk appetite</strong> 是指实体为了获得期望的回报愿意承担的不确定性程度。<br><strong>风险承受力risk tolerance</strong> 是指在项目或业务目标的潜在影响中实体能够接受的最大的偏差。<br><strong>风险效用risk utility</strong> 是指从潜在回报中得到的满意度。分为：</p><ul><li><strong>风险厌恶型risk-averse</strong></li><li><strong>风险喜好型risk-seeking</strong></li><li><strong>风险中性型risk-neutral</strong></li></ul><p>风险管理涉及的6个主要过程：</p><ul><li>计划风险管理<ul><li>风险管理计划</li><li>应急计划contingency plan</li><li>退路计划fallback plan</li><li>应急储备金contingency或者应急津贴contingency allowance</li></ul></li><li>识别风险<br><strong>风险分解结构</strong> 用来帮助考虑各类潜在风险的工具。<ul><li>识别风险的技术：<ul><li><strong>头脑风暴brainstorming</strong></li><li><strong>德尔菲技术Delphi technique</strong></li><li><strong>访谈interviewing</strong></li><li><strong>SWOT分析</strong></li><li>检查表</li><li>假设分析</li><li>创建图表</li></ul></li><li><strong>风险登记表risk register</strong> 是一份包含了各个风险管理过程结果的文档。</li></ul></li><li>实施定性风险分析<ul><li>使用 <strong>概率/影响矩阵</strong> 计算 <strong>风险因子</strong></li><li>风险定性分析工具：<strong>十大风险事项跟踪</strong></li></ul></li><li>实施定量风险分析<ul><li>决策树是一种图像方法，可以帮助在未来结果不确定的情况下选择最好的行动路径。</li><li>预期货币值EMV是风险事件概率和风险事件货币值的乘积。</li><li>模拟技术：<strong>蒙特卡罗分析MonteCarlo analysis</strong></li><li><strong>灵敏度分析sensitivity analysis</strong></li></ul></li><li>计划风险响应<ul><li>应对负面风险<ul><li>风险规避risk avoidance</li><li>风险承担risk acceptance</li><li>风险转移risk transference</li><li>风险缓解risk mitigation</li></ul></li><li>应对正面风险<ul><li>风险开发risk exploitation</li><li>风险共享risk sharing</li><li>风险增强risk enhancement</li><li>风险承担risk acceptance</li></ul></li><li><strong>残余风险residual risk</strong></li><li><strong>二次风险secondary risk</strong></li></ul></li><li>控制风险</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic14.png" alt=""></p><hr><h2 id="项目采购管理"><a href="#项目采购管理" class="headerlink" title="项目采购管理"></a>项目采购管理</h2><p><strong>project procurement management</strong> 包括为一个项目从外部组织获得商品或服务所需要的过程。包括4个主要过程：</p><ul><li>计划采购管理:<strong>自制/外购决策make-or-buy decision</strong><ul><li>合同类型<ul><li><strong>固定价格合同fixed-price contract或总付合同lump-sum contract</strong>–(买方风险最低)<ul><li><strong>严格固定价格FFP合同</strong></li><li><strong>有奖励的固定价格FPIF合同</strong></li><li><strong>经济价格调整的固定价格合同FP-EPA</strong></li><li>固定价格激励合同可以包括 <strong>总假设点PTA</strong><br><strong>PTA=(最高限价-目标价)/政府份额+目标成本</strong></li></ul></li><li><strong>成本补偿合同cost-reimbursable contract</strong> 包含向供应商支付直接与间接实际成本的合同。。以买方风险从低到高分为：<ul><li><strong>成本加激励合同CPIF contract</strong></li><li><strong>成本加固定费合同CPFF contract</strong></li><li><strong>成本加奖励费合同CPAF contract</strong></li><li><strong>成本加百分比合同CPPC contract</strong></li></ul></li><li><strong>时间与材料合同T&amp;M contract</strong> 是固定价格合同和成本补偿合同的混合。</li></ul></li><li>工具和技术<ul><li>自制/外购分析</li><li>专家评判</li><li>市场调研</li></ul></li><li>采购管理计划</li><li>工作说明书SOW</li><li>采购文档<ul><li><strong>建议书邀请函RFP</strong></li><li><strong>报价邀请函RFQ</strong></li></ul></li></ul></li><li>实施采购<br><strong>建议性变更单 constructive change order</strong> 指具有实际或明显权力的人，以口头或非正式的书面形式提出的意见。</li><li>控制采购</li><li>采购收尾</li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic15.png" alt=""></p><hr><h2 id="项目干系人管理"><a href="#项目干系人管理" class="headerlink" title="项目干系人管理"></a>项目干系人管理</h2><p>项目干系人管理第一次提出是在2012年<strong>PMBOK Guide</strong>上。</p><ul><li>干系人识别<ul><li>内部internal:project sponsor,project team,support staff,internal customers。</li><li>外部external：customers,competitors,suppliers</li></ul></li></ul><p><strong>干系人登记表stakeholder register</strong>：识别信息、评估信息、干系人分类<br><strong>干系人分析stakeholder analysis</strong> 是一种技术，通过分析信息来确定干系人关注什么，以及如何提高干系人对项目的支持。</p><ul><li><strong>权利兴趣网格power/interest grid</strong><ul><li><strong>high interest and high authority</strong> —-manage closely</li><li><strong>high interest and low authority</strong>—-keep inform</li><li><strong>low interest and high authority</strong>—-keep satisfied</li><li><strong>low interest and low authority</strong>—-monitor</li></ul></li><li>干系人管理计划<br>干系人管理计划通常包括敏感信息，<strong>不属于正式的项目文档</strong> ，通常用于所有干系人审查。<ul><li>干系人登记表上的信息</li><li>当前水平和期望水平</li><li>干系人之间的相互关系</li><li>沟通需求</li><li>每个干系人的潜在管理策略</li><li>干系人管理计划更新方法</li></ul></li><li>参与干系人管理<br><strong>期望管理矩阵expectation management matrix</strong> 平衡三项约束进行优先级排序。<br><strong>问题日志issue log</strong> 用来记录、监控和跟踪需要解决问题的一种工具。</li><li>参与干系人控制(早期阶段)</li><li>软件辅助<ul><li>提高通信和协作的技术</li><li>社交媒体</li><li>“击掌庆祝”</li><li>发布评论</li></ul></li></ul><p><img src="/2018/05/02/项目管理-知识点总结/pic16.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;项目管理概述&quot;&gt;&lt;a href=&quot;#项目管理概述&quot; class=&quot;headerlink&quot; title=&quot;项目管理概述&quot;&gt;&lt;/a&gt;项目管理概述&lt;/h2&gt;&lt;h3 id=&quot;项目与运营&quot;&gt;&lt;a href=&quot;#项目与运营&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
      <category term="课堂笔记" scheme="http://yoursite.com/categories/%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="项目管理" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/"/>
    
  </entry>
  
</feed>
